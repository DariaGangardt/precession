<!doctype html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />

    <title>precession API documentation</title>
    <meta name="description" content="**Author** Davide Gerosa

**email** d.gerosa@damtp.cam.ac.uk

**Copyright** Copyright (C) 2016 David..." />

  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>
  
  <style type="text/css">
  
* {
  box-sizing: border-box;
}
/*! normalize.css v1.1.1 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

audio,
canvas,
video {
    display: inline-block;
    *display: inline;
    *zoom: 1;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 7/8/9, Firefox 3, and Safari 4.
 * Known issue: no IE 6 support.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Prevent system color scheme's background color being used in Firefox, IE,
 *    and Opera.
 * 2. Prevent system color scheme's text color being used in Firefox, IE, and
 *    Opera.
 * 3. Correct text resizing oddly in IE 6/7 when body `font-size` is set using
 *    `em` units.
 * 4. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    background: #fff; /* 1 */
    color: #000; /* 2 */
    font-size: 100%; /* 3 */
    -webkit-text-size-adjust: 100%; /* 4 */
    -ms-text-size-adjust: 100%; /* 4 */
}

/**
 * Address `font-family` inconsistency between `textarea` and other form
 * elements.
 */

html,
button,
input,
select,
textarea {
    font-family: sans-serif;
}

/**
 * Address margins handled incorrectly in IE 6/7.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address font sizes and margins set differently in IE 6/7.
 * Address font sizes within `section` and `article` in Firefox 4+, Safari 5,
 * and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
}

h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

h4 {
    font-size: 1em;
    margin: 1.33em 0;
}

h5 {
    font-size: 0.83em;
    margin: 1.67em 0;
}

h6 {
    font-size: 0.67em;
    margin: 2.33em 0;
}

/**
 * Address styling not present in IE 7/8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 3+, Safari 4/5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

blockquote {
    margin: 1em 40px;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 * Known issue: no IE 6/7 normalization.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 6/7/8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Address margins set differently in IE 6/7.
 */

p,
pre {
    margin: 1em 0;
}

/**
 * Correct font family set oddly in IE 6, Safari 4/5, and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    _font-family: 'courier new', monospace;
    font-size: 1em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/**
 * Address CSS quotes not supported in IE 6/7.
 */

q {
    quotes: none;
}

/**
 * Address `quotes` property not supported in Safari 4.
 */

q:before,
q:after {
    content: '';
    content: none;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Lists
   ========================================================================== */

/**
 * Address margins set differently in IE 6/7.
 */

dl,
menu,
ol,
ul {
    margin: 1em 0;
}

dd {
    margin: 0 0 0 40px;
}

/**
 * Address paddings set differently in IE 6/7.
 */

menu,
ol,
ul {
    padding: 0 0 0 40px;
}

/**
 * Correct list images handled incorrectly in IE 7.
 */

nav ul,
nav ol {
    list-style: none;
    list-style-image: none;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * 1. Remove border when inside `a` element in IE 6/7/8/9 and Firefox 3.
 * 2. Improve image quality when scaled in IE 7.
 */

img {
    border: 0; /* 1 */
    -ms-interpolation-mode: bicubic; /* 2 */
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 6/7/8/9, Safari 5, and Opera 11.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Correct margin displayed oddly in IE 6/7.
 */

form {
    margin: 0;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct color not being inherited in IE 6/7/8/9.
 * 2. Correct text not wrapping in Firefox 3.
 * 3. Correct alignment displayed oddly in IE 6/7.
 */

legend {
    border: 0; /* 1 */
    padding: 0;
    white-space: normal; /* 2 */
    *margin-left: -7px; /* 3 */
}

/**
 * 1. Correct font size not being inherited in all browsers.
 * 2. Address margins set differently in IE 6/7, Firefox 3+, Safari 5,
 *    and Chrome.
 * 3. Improve appearance and consistency in all browsers.
 */

button,
input,
select,
textarea {
    font-size: 100%; /* 1 */
    margin: 0; /* 2 */
    vertical-align: baseline; /* 3 */
    *vertical-align: middle; /* 3 */
}

/**
 * Address Firefox 3+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 6+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 * 4. Remove inner spacing in IE 7 without affecting normal text inputs.
 *    Known issue: inner spacing remains in IE 6.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
    *overflow: visible;  /* 4 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to content-box in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 * 3. Remove excess padding in IE 7.
 *    Known issue: excess padding remains in IE 6.
 */

input[type="checkbox"],
input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    *height: 13px; /* 3 */
    *width: 13px; /* 3 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 3+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 6/7/8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}

  </style>

  <style type="text/css">
  
  html, body {
    margin: 0;
    padding: 0;
    height: 100%;
  }
  body {
    background: #fff;
    font-family: "Source Sans Pro", "Helvetica Neueue", Helvetica, sans;
    font-weight: 300;
    font-size: 16px;
    line-height: 1.6em;
  }
  #content {
    width: 70%;
    max-width: 850px;
    float: left;
    padding: 30px 60px;
    border-left: 1px solid #ddd;
  }
  #sidebar {
    width: 25%;
    float: left;
    padding: 30px;
    overflow: hidden;
  }
  #nav {
    font-size: 130%;
    margin: 0 0 15px 0;
  }

  #top {
    display: block;
    position: fixed;
    bottom: 5px;
    left: 5px;
    font-size: .85em;
    text-transform: uppercase;
  }

  #footer {
    font-size: .75em;
    padding: 5px 30px;
    border-top: 1px solid #ddd;
    text-align: right;
  }
    #footer p {
      margin: 0 0 0 30px;
      display: inline-block;
    }

  h1, h2, h3, h4, h5 {
    font-weight: 300;
  }
  h1 {
    font-size: 2.5em;
    line-height: 1.1em;
    margin: 0 0 .50em 0;
  }

  h2 {
    font-size: 1.75em;
    margin: 1em 0 .50em 0;
  }

  h3 {
    margin: 25px 0 10px 0;
  }

  h4 {
    margin: 0;
    font-size: 105%;
  }

  a {
    color: #058;
    text-decoration: none;
    transition: color .3s ease-in-out;
  }

  a:hover {
    color: #e08524;
    transition: color .3s ease-in-out;
  }

  pre, code, .mono, .name {
    font-family: "Ubuntu Mono", "Cousine", "DejaVu Sans Mono", monospace;
  }

  .title .name {
    font-weight: bold;
  }
  .section-title {
    margin-top: 2em;
  }
  .ident {
    color: #900;
  }

  code {
    background: #f9f9f9;
  } 

  pre {
    background: #fefefe;
    border: 1px solid #ddd;
    box-shadow: 2px 2px 0 #f3f3f3;
    margin: 0 30px;
    padding: 15px 30px;
  }

  .codehilite {
    margin: 0 30px 10px 30px;
  }

    .codehilite pre {
      margin: 0;
    }
    .codehilite .err { background: #ff3300; color: #fff !important; } 

  table#module-list {
    font-size: 110%;
  }

    table#module-list tr td:first-child {
      padding-right: 10px;
      white-space: nowrap;
    }

    table#module-list td {
      vertical-align: top;
      padding-bottom: 8px;
    }

      table#module-list td p {
        margin: 0 0 7px 0;
      }

  .def {
    display: table;
  }

    .def p {
      display: table-cell;
      vertical-align: top;
      text-align: left;
    }

    .def p:first-child {
      white-space: nowrap;
    }

    .def p:last-child {
      width: 100%;
    }


  #index {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
    ul#index .class_name {
      /* font-size: 110%; */
      font-weight: bold;
    }
    #index ul {
      margin: 0;
    }

  .item {
    margin: 0 0 15px 0;
  }

    .item .class {
      margin: 0 0 25px 30px;
    }

      .item .class ul.class_list {
        margin: 0 0 20px 0;
      }

    .item .name {
      background: #fafafa;
      margin: 0;
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 3px;
      display: inline-block;
      min-width: 40%;
    }
      .item .name:hover {
        background: #f6f6f6;
      }

    .item .empty_desc {
      margin: 0 0 5px 0;
      padding: 0;
    }

    .item .inheritance {
      margin: 3px 0 0 30px;
    }

    .item .inherited {
      color: #666;
    }

    .item .desc {
      padding: 0 8px;
      margin: 0;
    }

      .item .desc p {
        margin: 0 0 10px 0;
      }

    .source_cont {
      margin: 0;
      padding: 0;
    }

    .source_link a {
      background: #ffc300;
      font-weight: 400;
      font-size: .75em;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 1px 1px 0 #f4b700;
      
      padding: 3px 8px;
      border-radius: 2px;
      transition: background .3s ease-in-out;
    }
      .source_link a:hover {
        background: #FF7200;
        text-shadow: none;
        transition: background .3s ease-in-out;
      }

    .source {
      display: none;
      max-height: 600px;
      overflow-y: scroll;
      margin-bottom: 15px;
    }

      .source .codehilite {
        margin: 0;
      }

  .desc h1, .desc h2, .desc h3 {
    font-size: 100% !important;
  }
  .clear {
    clear: both;
  }

  @media all and (max-width: 950px) {
    #sidebar {
      width: 35%;
    }
    #content {
      width: 65%;
    }
  }
  @media all and (max-width: 650px) {
    #top {
      display: none;
    }
    #sidebar {
      float: none;
      width: auto;
    }
    #content {
      float: none;
      width: auto;
      padding: 30px;
    }

    #index ul {
      padding: 0;
      margin-bottom: 15px;
    }
    #index ul li {
      display: inline-block;
      margin-right: 30px;
    }
    #footer {
      text-align: left;
    }
    #footer p {
      display: block;
      margin: inherit;
    }
  }

  /*****************************/

  </style>

  <style type="text/css">
  .codehilite .hll { background-color: #ffffcc }
.codehilite  { background: #f8f8f8; }
.codehilite .c { color: #408080; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #FF0000 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666666 } /* Operator */
.codehilite .cm { color: #408080; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #BC7A00 } /* Comment.Preproc */
.codehilite .c1 { color: #408080; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #408080; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .gr { color: #FF0000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #00A000 } /* Generic.Inserted */
.codehilite .go { color: #888888 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #0044DD } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #7D9029 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #0000FF; font-weight: bold } /* Name.Class */
.codehilite .no { color: #880000 } /* Name.Constant */
.codehilite .nd { color: #AA22FF } /* Name.Decorator */
.codehilite .ni { color: #999999; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #D2413A; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #0000FF } /* Name.Function */
.codehilite .nl { color: #A0A000 } /* Name.Label */
.codehilite .nn { color: #0000FF; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #AA22FF; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #bbbbbb } /* Text.Whitespace */
.codehilite .mb { color: #666666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666666 } /* Literal.Number.Float */
.codehilite .mh { color: #666666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666666 } /* Literal.Number.Oct */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #BB6622; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #BB6688; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #BB6688 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .il { color: #666666 } /* Literal.Number.Integer.Long */
  </style>

  <style type="text/css">
  
/* ==========================================================================
   EXAMPLE Media Queries for Responsive Design.
   These examples override the primary ('mobile first') styles.
   Modify as content requires.
   ========================================================================== */

@media only screen and (min-width: 35em) {
    /* Style adjustments for viewports that meet the condition */
}

@media print,
       (-o-min-device-pixel-ratio: 5/4),
       (-webkit-min-device-pixel-ratio: 1.25),
       (min-resolution: 120dpi) {
    /* Style adjustments for high resolution devices */
}

/* ==========================================================================
   Print styles.
   Inlined to avoid required HTTP connection: h5bp.com/r
   ========================================================================== */

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a,
    a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    /*
     * Don't show links for images, or javascript/internal links
     */

    .ir a:after,
    a[href^="javascript:"]:after,
    a[href^="#"]:after {
        content: "";
    }

    pre,
    blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr,
    img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p,
    h2,
    h3 {
        orphans: 3;
        widows: 3;
    }

    h2,
    h3 {
        page-break-after: avoid;
    }
}

  </style>

  <script type="text/javascript">
  function toggle(id, $link) {
    $node = document.getElementById(id);
    if (!$node)
    return;
    if (!$node.style.display || $node.style.display == 'none') {
    $node.style.display = 'block';
    $link.innerHTML = 'Hide source &nequiv;';
    } else {
    $node.style.display = 'none';
    $link.innerHTML = 'Show source &equiv;';
    }
  }
  </script>
</head>
<body>
<a href="#" id="top">Top</a>

<div id="container">
    
  
  <div id="sidebar">
    <h1>Index</h1>
    <ul id="index">
    <li class="set"><h3><a href="#header-variables">Module variables</a></h3>
      
  <ul>
    <li class="mono"><a href="#precession.M">M</a></li>
    <li class="mono"><a href="#precession.flags_q1">flags_q1</a></li>
    <li class="mono"><a href="#precession.storedir">storedir</a></li>
  </ul>

    </li>

    <li class="set"><h3><a href="#header-functions">Functions</a></h3>
      
  <ul>
    <li class="mono"><a href="#precession.J_allowed">J_allowed</a></li>
    <li class="mono"><a href="#precession.J_lim">J_lim</a></li>
    <li class="mono"><a href="#precession.Jframe_projection">Jframe_projection</a></li>
    <li class="mono"><a href="#precession.Jofr">Jofr</a></li>
    <li class="mono"><a href="#precession.Jofr_checkpoint">Jofr_checkpoint</a></li>
    <li class="mono"><a href="#precession.Jofr_infinity">Jofr_infinity</a></li>
    <li class="mono"><a href="#precession.Jofr_infinity_checkpoint">Jofr_infinity_checkpoint</a></li>
    <li class="mono"><a href="#precession.Omegaz">Omegaz</a></li>
    <li class="mono"><a href="#precession.OmegazdtdS">OmegazdtdS</a></li>
    <li class="mono"><a href="#precession.S3sines_comp">S3sines_comp</a></li>
    <li class="mono"><a href="#precession.S_of_t">S_of_t</a></li>
    <li class="mono"><a href="#precession.Sb_limits">Sb_limits</a></li>
    <li class="mono"><a href="#precession.Sb_limits_comp">Sb_limits_comp</a></li>
    <li class="mono"><a href="#precession.Ssines_comp">Ssines_comp</a></li>
    <li class="mono"><a href="#precession.Sso_limits">Sso_limits</a></li>
    <li class="mono"><a href="#precession.St_limits">St_limits</a></li>
    <li class="mono"><a href="#precession.St_limits_comp">St_limits_comp</a></li>
    <li class="mono"><a href="#precession.aligned_configurations">aligned_configurations</a></li>
    <li class="mono"><a href="#precession.alpha_of_S">alpha_of_S</a></li>
    <li class="mono"><a href="#precession.alphaz">alphaz</a></li>
    <li class="mono"><a href="#precession.cutoff">cutoff</a></li>
    <li class="mono"><a href="#precession.dJdL">dJdL</a></li>
    <li class="mono"><a href="#precession.dJdr">dJdr</a></li>
    <li class="mono"><a href="#precession.dSdt">dSdt</a></li>
    <li class="mono"><a href="#precession.dkappadu">dkappadu</a></li>
    <li class="mono"><a href="#precession.dtdS">dtdS</a></li>
    <li class="mono"><a href="#precession.dxidS_minus">dxidS_minus</a></li>
    <li class="mono"><a href="#precession.dxidS_plus">dxidS_plus</a></li>
    <li class="mono"><a href="#precession.empty_temp">empty_temp</a></li>
    <li class="mono"><a href="#precession.evolve_J">evolve_J</a></li>
    <li class="mono"><a href="#precession.evolve_J_backwards">evolve_J_backwards</a></li>
    <li class="mono"><a href="#precession.evolve_J_infinity">evolve_J_infinity</a></li>
    <li class="mono"><a href="#precession.evolve_angles">evolve_angles</a></li>
    <li class="mono"><a href="#precession.evolve_angles_single">evolve_angles_single</a></li>
    <li class="mono"><a href="#precession.finalkick">finalkick</a></li>
    <li class="mono"><a href="#precession.finalmass">finalmass</a></li>
    <li class="mono"><a href="#precession.finalspin">finalspin</a></li>
    <li class="mono"><a href="#precession.find_morphology">find_morphology</a></li>
    <li class="mono"><a href="#precession.from_the_angles">from_the_angles</a></li>
    <li class="mono"><a href="#precession.from_the_angles_inf">from_the_angles_inf</a></li>
    <li class="mono"><a href="#precession.ftor">ftor</a></li>
    <li class="mono"><a href="#precession.get_L">get_L</a></li>
    <li class="mono"><a href="#precession.get_fixed">get_fixed</a></li>
    <li class="mono"><a href="#precession.get_varphi">get_varphi</a></li>
    <li class="mono"><a href="#precession.hybrid">hybrid</a></li>
    <li class="mono"><a href="#precession.hybrid_single">hybrid_single</a></li>
    <li class="mono"><a href="#precession.kappa_backwards">kappa_backwards</a></li>
    <li class="mono"><a href="#precession.kappa_backwards_checkpoint">kappa_backwards_checkpoint</a></li>
    <li class="mono"><a href="#precession.kappainf_allowed">kappainf_allowed</a></li>
    <li class="mono"><a href="#precession.kappainf_lim">kappainf_lim</a></li>
    <li class="mono"><a href="#precession.make_temp">make_temp</a></li>
    <li class="mono"><a href="#precession.orbav_eqs">orbav_eqs</a></li>
    <li class="mono"><a href="#precession.orbav_integrator">orbav_integrator</a></li>
    <li class="mono"><a href="#precession.orbit_angles">orbit_angles</a></li>
    <li class="mono"><a href="#precession.orbit_angles_single">orbit_angles_single</a></li>
    <li class="mono"><a href="#precession.orbit_averaged">orbit_averaged</a></li>
    <li class="mono"><a href="#precession.orbit_averaged_single">orbit_averaged_single</a></li>
    <li class="mono"><a href="#precession.orbit_vectors">orbit_vectors</a></li>
    <li class="mono"><a href="#precession.orbit_vectors_single">orbit_vectors_single</a></li>
    <li class="mono"><a href="#precession.parametric_angles">parametric_angles</a></li>
    <li class="mono"><a href="#precession.phase_checker">phase_checker</a></li>
    <li class="mono"><a href="#precession.phase_xi">phase_xi</a></li>
    <li class="mono"><a href="#precession.precession_period">precession_period</a></li>
    <li class="mono"><a href="#precession.region_selection">region_selection</a></li>
    <li class="mono"><a href="#precession.resonant_finder">resonant_finder</a></li>
    <li class="mono"><a href="#precession.rtof">rtof</a></li>
    <li class="mono"><a href="#precession.samplingS">samplingS</a></li>
    <li class="mono"><a href="#precession.t_of_S">t_of_S</a></li>
    <li class="mono"><a href="#precession.thetas_inf">thetas_inf</a></li>
    <li class="mono"><a href="#precession.updown">updown</a></li>
    <li class="mono"><a href="#precession.why">why</a></li>
    <li class="mono"><a href="#precession.xi_allowed">xi_allowed</a></li>
    <li class="mono"><a href="#precession.xi_at_Jlim">xi_at_Jlim</a></li>
    <li class="mono"><a href="#precession.xi_contour">xi_contour</a></li>
    <li class="mono"><a href="#precession.xi_lim">xi_lim</a></li>
    <li class="mono"><a href="#precession.xi_minus">xi_minus</a></li>
    <li class="mono"><a href="#precession.xi_minus_comp">xi_minus_comp</a></li>
    <li class="mono"><a href="#precession.xi_plus">xi_plus</a></li>
    <li class="mono"><a href="#precession.xi_plus_comp">xi_plus_comp</a></li>
    <li class="mono"><a href="#precession.xiinf_allowed">xiinf_allowed</a></li>
  </ul>

    </li>


    <li class="set"><h3><a href="#header-submodules">Sub-modules</a></h3>
      <ul>
        <li class="mono"><a href="test/index.html">precession.test</a></li>
      </ul>
    </li>
    </ul>
  </div>

    <article id="content">
      
  

  


  <header id="section-intro">
  <h1 class="title"><span class="name">precession</span> module</h1>
  <p><strong>Author</strong> Davide Gerosa</p>
<p><strong>email</strong> d.gerosa@damtp.cam.ac.uk</p>
<p><strong>Copyright</strong> Copyright (C) 2016 Davide Gerosa</p>
<p><strong>Licence</strong> CC BY 4.0</p>
<p><strong>Version</strong> 0.0.0.40</p>
<h1>DYNAMICS OF SPINNING BLACK-HOLE BINARIES WITH PYTHON</h1>
<p><code>precession</code> is a Python module to study the dynamics of precessing black-hole
binaries in the post-Newtonian regime. The code includes tools to study the
precessional dynamics, integrators to perform orbit-averaged and
precession-averaged post-Newtonian inspirals, and implementation of the fitting
formulae to predict the properties of the black-hole remnant.</p>
<p>This code is released to the community under the <a href="http://creativecommons.org/licenses/by/4.0">Creative Commons Attribution
International license</a>.
Essentially, you may use <code>precession</code> as you like but must make reference to
our work. When using precession in any published work, please cite the paper
describing its implementation:</p>
<ul>
<li><em>Precession. Dynamics of spinning black-hole binaries with Python.</em> 
Davide Gerosa. Submitted to... arXiv:...</li>
</ul>
<p><code>precession</code> is an open-source code distributed under git version-control system on</p>
<ul>
<li><a href="github.com/dgerosa/precessions">github.com/dgerosa/precession</a></li>
</ul>
<p>API documentation can be generated automatically in html format from the code docstrings using pdoc, and is is uplodad in a dedicated branch of the git repository</p>
<ul>
<li><a href="dgerosa.github.io/precession">dgerosa.github.io/precession</a></li>
</ul>
<p>Further information and scientific results on the results are available at:</p>
<ul>
<li><a href="www.damtp.cam.ac.uk/user/dg438/spinprecession">www.damtp.cam.ac.uk/user/dg438/spinprecession</a> </li>
<li><a href="www.davidegerosa.com/spinprecession">www.davidegerosa.com/spinprecession</a></li>
</ul>
<h3>INSTALLATION</h3>
<p><code>precession</code> works in python 2.x and has been tested on 2.7.10. It can be
installed through <a href="https://pypi.python.org/pypi/precession">pip</a>:</p>
<div class="codehilite"><pre>pip install precession
</pre></div>


<p>Prerequisites are <code>numpy</code>, <code>scipy</code> and <code>parmap</code>, which can be all installed
through pip. Information on all code functions are available through Pyhton's
built-in help system</p>
<div class="codehilite"><pre><span class="kn">import</span> <span class="nn">precession</span>
<span class="n">help</span><span class="p">(</span><span class="n">precession</span><span class="o">.</span><span class="n">function</span><span class="p">)</span>
</pre></div>


<p>Several tests and tutorial are available in the submodule <a href="test/index.html"><code>precession.test</code></a>.</p>
<h3>THINGS TO KEEP IN MIND</h3>
<ol>
<li>
<p><strong>Units</strong>. All quantities in the code are specified in units where c=G=1.
Moreover, the binary total mass M=m1+m2 is  set to 1, and everything else is
computed accordingly. In practice, this means that e.g. the binary separation r
is actually r/M. If you are trying to use <code>precession</code> from a code with
different units (lal?), you should just pass r/M instead of your cgs or SI r.
Equivalently, the angular momentum L, the spins Si and the total angular
momentum J are actually L/M^2, Si/M^2 and J/M^2.</p>
</li>
<li>
<p><strong>Don't go too close to the limits (i)</strong>. This is a code to study double-spin
precession and, in general, it won't behave nicely if you are too close to
aligned, hence non-precessing, configurations. These configurations are given by
the limits Jmin and Jmax of the total angular momentum J, and/or by
sin(theta_i)=0. I strongly recommend to always set a tolerance, for instance,</p>
<div class="codehilite"><pre>Jmin,Jmax=precession.J_lim(q,S1,S2,r) for J in
numpy.linspace(Jmin+1e-4,Jmax-1e-4,100): 
    do things...
</pre></div>


</li>
<li>
<p><strong>Don't go too close to the limits (ii)</strong>. For the same reason, some
quantities cannot be computed efficiently for binaries which are very close to a
spin-orbit resonance (which indeed does not precess at all!). For instance,  the
computation of the angle alpha is somewhat unstable close to xi_min and xi_max
as returned by xi_allowed. Richard O'Shaughnessy found that a tolerance of 2e-3
on xi works well.</p>
</li>
<li>
<p><strong>Checkpointing</strong>. Checkpointing is implemented in some functions for
computational efficiency. Temporary data are stored in a local directory and
will be read in if available. To delete all previous data run</p>
<div class="codehilite"><pre>precession.empty_temp()
</pre></div>


<p>By default, data are stored in a local directory called <code>checkpoints</code>, which
is created when needed. You can change it setting</p>
<div class="codehilite"><pre>precession.storedir=[path]
</pre></div>


</li>
<li>
<p><strong>Parallelization</strong>. Some parts of the code are parallelized using the
<code>parmap</code> module. Instructions on code parallelization are set by the global
variable CPUs - <code>CPUs=1</code>: no parallelization will be used; - <code>CPUs=integer</code>: to
specify the actual number of cores to be used; - <code>CPUs=0</code> (default): all CPUs in
the current machine will be used.</p>
<p>You can set this variable using</p>
<div class="codehilite"><pre>precession.CPUs = [integer]
</pre></div>


</li>
<li>
<p><strong>The equal-mass limit</strong>. The equal-mass q=1 limit requires some extra care.
If q=1 the total-spin magnitude S cannot be used to parametrize the precession
cycle and the angle varphi needs to be tracked explicitly. The q=1 case is
implemented in the code: inputs and outputs of some of the functions are
actually specified in cos(varphi), even if for simplicity we still call them
<strong>S</strong>. In case of precession-averaged integrations to/from infinity, kappa_inf
becomes degenerate with xi and a required initial value of S is required.
Please, refer to the documentation below for details. The generic unequal-mass
part of the code works fine up to q&lt;0.9999. To run higher values of q we
recommend setting q=1.</p>
</li>
<li>
<p><strong>Stalling</strong>. When performing precession-averaged evolutions, some binaires
may occasionally stall and take longer to run. This is due to the first step
attempted by the ODE integrator. This is a minor issue and  only happens to
roughly one binary in a million or so. If you really want to fix this, you
should play with the h0 optional paramenter in scipy's odeint function.</p>
</li>
</ol>
<h3>THANKS</h3>
<p>The code is developed and maintained by <a href="www.davidegerosa.com">Davide Gerosa</a>. 
Please, report bugs to</p>
<div class="codehilite"><pre>d.gerosa@damtp.cam.ac.uk
</pre></div>


<p>I'm happy to help you out! </p>
<p>I'd like to thank E. Berti, M. Kesden, U. Sperhake, R. O'Shaughnessy, D.
Trifiro' and J. Vosmera for the help received in interpreting the physical
results and implementing some of the algorithms.</p>
  
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession', this);">Show source &equiv;</a></p>
  <div id="source-precession" class="source">
    <div class="codehilite"><pre><span class="sd">&#39;&#39;&#39;</span>
<span class="sd"># DYNAMICS OF SPINNING BLACK-HOLE BINARIES WITH PYTHON</span>

<span class="sd">`precession` is a Python module to study the dynamics of precessing black-hole</span>
<span class="sd">binaries in the post-Newtonian regime. The code includes tools to study the</span>
<span class="sd">precessional dynamics, integrators to perform orbit-averaged and</span>
<span class="sd">precession-averaged post-Newtonian inspirals, and implementation of the fitting</span>
<span class="sd">formulae to predict the properties of the black-hole remnant.</span>

<span class="sd">This code is released to the community under the [Creative Commons Attribution</span>
<span class="sd">International license](http://creativecommons.org/licenses/by/4.0).</span>
<span class="sd">Essentially, you may use `precession` as you like but must make reference to</span>
<span class="sd">our work. When using precession in any published work, please cite the paper</span>
<span class="sd">describing its implementation:</span>

<span class="sd">- *Precession. Dynamics of spinning black-hole binaries with Python.* </span>
<span class="sd">Davide Gerosa. Submitted to... arXiv:...</span>

<span class="sd">`precession` is an open-source code distributed under git version-control system on</span>

<span class="sd">- [github.com/dgerosa/precession](github.com/dgerosa/precessions)</span>

<span class="sd">API documentation can be generated automatically in html format from the code docstrings using pdoc, and is is uplodad in a dedicated branch of the git repository</span>

<span class="sd">- [dgerosa.github.io/precession](dgerosa.github.io/precession)</span>

<span class="sd">Further information and scientific results on the results are available at:</span>

<span class="sd">- [www.damtp.cam.ac.uk/user/dg438/spinprecession](www.damtp.cam.ac.uk/user/dg438/spinprecession) </span>
<span class="sd">- [www.davidegerosa.com/spinprecession](www.davidegerosa.com/spinprecession)</span>


<span class="sd">### INSTALLATION</span>
<span class="sd"> </span>
<span class="sd">`precession` works in python 2.x and has been tested on 2.7.10. It can be</span>
<span class="sd">installed through [pip](https://pypi.python.org/pypi/precession):</span>

<span class="sd">    pip install precession</span>

<span class="sd">Prerequisites are `numpy`, `scipy` and `parmap`, which can be all installed</span>
<span class="sd">through pip. Information on all code functions are available through Pyhton&#39;s</span>
<span class="sd">built-in help system</span>

<span class="sd">    import precession</span>
<span class="sd">    help(precession.function)</span>

<span class="sd">Several tests and tutorial are available in the submodule `precession.test`.</span>


<span class="sd">### THINGS TO KEEP IN MIND</span>

<span class="sd">1. **Units**. All quantities in the code are specified in units where c=G=1.</span>
<span class="sd">Moreover, the binary total mass M=m1+m2 is  set to 1, and everything else is</span>
<span class="sd">computed accordingly. In practice, this means that e.g. the binary separation r</span>
<span class="sd">is actually r/M. If you are trying to use `precession` from a code with</span>
<span class="sd">different units (lal?), you should just pass r/M instead of your cgs or SI r.</span>
<span class="sd">Equivalently, the angular momentum L, the spins Si and the total angular</span>
<span class="sd">momentum J are actually L/M^2, Si/M^2 and J/M^2.</span>

<span class="sd">2. **Don&#39;t go too close to the limits (i)**. This is a code to study double-spin</span>
<span class="sd">precession and, in general, it won&#39;t behave nicely if you are too close to</span>
<span class="sd">aligned, hence non-precessing, configurations. These configurations are given by</span>
<span class="sd">the limits Jmin and Jmax of the total angular momentum J, and/or by</span>
<span class="sd">sin(theta_i)=0. I strongly recommend to always set a tolerance, for instance,</span>

<span class="sd">        Jmin,Jmax=precession.J_lim(q,S1,S2,r) for J in</span>
<span class="sd">        numpy.linspace(Jmin+1e-4,Jmax-1e-4,100): </span>
<span class="sd">            do things...</span>

<span class="sd">3. **Don&#39;t go too close to the limits (ii)**. For the same reason, some</span>
<span class="sd">quantities cannot be computed efficiently for binaries which are very close to a</span>
<span class="sd">spin-orbit resonance (which indeed does not precess at all!). For instance,  the</span>
<span class="sd">computation of the angle alpha is somewhat unstable close to xi_min and xi_max</span>
<span class="sd">as returned by xi_allowed. Richard O&#39;Shaughnessy found that a tolerance of 2e-3</span>
<span class="sd">on xi works well.</span>


<span class="sd">4. **Checkpointing**. Checkpointing is implemented in some functions for</span>
<span class="sd">computational efficiency. Temporary data are stored in a local directory and</span>
<span class="sd">will be read in if available. To delete all previous data run</span>

<span class="sd">        precession.empty_temp()</span>

<span class="sd">    By default, data are stored in a local directory called `checkpoints`, which</span>
<span class="sd">    is created when needed. You can change it setting</span>

<span class="sd">        precession.storedir=[path]</span>

<span class="sd">5. **Parallelization**. Some parts of the code are parallelized using the</span>
<span class="sd">`parmap` module. Instructions on code parallelization are set by the global</span>
<span class="sd">variable CPUs - `CPUs=1`: no parallelization will be used; - `CPUs=integer`: to</span>
<span class="sd">specify the actual number of cores to be used; - `CPUs=0` (default): all CPUs in</span>
<span class="sd">the current machine will be used.</span>

<span class="sd">    You can set this variable using</span>

<span class="sd">        precession.CPUs = [integer]</span>

<span class="sd">6. **The equal-mass limit**. The equal-mass q=1 limit requires some extra care.</span>
<span class="sd">If q=1 the total-spin magnitude S cannot be used to parametrize the precession</span>
<span class="sd">cycle and the angle varphi needs to be tracked explicitly. The q=1 case is</span>
<span class="sd">implemented in the code: inputs and outputs of some of the functions are</span>
<span class="sd">actually specified in cos(varphi), even if for simplicity we still call them</span>
<span class="sd">**S**. In case of precession-averaged integrations to/from infinity, kappa_inf</span>
<span class="sd">becomes degenerate with xi and a required initial value of S is required.</span>
<span class="sd">Please, refer to the documentation below for details. The generic unequal-mass</span>
<span class="sd">part of the code works fine up to q&lt;0.9999. To run higher values of q we</span>
<span class="sd">recommend setting q=1.</span>

<span class="sd">7. **Stalling**. When performing precession-averaged evolutions, some binaires</span>
<span class="sd">may occasionally stall and take longer to run. This is due to the first step</span>
<span class="sd">attempted by the ODE integrator. This is a minor issue and  only happens to</span>
<span class="sd">roughly one binary in a million or so. If you really want to fix this, you</span>
<span class="sd">should play with the h0 optional paramenter in scipy&#39;s odeint function.</span>


<span class="sd">### THANKS</span>
<span class="sd">The code is developed and maintained by [Davide Gerosa](www.davidegerosa.com). </span>
<span class="sd">Please, report bugs to</span>

<span class="sd">    d.gerosa@damtp.cam.ac.uk</span>

<span class="sd">I&#39;m happy to help you out! </span>

<span class="sd">I&#39;d like to thank E. Berti, M. Kesden, U. Sperhake, R. O&#39;Shaughnessy, D.</span>
<span class="sd">Trifiro&#39; and J. Vosmera for the help received in interpreting the physical</span>
<span class="sd">results and implementing some of the algorithms.</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s">&quot;Davide Gerosa&quot;</span>
<span class="n">__email__</span> <span class="o">=</span> <span class="s">&quot;d.gerosa@damtp.cam.ac.uk&quot;</span>
<span class="n">__copyright__</span> <span class="o">=</span> <span class="s">&quot;Copyright (C) 2016 Davide Gerosa&quot;</span>
<span class="n">__license__</span> <span class="o">=</span> <span class="s">&quot;CC BY 4.0&quot;</span>
<span class="n">__version__</span> <span class="o">=</span> <span class="s">&quot;0.0.0.40&quot;</span>


<span class="n">__doc__</span><span class="o">=</span><span class="s">&quot;**Author** &quot;</span><span class="o">+</span><span class="n">__author__</span><span class="o">+</span><span class="s">&quot;</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="o">+</span>\
        <span class="s">&quot;**email** &quot;</span><span class="o">+</span><span class="n">__email__</span><span class="o">+</span><span class="s">&quot;</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="o">+</span>\
        <span class="s">&quot;**Copyright** &quot;</span><span class="o">+</span><span class="n">__copyright__</span><span class="o">+</span><span class="s">&quot;</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="o">+</span>\
        <span class="s">&quot;**Licence** &quot;</span><span class="o">+</span><span class="n">__license__</span><span class="o">+</span><span class="s">&quot;</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="o">+</span>\
        <span class="s">&quot;**Version** &quot;</span><span class="o">+</span><span class="n">__version__</span><span class="o">+</span><span class="s">&quot;</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="o">+</span>\
        <span class="n">__doc__</span>

<span class="k">def</span> <span class="nf">why</span><span class="p">():</span>
    <span class="k">print</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">It&#39;s all about python and gravity. Go to&quot;</span>
    <span class="k">print</span> <span class="s">&quot;http://imgs.xkcd.com/comics/python.png</span><span class="se">\n</span><span class="s">&quot;</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">()</span>


<span class="c">################################</span>
<span class="c">########### STARTUP ############</span>
<span class="c">################################</span>

<span class="kn">import</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">imp</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy</span> <span class="kn">as</span> <span class="nn">sp</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">optimize</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">integrate</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">multiprocessing</span><span class="o">,</span><span class="nn">parmap</span> <span class="c"># if you don&#39;t have parmap, try &quot;pip install parmap&quot;.</span>
<span class="kn">import</span> <span class="nn">__main__</span> 

<span class="c">##Unbuffereb stdout. Less efficient but interesting for debugging.</span>
<span class="k">if</span> <span class="bp">False</span><span class="p">:</span>
    <span class="k">class</span> <span class="nc">Unbuffered</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stream</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stream</span> <span class="o">=</span> <span class="n">stream</span>
        <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
        <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span> <span class="o">=</span> <span class="n">Unbuffered</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">)</span> 

<span class="c"># Checkpoint setup. Checkpoints will be stored in the storedir directory.</span>
<span class="c"># storedir=imp.find_module(&#39;precession&#39;)[1].split(&quot;precession.py&quot;)[0]+&quot;precession_checkpoints&quot; ## Global directory</span>
<span class="n">storedir</span><span class="o">=</span><span class="s">&quot;precession_checkpoints&quot;</span> <span class="c">## Local directory</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Directory path to store checkpoints. Deafult is `./precession_checkpoints`.</span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="k">def</span> <span class="nf">make_temp</span><span class="p">():</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Make an empty directory to store checkpoints. Calling this function is</span>
<span class="sd">    typically not necessary, because the checkpoint directory is created when</span>
<span class="sd">    needed.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        precession.make_temp()</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="k">global</span> <span class="n">storedir</span>
    <span class="k">print</span> <span class="s">&quot;[make_temp] Creating temp directory: &quot;</span><span class="o">+</span><span class="n">storedir</span>
    <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s">&quot;mkdir -p &quot;</span><span class="o">+</span><span class="n">storedir</span><span class="p">)</span> 


<span class="k">def</span> <span class="nf">empty_temp</span><span class="p">():</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Remove all checkpoints.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        precession.empty_temp()</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="k">global</span> <span class="n">storedir</span>
    <span class="k">print</span> <span class="s">&quot;[empty_temp] Removing temp files from directory: &quot;</span><span class="o">+</span><span class="n">storedir</span>
    <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s">&quot;rm -rf &quot;</span><span class="o">+</span><span class="n">storedir</span><span class="p">)</span> 
<span class="c">#empty_temp(storedir)</span>

<span class="n">M</span><span class="o">=</span><span class="mf">1.</span>
<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">The total mass is just a free scale, and we set it to 1. Please, don&#39;t change</span>
<span class="sd">this, because I never checked that the various M factors are all right. </span>
<span class="sd">&#39;&#39;&#39;</span>

<span class="n">flags_q1</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">20</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">))</span> 
<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">Global flags to reduce warnings in the equal-mass limit q=1.</span>
<span class="sd">&#39;&#39;&#39;</span>



<span class="c">#################################</span>
<span class="c">############# LIMITS ############</span>
<span class="c">#################################</span>

<span class="k">def</span> <span class="nf">get_fixed</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">chi1</span><span class="p">,</span><span class="n">chi2</span><span class="p">):</span>
    
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Compute individual masses and spins, from mass ratio (q&lt;1) and</span>
<span class="sd">    dimensionless spins (0&lt;chi&lt;1).</span>

<span class="sd">    **Call:**</span>

<span class="sd">        M,m1,m2,S1,S2=precession.get_fixed(q,chi1,chi2)</span>
<span class="sd">    </span>
<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `chi1`: dimensionless spin magnitude of the primary BH. Must be 0&lt;chi1&lt;1.</span>
<span class="sd">    - `chi2`: dimensionless spin magnitude of the secondary BH. Must be 0&lt;chi2&lt;1.</span>

<span class="sd">    **Returns:**</span>
<span class="sd">    </span>
<span class="sd">    - `M`: total mass of the binary (set to 1).</span>
<span class="sd">    - `m1`: mass of the primary BH.</span>
<span class="sd">    - `m2`: mass of the secondary BH.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="k">global</span> <span class="n">M</span>
    <span class="n">m1</span><span class="o">=</span><span class="n">M</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span> <span class="c"># Primary mass</span>
    <span class="n">m2</span><span class="o">=</span><span class="n">q</span><span class="o">*</span><span class="n">M</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span> <span class="c"># Secondary mass</span>
    <span class="n">S1</span><span class="o">=</span><span class="n">chi1</span><span class="o">*</span><span class="n">m1</span><span class="o">**</span><span class="mi">2</span> <span class="c"># Primary spin magnitude</span>
    <span class="n">S2</span><span class="o">=</span><span class="n">chi2</span><span class="o">*</span><span class="n">m2</span><span class="o">**</span><span class="mi">2</span> <span class="c"># Secondary spin magnitude</span>
    <span class="k">return</span> <span class="n">M</span><span class="p">,</span><span class="n">m1</span><span class="p">,</span><span class="n">m2</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span>


<span class="k">def</span> <span class="nf">get_L</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">q</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Return Newtonian expression for the orbital angular momentum. This function is not called explicitely within the precession module to increase efficiency.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="n">L</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>    
    <span class="k">return</span> <span class="n">L</span>


<span class="k">def</span> <span class="nf">J_lim</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Compute the limits on the magnitude of the total angular momentum J, defined</span>
<span class="sd">    as J=|L+S1+S2|.    </span>

<span class="sd">    **Call:**</span>

<span class="sd">        Jmin,Jmax=precession.J_lim(q,S1,S2,r, verbose=False)</span>
<span class="sd">    </span>
<span class="sd">    **Parameters:**</span>
<span class="sd"> </span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `r`: binary separation.</span>
<span class="sd">    - `verbose`: if `True` print additional information.</span>

<span class="sd">    **Returns:**</span>
<span class="sd">    </span>
<span class="sd">    - `Jmin`: minimum value of J from geometrical constraints.</span>
<span class="sd">    - `Jmax`: maximum value of J from geometrical constraints.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">L</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>    
    <span class="n">Jmin</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="mf">1e-20</span><span class="p">,</span><span class="n">L</span><span class="o">-</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">,</span><span class="n">S1</span><span class="o">-</span><span class="n">L</span><span class="o">-</span><span class="n">S2</span><span class="p">,</span><span class="n">S2</span><span class="o">-</span><span class="n">S1</span><span class="o">-</span><span class="n">L</span><span class="p">)</span>
    <span class="n">Jmax</span><span class="o">=</span><span class="n">L</span><span class="o">+</span><span class="n">S1</span><span class="o">+</span><span class="n">S2</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&quot;[J_lim] L=&quot;</span><span class="p">,</span><span class="n">L</span><span class="p">,</span> <span class="s">&quot; S1=&quot;</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="s">&quot; S2=&quot;</span><span class="p">,</span><span class="n">S2</span>
        <span class="k">print</span> <span class="s">&quot;[J_lim] Jmin=&quot;</span><span class="p">,</span><span class="n">Jmin</span><span class="p">,</span> <span class="s">&quot; Jmax=&quot;</span><span class="p">,</span><span class="n">Jmax</span>
        <span class="k">if</span> <span class="n">Jmin</span><span class="o">==</span><span class="mf">1e-20</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;[J_lim] Jmin=0, Jmax=L+S1+S2&quot;</span>
        <span class="k">elif</span> <span class="n">Jmin</span><span class="o">==</span><span class="n">L</span><span class="o">-</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;[J_lim] Jmin=L-S1-S2, Jmax=L+S1+S2&quot;</span>
        <span class="k">if</span> <span class="n">Jmin</span><span class="o">==</span><span class="n">S1</span><span class="o">-</span><span class="n">L</span><span class="o">-</span><span class="n">S2</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;[J_lim] Jmin=S1-L-S2, Jmax=L+S1+S2&quot;</span>
        <span class="k">if</span> <span class="n">Jmin</span><span class="o">==</span><span class="n">S2</span><span class="o">-</span><span class="n">L</span><span class="o">-</span><span class="n">S1</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;[J_lim] Jmin=S2-L-S1, Jmax=L+S1+S2&quot;</span>
            
    <span class="k">return</span> <span class="n">Jmin</span><span class="p">,</span><span class="n">Jmax</span>    
    
<span class="k">def</span> <span class="nf">St_limits</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
     
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Compute the *total* limits on the magnitude of the total spin S. S has to</span>
<span class="sd">    satisfy both S=S1+S2 and S=J-L.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        St_min,St_max=precession.St_limits(J,q,S1,S2,r,verbose=False)</span>
<span class="sd">    </span>
<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `J`: magnitude of the total angular momentum.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `r`: binary separation.</span>
<span class="sd">    - `verbose`: if `True` print additional information.</span>

<span class="sd">    **Returns:**</span>
<span class="sd">    </span>
<span class="sd">    - `St_min`: minimum value of S from geometrical constraints. This is S_min in our papers.</span>
<span class="sd">    - `St_max`: maximum value of S from geometrical constraints. This is S_max in our papers.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">ttol</span><span class="o">=</span><span class="mf">0.0</span>
    <span class="n">L</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
    <span class="n">St_min</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">J</span><span class="o">-</span><span class="n">L</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">)))</span>
    <span class="n">St_max</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="n">J</span><span class="o">+</span><span class="n">L</span><span class="p">,</span><span class="n">S1</span><span class="o">+</span><span class="n">S2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&quot;[S_lim] L=&quot;</span><span class="p">,</span><span class="n">L</span><span class="p">,</span> <span class="s">&quot; J&quot;</span><span class="p">,</span><span class="n">J</span><span class="p">,</span> <span class="s">&quot; S1=&quot;</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="s">&quot; S2=&quot;</span><span class="p">,</span><span class="n">S2</span>
        <span class="k">print</span> <span class="s">&quot;[S_lim] St_min=&quot;</span><span class="p">,</span><span class="n">St_min</span><span class="p">,</span> <span class="s">&quot; St_max=&quot;</span><span class="p">,</span><span class="n">St_max</span>
        <span class="k">if</span> <span class="n">St_min</span><span class="o">==</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">J</span><span class="o">-</span><span class="n">L</span><span class="p">)</span> <span class="ow">and</span> <span class="n">St_max</span><span class="o">==</span><span class="n">J</span><span class="o">+</span><span class="n">L</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;[S_lim] St_min=|J-L|, St_max=J+L&quot;</span>
        <span class="k">elif</span> <span class="n">St_min</span><span class="o">==</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">J</span><span class="o">-</span><span class="n">L</span><span class="p">)</span> <span class="ow">and</span> <span class="n">St_max</span><span class="o">==</span><span class="n">S1</span><span class="o">+</span><span class="n">S2</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;[S_lim] St_min=|J-L|, St_max=S1+S2&quot;</span>
        <span class="k">elif</span> <span class="n">St_min</span><span class="o">==</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">)</span> <span class="ow">and</span> <span class="n">St_max</span><span class="o">==</span><span class="n">J</span><span class="o">+</span><span class="n">L</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;[S_lim] St_min=|S1-S2|, St_max=J+L&quot;</span>
        <span class="k">elif</span> <span class="n">St_min</span><span class="o">==</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">)</span> <span class="ow">and</span> <span class="n">St_max</span><span class="o">==</span><span class="n">S1</span><span class="o">+</span><span class="n">S2</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;[S_lim] St_min=|S1-S2|, St_max=S1+S2&quot;</span>

    <span class="k">return</span> <span class="n">St_min</span><span class="o">+</span><span class="n">ttol</span><span class="p">,</span><span class="n">St_max</span><span class="o">-</span><span class="n">ttol</span>


<span class="k">def</span> <span class="nf">Sso_limits</span><span class="p">(</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">):</span>
    
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Compute the *spin-only* limits on the magnitude of the total spin S,</span>
<span class="sd">    considering the single constraint S=S1+S2.  This is needed e.g. to provide</span>
<span class="sd">    initial condition to precession-averaged integration from infinity in the</span>
<span class="sd">    q=1 limit.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        Sso_min,Sso_max=precession.Sso_limits(S1,S2)</span>

<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>

<span class="sd">    **Returns:**</span>
<span class="sd">    </span>
<span class="sd">    - `Sso_min`: minimum value of S from the spin constraint only.</span>
<span class="sd">    - `Sso_max`: maximum value of S from the spin constraint only.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">),</span> <span class="n">S1</span><span class="o">+</span><span class="n">S2</span>


<span class="k">def</span> <span class="nf">xi_lim</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Compute the absolute limits on xi (i.e. regardless of J). Check</span>
<span class="sd">    `precession.xi_allowed` for the limits on xi for a given J. This functions</span>
<span class="sd">    is simply checks -1&lt;cos(theta_i)&lt;1.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        xi_min,xi_max=precession.xi_lim(q,S1,S2)</span>
<span class="sd">    </span>
<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    </span>
<span class="sd">    **Returns:**</span>
<span class="sd">    </span>
<span class="sd">    - `xi_min`: minimum value of xi from geometrical constraints.</span>
<span class="sd">    - `xi_max`: maximum value of xi from geometrical constraints.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">xi_max</span><span class="o">=</span> <span class="p">((</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">S1</span><span class="o">+</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="o">**-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">S2</span><span class="p">)</span><span class="o">*</span><span class="n">M</span><span class="o">**-</span><span class="mi">2</span>
    <span class="n">xi_min</span><span class="o">=-</span><span class="mf">1.</span><span class="o">*</span><span class="n">xi_max</span>
    <span class="k">return</span> <span class="n">xi_min</span><span class="p">,</span><span class="n">xi_max</span>    


<span class="k">def</span> <span class="nf">xi_at_Jlim</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">more</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Find the value of xi (and S, optional) when J is either Jmax or Jmin.</span>
<span class="sd">    </span>
<span class="sd">    **Call:**</span>

<span class="sd">        xi_Jmin,xi_Jmax=precession.xi_at_Jlim(q,S1,S2,r,more=False)</span>
<span class="sd">    </span>
<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `r`: binary separation.</span>
<span class="sd">    - `more`: if `True` returns additional quantities.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `xi_Jmin`: value of xi when J=Jmin.</span>
<span class="sd">    - `xi_Jmax`: value of xi when J=Jmax.</span>
<span class="sd">    - `S_Jmin`: (optional) value of S when J=Jmin.</span>
<span class="sd">    - `S_Jmax`: (optional) value of S when J=Jmax.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="c"># Find Jmin and Jmax</span>
    <span class="n">L</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>    
    <span class="n">Jmin</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="mf">1e-20</span><span class="p">,</span><span class="n">L</span><span class="o">-</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">,</span><span class="n">S1</span><span class="o">-</span><span class="n">L</span><span class="o">-</span><span class="n">S2</span><span class="p">,</span><span class="n">S2</span><span class="o">-</span><span class="n">S1</span><span class="o">-</span><span class="n">L</span><span class="p">)</span>
    <span class="n">Jmax</span><span class="o">=</span><span class="n">L</span><span class="o">+</span><span class="n">S1</span><span class="o">+</span><span class="n">S2</span>
    
    <span class="c"># Everything is aligned at Jmax</span>
    <span class="n">ct1</span><span class="o">=</span><span class="mf">1.</span>
    <span class="n">ct2</span><span class="o">=</span><span class="mf">1.</span>
    <span class="n">xi_Jmax</span><span class="o">=</span> <span class="p">((</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">S1</span><span class="o">*</span><span class="n">ct1</span><span class="o">+</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="o">**-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">S2</span><span class="o">*</span><span class="n">ct2</span><span class="p">)</span><span class="o">*</span><span class="n">M</span><span class="o">**-</span><span class="mi">2</span>
    <span class="n">S_Jmax</span><span class="o">=</span> <span class="n">S1</span><span class="o">+</span><span class="n">S2</span>
    
    <span class="c"># Split the Jmin cases</span>
    <span class="k">if</span> <span class="n">Jmin</span><span class="o">==</span><span class="mf">1e-20</span><span class="p">:</span> <span class="c"># Force vectors in a plane, closed triangle</span>
        <span class="n">ct1</span><span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">S1</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">S2</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">L</span><span class="o">*</span><span class="n">S1</span><span class="p">)</span>
        <span class="n">ct2</span><span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">S2</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">S1</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">L</span><span class="o">*</span><span class="n">S2</span><span class="p">)</span>
        <span class="n">S_Jmin</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">elif</span> <span class="n">Jmin</span><span class="o">==</span><span class="n">L</span><span class="o">-</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">:</span> <span class="c"># Both antialigned</span>
        <span class="n">ct1</span><span class="o">=-</span><span class="mf">1.</span>
        <span class="n">ct2</span><span class="o">=-</span><span class="mf">1.</span>
        <span class="n">S_Jmin</span><span class="o">=</span><span class="n">S1</span><span class="o">+</span><span class="n">S2</span>
    <span class="k">elif</span> <span class="n">Jmin</span><span class="o">==</span><span class="n">S1</span><span class="o">-</span><span class="n">L</span><span class="o">-</span><span class="n">S2</span><span class="p">:</span> <span class="c"># One antialigned</span>
        <span class="n">ct1</span><span class="o">=-</span><span class="mf">1.</span>
        <span class="n">ct2</span><span class="o">=</span><span class="mf">1.</span>
        <span class="n">S_Jmin</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">Jmin</span><span class="o">==</span><span class="n">S2</span><span class="o">-</span><span class="n">L</span><span class="o">-</span><span class="n">S1</span><span class="p">:</span> <span class="c"># One antialigned</span>
        <span class="n">ct1</span><span class="o">=</span><span class="mf">1.</span>
        <span class="n">ct2</span><span class="o">=-</span><span class="mf">1.</span>
        <span class="n">S_Jmin</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">)</span>
    <span class="n">xi_Jmin</span><span class="o">=</span> <span class="p">((</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">S1</span><span class="o">*</span><span class="n">ct1</span><span class="o">+</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="o">**-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">S2</span><span class="o">*</span><span class="n">ct2</span><span class="p">)</span><span class="o">*</span><span class="n">M</span><span class="o">**-</span><span class="mi">2</span>
    
    <span class="k">if</span> <span class="n">more</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">xi_Jmin</span><span class="p">,</span> <span class="n">xi_Jmax</span><span class="p">,</span> <span class="n">S_Jmin</span><span class="p">,</span> <span class="n">S_Jmax</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">xi_Jmin</span><span class="p">,</span> <span class="n">xi_Jmax</span>


<span class="k">def</span> <span class="nf">kappainf_lim</span><span class="p">(</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">):</span>
    
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Absolute limits in kappa_inf (asymptotic value of kappa). At large</span>
<span class="sd">    separations, kappa is the projection of the total spin along L.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        kappainf_min,kappainf_max=precession.kappainf_lim(S1,S2)</span>
<span class="sd">     </span>
<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `kappainf_min`: minimum value of kappa at infinitely large separations.</span>
<span class="sd">    - `kappainf_max`: maximum value of kappa at infinitely large separations.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="k">return</span> <span class="o">-</span><span class="p">(</span><span class="n">S1</span><span class="o">+</span><span class="n">S2</span><span class="p">),</span> <span class="n">S1</span><span class="o">+</span><span class="n">S2</span>
 
 
<span class="k">def</span> <span class="nf">xiinf_allowed</span><span class="p">(</span><span class="n">kappa_inf</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">):</span>
 
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Limits on xi for a given value of kappa_inf, obtained forcing</span>
<span class="sd">    -1&lt;cos(theta_i)&lt;1.</span>
<span class="sd"> </span>
<span class="sd">    **Call:**</span>

<span class="sd">        xi_low,xi_up=precession.xiinf_allowed(kappa_inf,q,S1,S2)</span>
<span class="sd">    </span>
<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `kappa_inf`: asymptotic value of kappa at large separations.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `xi_low`: minimum allowed value of xi, given the input parameters.</span>
<span class="sd">    - `xi_up`: maximum allowed value of xi, given the input parameters.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="n">xi_low</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span> <span class="n">kappa_inf</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">q</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">q</span><span class="o">**-</span><span class="mi">1</span><span class="o">-</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">S2</span> <span class="p">,</span> <span class="n">kappa_inf</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">q</span><span class="o">**-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">q</span><span class="o">**-</span><span class="mi">1</span><span class="o">-</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">S1</span> <span class="p">)</span>
    <span class="n">xi_up</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span> <span class="n">kappa_inf</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">q</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">q</span><span class="o">**-</span><span class="mi">1</span><span class="o">-</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">S2</span> <span class="p">,</span> <span class="n">kappa_inf</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">q</span><span class="o">**-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">q</span><span class="o">**-</span><span class="mi">1</span><span class="o">-</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">S1</span> <span class="p">)</span>
    <span class="k">return</span> <span class="n">xi_low</span><span class="p">,</span><span class="n">xi_up</span>
 
 
<span class="k">def</span> <span class="nf">kappainf_allowed</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Limits on kappa_inf for a given value of xi, obtained forcing</span>
<span class="sd">    -1&lt;cos(theta_i)&lt;1.</span>
<span class="sd"> </span>
<span class="sd">    **Call:**</span>

<span class="sd">        kappainf_low,kappainf_up=precession.kappainf_allowed(xi,q,S1,S2)</span>
<span class="sd">    </span>
<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `kappainf_low`: minimum allowed value of kappa_inf, given the input parameters.</span>
<span class="sd">    - `kappainf_up`: maximum allowed value of kappa_inf, given the input parameters.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="n">kappainf_low</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span> <span class="p">(</span><span class="n">xi</span> <span class="o">-</span> <span class="p">(</span><span class="n">q</span><span class="o">**-</span><span class="mi">1</span><span class="o">-</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">S2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">q</span><span class="p">)</span> <span class="p">,</span> <span class="p">(</span><span class="n">xi</span> <span class="o">-</span> <span class="p">(</span><span class="n">q</span><span class="o">**-</span><span class="mi">1</span><span class="o">-</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">S1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">q</span><span class="o">**-</span><span class="mi">1</span><span class="p">)</span> <span class="p">)</span>
    <span class="n">kappainf_up</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span> <span class="p">(</span><span class="n">xi</span> <span class="o">+</span> <span class="p">(</span><span class="n">q</span><span class="o">**-</span><span class="mi">1</span><span class="o">-</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">S2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">q</span><span class="p">)</span> <span class="p">,</span> <span class="p">(</span><span class="n">xi</span> <span class="o">+</span> <span class="p">(</span><span class="n">q</span><span class="o">**-</span><span class="mi">1</span><span class="o">-</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">S1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">q</span><span class="o">**-</span><span class="mi">1</span><span class="p">)</span> <span class="p">)</span>
    <span class="k">return</span> <span class="n">kappainf_low</span><span class="p">,</span><span class="n">kappainf_up</span>




<span class="c">#################################</span>
<span class="c">##### EFFECTIVE POTENTIALS ######</span>
<span class="c">#################################</span>


<span class="k">def</span> <span class="nf">xi_contour</span><span class="p">(</span><span class="n">varphi</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Compute the projection of the effective spin xi as a function of the</span>
<span class="sd">    spin-rotation degree of freedom varphi and the total spin magnitude S.</span>
<span class="sd"> </span>
<span class="sd">    **Call:**</span>

<span class="sd">        xi=precession.xi_contour(varphi,S,J,q,S1,S2,r)</span>
<span class="sd">    </span>
<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `varphi`: angle describing the rotation of S1 and S2 about S, in a frame aligned with J.</span>
<span class="sd">    - `S`: magnitude of the total spin.</span>
<span class="sd">    - `J`: magnitude of the total angular momentum.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `r`: binary separation.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">L</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
    <span class="n">t1</span><span class="o">=</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">4.</span><span class="o">*</span><span class="n">q</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">L</span><span class="p">)</span>
    <span class="n">t2</span><span class="o">=</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">t3</span><span class="o">=</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">-</span><span class="p">(</span><span class="n">S1</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">q</span><span class="p">)</span>
    <span class="n">t4</span><span class="o">=</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="p">((</span><span class="n">L</span><span class="o">+</span><span class="n">S</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
    <span class="n">t5</span><span class="o">=</span><span class="p">(</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="n">S</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>             
    <span class="n">t6</span><span class="o">=</span><span class="p">((</span><span class="n">S1</span><span class="o">+</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
    <span class="n">t7</span><span class="o">=</span><span class="p">(</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
    <span class="k">return</span> <span class="n">t1</span><span class="o">*</span><span class="p">((</span><span class="n">t2</span><span class="o">*</span><span class="n">t3</span><span class="p">)</span><span class="o">-</span><span class="p">(</span><span class="n">t4</span><span class="o">*</span><span class="n">t5</span><span class="o">*</span><span class="n">t6</span><span class="o">*</span><span class="n">t7</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">varphi</span><span class="p">)))</span>  

    
<span class="k">def</span> <span class="nf">xi_plus</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Upper effective potential, corresponding to cos(varphi)=-1.</span>
<span class="sd"> </span>
<span class="sd">    **Call:**</span>

<span class="sd">        xi=precession.xi_plus(S,J,q,S1,S2,r)</span>

<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `S`: magnitude of the total spin.</span>
<span class="sd">    - `J`: magnitude of the total angular momentum.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `r`: binary separation.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="c"># Do it explicitely. Somehow faster than calling xi_contour(np.pi,...)</span>
    <span class="n">L</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
    <span class="n">t1</span><span class="o">=</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">4.</span><span class="o">*</span><span class="n">q</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">L</span><span class="p">)</span>
    <span class="n">t2</span><span class="o">=</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">t3</span><span class="o">=</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">-</span><span class="p">(</span><span class="n">S1</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">q</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">S</span> <span class="ow">in</span> <span class="n">St_limits</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">):</span> <span class="c">#if you&#39;re on the limits, the second bit must be zero</span>
        <span class="n">t4</span><span class="o">=</span><span class="n">t5</span><span class="o">=</span><span class="n">t6</span><span class="o">=</span><span class="n">t7</span><span class="o">=</span><span class="mf">0.</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">t4</span><span class="o">=</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="p">((</span><span class="n">L</span><span class="o">+</span><span class="n">S</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
        <span class="n">t5</span><span class="o">=</span><span class="p">(</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="n">S</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>             
        <span class="n">t6</span><span class="o">=</span><span class="p">((</span><span class="n">S1</span><span class="o">+</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
        <span class="n">t7</span><span class="o">=</span><span class="p">(</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>    

    <span class="k">return</span> <span class="n">t1</span><span class="o">*</span><span class="p">((</span><span class="n">t2</span><span class="o">*</span><span class="n">t3</span><span class="p">)</span><span class="o">-</span><span class="p">(</span><span class="n">t4</span><span class="o">*</span><span class="n">t5</span><span class="o">*</span><span class="n">t6</span><span class="o">*</span><span class="n">t7</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="mf">1.</span><span class="p">)))</span>  
 
 
<span class="k">def</span> <span class="nf">xi_minus</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">):</span>
    
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Lower effective potential, corresponding to cos(varphi)=+1.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        xi=precession.xi_minus(S,J,q,S1,S2,r)</span>
<span class="sd">    </span>
<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `S`: magnitude of the total spin.</span>
<span class="sd">    - `J`: magnitude of the total angular momentum.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `r`: binary separation.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="c"># Do it explicitely. Somehow faster than calling xi_contour(np.pi,...)    </span>
    <span class="n">L</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
    <span class="n">t1</span><span class="o">=</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">4.</span><span class="o">*</span><span class="n">q</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">L</span><span class="p">)</span>
    <span class="n">t2</span><span class="o">=</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">t3</span><span class="o">=</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">-</span><span class="p">(</span><span class="n">S1</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">q</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">S</span> <span class="ow">in</span> <span class="n">St_limits</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">):</span> <span class="c">#if you&#39;re on the limits, the second bit must be zero</span>
        <span class="n">t4</span><span class="o">=</span><span class="n">t5</span><span class="o">=</span><span class="n">t6</span><span class="o">=</span><span class="n">t7</span><span class="o">=</span><span class="mf">0.</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">t4</span><span class="o">=</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="p">((</span><span class="n">L</span><span class="o">+</span><span class="n">S</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
        <span class="n">t5</span><span class="o">=</span><span class="p">(</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="n">S</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>             
        <span class="n">t6</span><span class="o">=</span><span class="p">((</span><span class="n">S1</span><span class="o">+</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
        <span class="n">t7</span><span class="o">=</span><span class="p">(</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>    

    <span class="k">return</span> <span class="n">t1</span><span class="o">*</span><span class="p">((</span><span class="n">t2</span><span class="o">*</span><span class="n">t3</span><span class="p">)</span><span class="o">-</span><span class="p">(</span><span class="n">t4</span><span class="o">*</span><span class="n">t5</span><span class="o">*</span><span class="n">t6</span><span class="o">*</span><span class="n">t7</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="p">)))</span>  


<span class="k">def</span> <span class="nf">dxidS_plus</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Derivative of the effective potential xi_plus with respect to S.    </span>

<span class="sd">    **Call:**</span>

<span class="sd">        dxidS=precession.dxidS_plus(S,J,q,S1,S2,r)</span>
<span class="sd">    </span>
<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `S`: magnitude of the total spin.</span>
<span class="sd">    - `J`: magnitude of the total angular momentum.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `r`: binary separation.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `dxidS`: derivative of effective potential with respect to S.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="n">L</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
    <span class="n">A1</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="n">S</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">A2</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">L</span><span class="o">+</span><span class="n">S</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">A3</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">A4</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">S1</span><span class="o">+</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">Fp</span> <span class="o">=</span> <span class="p">(</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">S1</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">q</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">+</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">q</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">A1</span><span class="o">*</span><span class="n">A2</span><span class="o">*</span><span class="n">A3</span><span class="o">*</span><span class="n">A4</span>
    <span class="n">G</span><span class="o">=</span><span class="mi">4</span><span class="o">*</span><span class="n">q</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">L</span>
    <span class="n">dFpdS</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">S</span><span class="o">*</span><span class="p">(</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">S1</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">q</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">S</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">q</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(((</span><span class="n">L</span><span class="o">-</span><span class="n">S</span><span class="p">)</span><span class="o">*</span><span class="n">A2</span><span class="o">*</span><span class="n">A3</span><span class="o">*</span><span class="n">A4</span><span class="p">)</span><span class="o">/</span><span class="n">A1</span><span class="o">+</span><span class="p">((</span><span class="n">L</span><span class="o">+</span><span class="n">S</span><span class="p">)</span><span class="o">*</span><span class="n">A3</span><span class="o">*</span><span class="n">A4</span><span class="o">*</span><span class="n">A1</span><span class="p">)</span><span class="o">/</span><span class="n">A2</span><span class="o">+</span><span class="p">(</span><span class="n">S</span><span class="o">*</span><span class="n">A4</span><span class="o">*</span><span class="n">A1</span><span class="o">*</span><span class="n">A2</span><span class="p">)</span><span class="o">/</span><span class="n">A3</span><span class="o">-</span><span class="p">(</span><span class="n">S</span><span class="o">*</span><span class="n">A1</span><span class="o">*</span><span class="n">A2</span><span class="o">*</span><span class="n">A3</span><span class="p">)</span><span class="o">/</span><span class="n">A4</span><span class="p">)</span>
    <span class="n">dGdS</span><span class="o">=</span><span class="mi">8</span><span class="o">*</span><span class="n">q</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">S</span><span class="o">*</span><span class="n">L</span>
    <span class="n">dxipdS</span><span class="o">=</span><span class="p">(</span><span class="n">dFpdS</span><span class="o">*</span><span class="n">G</span><span class="o">-</span><span class="n">dGdS</span><span class="o">*</span><span class="n">Fp</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">G</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dxipdS</span>


<span class="k">def</span> <span class="nf">dxidS_minus</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">):</span>
    
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Derivative of the effective potential xi_minus with respect to S.    </span>

<span class="sd">    **Call:**</span>

<span class="sd">        dxidS=precession.dxidS_minus(S,J,q,S1,S2,r)</span>
<span class="sd">    </span>
<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `S`: magnitude of the total spin.</span>
<span class="sd">    - `J`: magnitude of the total angular momentum.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `r`: binary separation.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `dxidS`: derivative of effective potential with respect to S.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">L</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
    <span class="n">A1</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="n">S</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">A2</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">L</span><span class="o">+</span><span class="n">S</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">A3</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">A4</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">S1</span><span class="o">+</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">Fm</span> <span class="o">=</span> <span class="p">(</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">S1</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">q</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">-</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">q</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">A1</span><span class="o">*</span><span class="n">A2</span><span class="o">*</span><span class="n">A3</span><span class="o">*</span><span class="n">A4</span>
    <span class="n">G</span><span class="o">=</span><span class="mi">4</span><span class="o">*</span><span class="n">q</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">L</span>
    <span class="n">dFmdS</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">S</span><span class="o">*</span><span class="p">(</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">S1</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">q</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">S</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">q</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(((</span><span class="n">L</span><span class="o">-</span><span class="n">S</span><span class="p">)</span><span class="o">*</span><span class="n">A2</span><span class="o">*</span><span class="n">A3</span><span class="o">*</span><span class="n">A4</span><span class="p">)</span><span class="o">/</span><span class="n">A1</span><span class="o">+</span><span class="p">((</span><span class="n">L</span><span class="o">+</span><span class="n">S</span><span class="p">)</span><span class="o">*</span><span class="n">A3</span><span class="o">*</span><span class="n">A4</span><span class="o">*</span><span class="n">A1</span><span class="p">)</span><span class="o">/</span><span class="n">A2</span><span class="o">+</span><span class="p">(</span><span class="n">S</span><span class="o">*</span><span class="n">A4</span><span class="o">*</span><span class="n">A1</span><span class="o">*</span><span class="n">A2</span><span class="p">)</span><span class="o">/</span><span class="n">A3</span><span class="o">-</span><span class="p">(</span><span class="n">S</span><span class="o">*</span><span class="n">A1</span><span class="o">*</span><span class="n">A2</span><span class="o">*</span><span class="n">A3</span><span class="p">)</span><span class="o">/</span><span class="n">A4</span><span class="p">)</span>
    <span class="n">dGdS</span><span class="o">=</span><span class="mi">8</span><span class="o">*</span><span class="n">q</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">S</span><span class="o">*</span><span class="n">L</span>
    <span class="n">dximdS</span><span class="o">=</span><span class="p">(</span><span class="n">dFmdS</span><span class="o">*</span><span class="n">G</span><span class="o">-</span><span class="n">dGdS</span><span class="o">*</span><span class="n">Fm</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">G</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dximdS</span>


<span class="k">def</span> <span class="nf">get_varphi</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">sign</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Compute varphi from a given xi. This can be seen as the inverse of</span>
<span class="sd">    xi_contour. If phase==1 (default) return varphi in [0,pi], if sign==-1</span>
<span class="sd">    return varphi in [-pi,0].</span>

<span class="sd">    WARKNING: Don&#39;t run for q=1, as varphi is independent of S in this limit.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        varphi=precession.get_varphi(xi,S,J,q,S1,S2,r,sign=1)</span>
<span class="sd">    </span>
<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `S`: magnitude of the total spin.</span>
<span class="sd">    - `J`: magnitude of the total angular momentum.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `r`: binary separation.</span>
<span class="sd">    - `sign`: if 1 return angle in [0,pi], if -1 return angle in [-pi,0].</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `varphi`: angle describing the rotation of S1 and S2 about S, in a frame aligned with J.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="n">q</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">assert</span> <span class="bp">False</span><span class="p">,</span> <span class="s">&quot;[get_varphi] Error: I&#39;m sorry, can&#39;t run for q=1. S is degenerate with varphi.&quot;</span>

    <span class="n">L</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
    <span class="n">t1</span><span class="o">=</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">4.</span><span class="o">*</span><span class="n">q</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">L</span><span class="p">)</span>
    <span class="n">t2</span><span class="o">=</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">t3</span><span class="o">=</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">-</span><span class="p">(</span><span class="n">S1</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">q</span><span class="p">)</span>
    <span class="n">t4</span><span class="o">=</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="p">((</span><span class="n">L</span><span class="o">+</span><span class="n">S</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
    <span class="n">t5</span><span class="o">=</span><span class="p">(</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="n">S</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>             
    <span class="n">t6</span><span class="o">=</span><span class="p">((</span><span class="n">S1</span><span class="o">+</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
    <span class="n">t7</span><span class="o">=</span><span class="p">(</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
    <span class="n">cosvarphi</span><span class="o">=</span> <span class="p">((</span><span class="n">t2</span><span class="o">*</span><span class="n">t3</span><span class="p">)</span><span class="o">-</span><span class="p">(</span><span class="n">xi</span><span class="o">/</span><span class="n">t1</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="n">t4</span><span class="o">*</span><span class="n">t5</span><span class="o">*</span><span class="n">t6</span><span class="o">*</span><span class="n">t7</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">cosvarphi</span><span class="p">)</span><span class="o">*</span><span class="n">sign</span>


<span class="k">def</span> <span class="nf">Sb_limits</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">):</span>
    
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Compute the *bounded* limits on S, using xi as a constant of motion. The</span>
<span class="sd">    routine first guesses where the extrema are expected to be, then brakets the</span>
<span class="sd">    solution, and finally runs root finder. In some cases the braketing may</span>
<span class="sd">    fail: this typically happens if the two roots are very close (DeltaS&lt;1e-8)</span>
<span class="sd">    and cannot be distinguished numerically. In this case, assume Sb_min=Sb_max.</span>

<span class="sd">    WARNING: This function is critical. It is well tested, but is tricky</span>
<span class="sd">    numerical issues may still be present.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        Sb_min,Sb_max=precession.Sb_limits(xi,J,q,S1,S2,r)</span>

<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `J`: magnitude of the total angular momentum.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `r`: binary separation.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `Sb_min`: minimum value of S from geometrical constraints. This is S- in our papers.</span>
<span class="sd">    - `Sb_max`: maximum value of S from geometrical constraints. This is S+ in our papers.   </span>
<span class="sd">    &#39;&#39;&#39;</span>
 
    <span class="n">St_min</span><span class="p">,</span><span class="n">St_max</span><span class="o">=</span><span class="n">St_limits</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">St_max</span><span class="o">&lt;</span><span class="n">St_min</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&quot;[Sb_limits] Problem in the absolute limits at r=&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="o">+</span><span class="s">&quot;. Assume Sb_min=Sb_max=mean(St_min,St_max)&quot;</span>        
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">St_min</span><span class="p">,</span><span class="n">St_max</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">St_min</span><span class="p">,</span><span class="n">St_max</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">q</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="c"># if q=1 the effective potential loop shrinks to a lime (Sb_min=Sb_max) and the equations xi_/pm(S)=xi can be solved analytically.</span>
        <span class="n">L</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
        <span class="n">Sb_both</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">xi</span><span class="o">*</span><span class="n">L</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Sb_both</span><span class="p">,</span><span class="n">Sb_both</span>

    <span class="c"># Remember: xi_minus=xi_plus at St_min and St_max</span>
    <span class="n">xi_low</span><span class="o">=</span><span class="n">xi_minus</span><span class="p">(</span><span class="n">St_min</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span> 
    <span class="n">xi_up</span><span class="o">=</span><span class="n">xi_minus</span><span class="p">(</span><span class="n">St_max</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
 
    <span class="c">#Debug option: print the parameter-space region of the initial guess</span>
    <span class="n">whereareyou</span><span class="o">=</span><span class="bp">False</span>
 
    <span class="c"># Both roots on xi_plus. Split the interval first</span>
    <span class="k">if</span> <span class="n">xi</span> <span class="o">&gt;</span> <span class="n">xi_low</span> <span class="ow">and</span> <span class="n">xi</span> <span class="o">&gt;</span> <span class="n">xi_up</span><span class="p">:</span>    
        <span class="k">if</span> <span class="n">whereareyou</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;[Sb_limits] Both roots on xi_plus&quot;</span>
        
        <span class="n">resmax</span><span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">fminbound</span><span class="p">(</span><span class="k">lambda</span> <span class="n">S</span><span class="p">:</span> <span class="o">-</span><span class="mf">1.</span><span class="o">*</span><span class="n">xi_plus</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">),</span> <span class="n">St_min</span><span class="p">,</span> <span class="n">St_max</span><span class="p">,</span><span class="n">full_output</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">S_up</span><span class="o">=</span><span class="n">resmax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">xi_max</span><span class="o">=-</span><span class="mf">1.</span><span class="o">*</span><span class="n">resmax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">xi_max</span><span class="o">&lt;</span><span class="n">xi</span><span class="p">:</span> <span class="c">#Braket failed!</span>
            <span class="k">print</span> <span class="s">&quot;[Sb_limits] Braket failed on xi_plus at r=&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="o">+</span><span class="s">&quot;. Assume Sb_min=Sb_max&quot;</span>
            <span class="c">#print  xi_plus(S_up,J,q,S1,S2,r), xi</span>
            <span class="n">Sb_min</span><span class="o">=</span><span class="n">S_up</span>
            <span class="n">Sb_max</span><span class="o">=</span><span class="n">S_up</span>  
        <span class="k">else</span><span class="p">:</span> <span class="c">#Braket succeeded!</span>
            <span class="n">Sb_min</span><span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="k">lambda</span> <span class="n">S</span><span class="p">:</span> <span class="n">xi_plus</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span><span class="o">-</span><span class="n">xi</span><span class="p">,</span> <span class="n">St_min</span><span class="p">,</span> <span class="n">S_up</span><span class="p">)</span>
            <span class="n">Sb_max</span><span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="k">lambda</span> <span class="n">S</span><span class="p">:</span> <span class="n">xi_plus</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span><span class="o">-</span><span class="n">xi</span><span class="p">,</span> <span class="n">S_up</span><span class="p">,</span> <span class="n">St_max</span><span class="p">)</span>

    <span class="c"># Both roots on xi_minus. Split the interval first</span>
    <span class="k">elif</span> <span class="n">xi</span> <span class="o">&lt;</span> <span class="n">xi_low</span> <span class="ow">and</span> <span class="n">xi</span> <span class="o">&lt;</span> <span class="n">xi_up</span><span class="p">:</span>    
        <span class="k">if</span> <span class="n">whereareyou</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;[Sb_limits] Both roots on xi_minus&quot;</span>
            
        <span class="n">resmin</span><span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">fminbound</span><span class="p">(</span><span class="k">lambda</span> <span class="n">S</span><span class="p">:</span> <span class="n">xi_minus</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">),</span> <span class="n">St_min</span><span class="p">,</span> <span class="n">St_max</span><span class="p">,</span><span class="n">full_output</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">S_low</span><span class="o">=</span><span class="n">resmin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">xi_min</span><span class="o">=</span><span class="n">resmin</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                 
        <span class="k">if</span> <span class="n">xi_min</span><span class="o">&gt;</span><span class="n">xi</span><span class="p">:</span> <span class="c">#Braket failed! </span>
            <span class="k">print</span> <span class="s">&quot;[Sb_limits] Braket failed on xi_minus at r=&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="o">+</span><span class="s">&quot;. Assume Sb_min=Sb_max&quot;</span>
            <span class="n">Sb_min</span><span class="o">=</span><span class="n">S_low</span>
            <span class="n">Sb_max</span><span class="o">=</span><span class="n">S_low</span>  
        <span class="k">else</span><span class="p">:</span> <span class="c">#Braket succeeded!</span>
            <span class="n">Sb_min</span><span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="k">lambda</span> <span class="n">S</span><span class="p">:</span> <span class="n">xi_minus</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span><span class="o">-</span><span class="n">xi</span><span class="p">,</span> <span class="n">St_min</span><span class="p">,</span> <span class="n">S_low</span><span class="p">)</span>
            <span class="n">Sb_max</span><span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="k">lambda</span> <span class="n">S</span><span class="p">:</span> <span class="n">xi_minus</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span><span class="o">-</span><span class="n">xi</span><span class="p">,</span> <span class="n">S_low</span><span class="p">,</span> <span class="n">St_max</span><span class="p">)</span>

    <span class="c"># One root on xi_plus and the other one on xi_plus. No additional maximization is neeeded</span>
    <span class="k">elif</span> <span class="n">xi</span> <span class="o">&gt;=</span> <span class="n">xi_low</span> <span class="ow">and</span> <span class="n">xi</span> <span class="o">&lt;=</span> <span class="n">xi_up</span><span class="p">:</span>    
        <span class="k">if</span> <span class="n">whereareyou</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;[Sb_limits] Sb_min on xi_plus, Sb_max on xi_minus&quot;</span>

        <span class="n">Sb_min</span><span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="k">lambda</span> <span class="n">S</span><span class="p">:</span> <span class="n">xi_plus</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span><span class="o">-</span><span class="n">xi</span><span class="p">,</span> <span class="n">St_min</span><span class="p">,</span> <span class="n">St_max</span><span class="p">)</span>
        <span class="n">Sb_max</span><span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="k">lambda</span> <span class="n">S</span><span class="p">:</span> <span class="n">xi_minus</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span><span class="o">-</span><span class="n">xi</span><span class="p">,</span> <span class="n">St_min</span><span class="p">,</span> <span class="n">St_max</span><span class="p">)</span>
    
    <span class="k">elif</span> <span class="n">xi</span> <span class="o">&lt;=</span> <span class="n">xi_low</span> <span class="ow">and</span> <span class="n">xi</span> <span class="o">&gt;=</span> <span class="n">xi_up</span><span class="p">:</span>    
        <span class="k">if</span> <span class="n">whereareyou</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;[Sb_limits] Sb_min on xi_minus, Sb_max on xi_plus&quot;</span>

        <span class="n">Sb_min</span><span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="k">lambda</span> <span class="n">S</span><span class="p">:</span> <span class="n">xi_minus</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span><span class="o">-</span><span class="n">xi</span><span class="p">,</span> <span class="n">St_min</span><span class="p">,</span> <span class="n">St_max</span><span class="p">)</span>
        <span class="n">Sb_max</span><span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="k">lambda</span> <span class="n">S</span><span class="p">:</span> <span class="n">xi_plus</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span><span class="o">-</span><span class="n">xi</span><span class="p">,</span> <span class="n">St_min</span><span class="p">,</span> <span class="n">St_max</span><span class="p">)</span>
                    
    <span class="k">else</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&quot;[Sb_limits] Erorr in case selection&quot;</span>
        <span class="k">print</span> <span class="s">&quot;xi=&quot;</span><span class="p">,</span> <span class="n">xi</span>
        <span class="k">print</span> <span class="s">&quot;xi(Stmin)=&quot;</span><span class="p">,</span> <span class="n">xi_low</span>
        <span class="k">print</span> <span class="s">&quot;xi(Stmax)=&quot;</span><span class="p">,</span> <span class="n">xi_up</span>
        <span class="k">print</span> <span class="s">&quot;Stmin=&quot;</span><span class="p">,</span> <span class="n">St_min</span>
        <span class="k">print</span> <span class="s">&quot;Stmax&quot;</span><span class="p">,</span> <span class="n">St_max</span>
        <span class="k">print</span> <span class="s">&quot;J=&quot;</span><span class="p">,</span> <span class="n">J</span>
        <span class="k">print</span> <span class="s">&quot;L=&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
        <span class="k">print</span> <span class="s">&quot;r=&quot;</span><span class="p">,</span> <span class="n">r</span>
        <span class="k">assert</span> <span class="bp">False</span><span class="p">,</span> <span class="s">&quot;[Sb_limits] Erorr in case selection&quot;</span>
    
    <span class="n">btol</span><span class="o">=</span><span class="mf">1e-8</span> <span class="c"># Never go to close to the actual limits, because of numerical stabilty</span>
    <span class="n">Sb_min</span><span class="o">+=</span><span class="n">btol</span>
    <span class="n">Sb_max</span><span class="o">-=</span><span class="n">btol</span>

    <span class="k">if</span> <span class="n">whereareyou</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&quot;[Sb_limits] Results:&quot;</span><span class="p">,</span> <span class="n">Sb_min</span><span class="p">,</span><span class="n">Sb_max</span>
    
    <span class="k">if</span> <span class="n">Sb_min</span><span class="o">&gt;</span><span class="n">Sb_max</span><span class="p">:</span> <span class="c"># This may happen (numerically) if they&#39;re too close to each other. Assume they&#39;re the same.</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">Sb_min</span><span class="p">,</span><span class="n">Sb_max</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">Sb_min</span><span class="p">,</span><span class="n">Sb_max</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span> 
        <span class="k">return</span> <span class="n">Sb_min</span><span class="p">,</span> <span class="n">Sb_max</span>

  
<span class="k">def</span> <span class="nf">parametric_angles</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">):</span>
    
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Compute the angles theta1,theta2,deltaphi and theta12, given S, J and xi.</span>
<span class="sd">    Roundoff errors are fixed forcing cosines to be in [-1,1]. The thetas are</span>
<span class="sd">    polar angles in [0,pi]. Deltaphi is an azimuthal angle, in principle lies in</span>
<span class="sd">    [-pi,pi]. Here we assumed DeltaPhi to be in [0,pi] as returned by arcccos:</span>
<span class="sd">    one may need to add a sign, depending on the actual application of this</span>
<span class="sd">    function (see e.g. `precession.orbit_angles` below). This function can be</span>
<span class="sd">    seen as the inverse of `precession.from_the_angles`. In the equal-mass limit</span>
<span class="sd">    q=1, S doesn&#39;t parametrize the precessional motion; we track the binary</span>
<span class="sd">    precession using varphi explicitly.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        theta1,theta2,deltaphi,theta12=precession.parametric_angles(S,J,xi,q,S1,S2,r)</span>

<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `S`: magnitude of the total spin.   </span>
<span class="sd">    - `J`: magnitude of the total angular momentum.</span>
<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `r`: binary separation.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `theta1`: angle between the spin of the primary and the orbital angular momentum.</span>
<span class="sd">    - `theta2`: angle between the spin of the secondary and the orbital angular momentum.</span>
<span class="sd">    - `deltaphi`: angle between the projection of the two spins on the orbital plane.</span>
<span class="sd">    - `theta12`: angle between the two spins.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="n">L</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>

    <span class="k">global</span> <span class="n">flags_q1</span>    
    <span class="k">if</span> <span class="n">q</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">flags_q1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="bp">False</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;[parametric_angles] Warning q=1: input here is cos(varphi), not S.&quot;</span>
            <span class="n">flags_q1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="bp">True</span> <span class="c"># Suppress future warnings</span>
        <span class="n">cosvarphi</span><span class="o">=</span><span class="n">S</span> <span class="c"># The input variable is actually cos(varphi)</span>
        <span class="n">S</span><span class="o">=</span><span class="p">(</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">xi</span><span class="o">*</span><span class="n">L</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
        <span class="n">t4</span><span class="o">=</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="n">S</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">t5</span><span class="o">=</span><span class="p">(</span><span class="n">L</span><span class="o">+</span><span class="n">S</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">t6</span><span class="o">=</span><span class="p">(</span><span class="n">S1</span><span class="o">+</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">t7</span><span class="o">=</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>        
        <span class="n">B</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">t4</span><span class="o">*</span><span class="n">t5</span><span class="o">*</span><span class="n">t6</span><span class="o">*</span><span class="n">t7</span><span class="p">)</span>
        <span class="n">costheta1</span><span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">S1</span><span class="o">*</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">L</span><span class="p">))</span><span class="o">*</span><span class="p">((</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">S1</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">B</span><span class="p">)</span><span class="o">*</span><span class="n">cosvarphi</span><span class="p">)</span>
        <span class="n">costheta2</span><span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">S2</span><span class="o">*</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">L</span><span class="p">))</span><span class="o">*</span><span class="p">((</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">S2</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S1</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">B</span><span class="p">)</span><span class="o">*</span><span class="n">cosvarphi</span><span class="p">)</span>
    
    <span class="k">else</span><span class="p">:</span>
        <span class="n">costheta1</span><span class="o">=</span> <span class="p">(</span> <span class="p">((</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="n">L</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">q</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">xi</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span> <span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">S1</span><span class="p">)</span>
        <span class="n">costheta2</span><span class="o">=</span> <span class="p">(</span> <span class="p">((</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">q</span><span class="o">/</span><span class="n">L</span><span class="p">))</span> <span class="o">+</span> <span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">q</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">xi</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span> <span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">S2</span><span class="p">)</span>

    <span class="c"># Force all cosines in [-1,1].</span>
    <span class="n">costheta1</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="nb">min</span><span class="p">(</span><span class="n">costheta1</span><span class="p">,</span><span class="mf">1.</span><span class="p">))</span>
    <span class="n">theta1</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">costheta1</span><span class="p">)</span>
    <span class="n">costheta2</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="nb">min</span><span class="p">(</span><span class="n">costheta2</span><span class="p">,</span><span class="mf">1.</span><span class="p">))</span>
    <span class="n">theta2</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">costheta2</span><span class="p">)</span>
    <span class="n">costheta12</span><span class="o">=</span><span class="p">(</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S1</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">S1</span><span class="o">*</span><span class="n">S2</span><span class="p">)</span>
    <span class="n">costheta12</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="nb">min</span><span class="p">(</span><span class="n">costheta12</span><span class="p">,</span><span class="mf">1.</span><span class="p">))</span>
    <span class="n">theta12</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">costheta12</span><span class="p">)</span>
    <span class="n">cosdeltaphi</span><span class="o">=</span> <span class="p">(</span><span class="n">costheta12</span> <span class="o">-</span> <span class="n">costheta1</span><span class="o">*</span><span class="n">costheta2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta1</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta2</span><span class="p">))</span>    
    <span class="n">cosdeltaphi</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="nb">min</span><span class="p">(</span><span class="n">cosdeltaphi</span><span class="p">,</span><span class="mf">1.</span><span class="p">))</span>
    <span class="n">deltaphi</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">cosdeltaphi</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">theta1</span><span class="p">,</span><span class="n">theta2</span><span class="p">,</span><span class="n">deltaphi</span><span class="p">,</span><span class="n">theta12</span>


<span class="k">def</span> <span class="nf">from_the_angles</span><span class="p">(</span><span class="n">theta1</span><span class="p">,</span><span class="n">theta2</span><span class="p">,</span><span class="n">deltaphi</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Convert a set of angles theta1,theta2,deltaphi into values of J,xi,S. This</span>
<span class="sd">    function can be seen as the inverse of `precession.parametric_angles`. In</span>
<span class="sd">    the equal-mass limit q=1, S doesn&#39;t parametrize the precessional motion; we</span>
<span class="sd">    track the binary precession using varphi explicitly.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        xi,J,S=precession.from_the_angles(theta1,theta2,deltaphi,q,S1,S2,r)</span>

<span class="sd">    **Parameters:**</span>

<span class="sd">    - `theta1`: angle between the spin of the primary and the orbital angular momentum.</span>
<span class="sd">    - `theta2`: angle between the spin of the secondary and the orbital angular momentum.</span>
<span class="sd">    - `deltaphi`: angle between the projection of the two spins on the orbital plane.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `r`: binary separation.</span>

<span class="sd">    **Returns:**</span>
<span class="sd">    </span>
<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `J`: magnitude of the total angular momentum.</span>
<span class="sd">    - `S`: magnitude of the total spin.   </span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">L</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
    
    <span class="k">global</span> <span class="n">flags_q1</span>
    <span class="k">if</span> <span class="n">q</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">flags_q1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="bp">False</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;[from_the_angles] Warning q=1: output here is cos(varphi), not S.&quot;</span>
            <span class="n">flags_q1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="bp">True</span> <span class="c"># Suppress future warnings</span>
        <span class="n">xi</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">/</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">S1</span> <span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta1</span><span class="p">)</span><span class="o">+</span><span class="n">S2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta2</span><span class="p">))</span>
        <span class="n">Ssq</span> <span class="o">=</span> <span class="n">S1</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">S2</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">S1</span><span class="o">*</span><span class="n">S2</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta1</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta2</span><span class="p">)</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta1</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta2</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">deltaphi</span><span class="p">))</span>
        <span class="n">J</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Ssq</span><span class="o">+</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">xi</span><span class="o">*</span><span class="n">L</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">t6</span><span class="o">=</span><span class="p">((</span><span class="n">S1</span><span class="o">+</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">Ssq</span><span class="p">)</span>
        <span class="n">t7</span><span class="o">=</span><span class="p">(</span><span class="n">Ssq</span><span class="o">-</span><span class="p">(</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>        
        <span class="n">B</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">Ssq</span><span class="o">-</span><span class="n">xi</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span><span class="o">*</span><span class="n">t6</span><span class="o">*</span><span class="n">t7</span>
        <span class="n">cosvarphi</span><span class="o">=</span> <span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">S1</span><span class="o">*</span><span class="n">Ssq</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta1</span><span class="p">)</span><span class="o">-</span><span class="n">xi</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">Ssq</span><span class="o">+</span><span class="n">S1</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S2</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">B</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">cosvarphi</span> <span class="c"># The output variable is actually cos(varphi)</span>
    
    <span class="k">else</span><span class="p">:</span>
        <span class="n">xi</span><span class="o">=</span> <span class="p">((</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">S1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta1</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="o">**-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">S2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta2</span><span class="p">))</span><span class="o">*</span><span class="n">M</span><span class="o">**-</span><span class="mi">2</span>
        <span class="n">S</span><span class="o">=</span> <span class="p">(</span><span class="n">S1</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">S2</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="mf">2.</span><span class="o">*</span><span class="n">S1</span><span class="o">*</span><span class="n">S2</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta1</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta2</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">deltaphi</span><span class="p">)</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta1</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta2</span><span class="p">)))</span><span class="o">**.</span><span class="mi">5</span>
        <span class="n">J</span><span class="o">=</span> <span class="p">(</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="mf">2.</span><span class="o">*</span><span class="n">L</span><span class="o">*</span><span class="p">(</span><span class="n">S1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta1</span><span class="p">)</span><span class="o">+</span><span class="n">S2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta2</span><span class="p">)))</span><span class="o">**.</span><span class="mi">5</span>
        <span class="k">return</span> <span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">S</span>


<span class="k">def</span> <span class="nf">xi_allowed</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">,</span> <span class="n">more</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Find the allowed range of xi for fixed J, corresponding to the extrema of</span>
<span class="sd">    the effective potential. Two implementations are presented, and are</span>
<span class="sd">    controlled by the inner flag use_derivative. If False (default, suggested),</span>
<span class="sd">    scipy&#39;s fminbound minimization algorithm is applied to the effective</span>
<span class="sd">    potentials `precession.xi_minus` and `precession.xi_plus`. If True, we</span>
<span class="sd">    explicitly look for the zeroes of the derivative of the effective potentials</span>
<span class="sd">    with respect to S. J. Vosmera found that the bisect root finder behaves</span>
<span class="sd">    better than brentq for low mass ratio. We believe both implementation are</span>
<span class="sd">    correct: the former has been tested more extensively, the latter has been</span>
<span class="sd">    found to be more reliable in the q-&gt;1 limit.</span>

<span class="sd">    WARNING: This function is critical. It&#39;s tested, but is tricky numerical</span>
<span class="sd">    issues may still be present.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        xi_low,xi_up=precession.xi_allowed(J,q,S1,S2,r,more=False,verbose=False)</span>

<span class="sd">        xi_low,xi_up,S_xilow,S_xiup=precession.xi_allowed(J,q,S1,S2,r,more=True,verbose=False)</span>


<span class="sd">    **Parameters:**</span>

<span class="sd">    - `J`: magnitude of the total angular momentum.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `r`: binary separation.</span>
<span class="sd">    - `more`: if `True` returns additional quantities.</span>
<span class="sd">    - `verbose`: if `True` print additional information.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `xi_low`: minimum allowed value of xi, given the input parameters.</span>
<span class="sd">    - `xi_up`: maximum allowed value of xi, given the input parameters.</span>
<span class="sd">    - `S_xilow`: (optional) value of S when xi=xi_low.</span>
<span class="sd">    - `S_xiup`: (optional) value of S when xi=xi_up.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="c"># Take care of possible pathologies at the edges of the parameter space</span>
    <span class="n">Jmin</span><span class="p">,</span><span class="n">Jmax</span><span class="o">=</span> <span class="n">J_lim</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">J</span><span class="o">==</span><span class="n">Jmin</span> <span class="ow">or</span> <span class="n">J</span><span class="o">==</span><span class="n">Jmax</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">J</span><span class="o">==</span><span class="n">Jmin</span><span class="p">:</span>
            <span class="n">xiboth</span><span class="p">,</span> <span class="n">dummy</span><span class="p">,</span> <span class="n">Sboth</span><span class="p">,</span> <span class="n">dummy</span> <span class="o">=</span> <span class="n">xi_at_Jlim</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">more</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">J</span><span class="o">==</span><span class="n">Jmax</span><span class="p">:</span>
            <span class="n">dummy</span><span class="p">,</span> <span class="n">xiboth</span><span class="p">,</span> <span class="n">dummy</span><span class="p">,</span> <span class="n">Sboth</span> <span class="o">=</span> <span class="n">xi_at_Jlim</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">more</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">more</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">xiboth</span><span class="p">,</span> <span class="n">xiboth</span><span class="p">,</span> <span class="n">Sboth</span><span class="p">,</span> <span class="n">Sboth</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">xiboth</span><span class="p">,</span> <span class="n">xiboth</span>
    
    <span class="n">St_min</span><span class="p">,</span><span class="n">St_max</span><span class="o">=</span><span class="n">St_limits</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
    
    <span class="c"># The extrema are at S=St_min, St_max</span>
    <span class="k">if</span> <span class="n">q</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">L</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
        <span class="n">xi_low</span><span class="o">=</span><span class="p">(</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">St_max</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">L</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">xi_up</span><span class="o">=</span><span class="p">(</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">St_min</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">L</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">S_xilow</span><span class="o">=</span><span class="n">St_max</span>
        <span class="n">S_xiup</span><span class="o">=</span><span class="n">St_min</span>

    <span class="c"># Extremize the two effective potentials.  </span>
    <span class="k">else</span><span class="p">:</span>
    
        <span class="n">use_derivative</span><span class="o">=</span><span class="bp">False</span>
        
        <span class="c">#Run a minimization algorithms on the effective potentials. </span>
        <span class="k">if</span> <span class="n">use_derivative</span><span class="o">==</span><span class="bp">False</span><span class="p">:</span>
        
            <span class="c"># Minimum of xi_minus</span>
            <span class="n">resmin</span><span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">fminbound</span><span class="p">(</span><span class="k">lambda</span> <span class="n">S</span><span class="p">:</span> <span class="n">xi_minus</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">),</span> <span class="n">St_min</span><span class="p">,</span> <span class="n">St_max</span><span class="p">,</span><span class="n">xtol</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">,</span><span class="n">full_output</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">S_xilow</span><span class="o">=</span><span class="n">resmin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> 
            <span class="n">xi_low</span><span class="o">=</span><span class="n">resmin</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="c"># Maximum of xi_plus. Scipy provides minimization algorithms: minimize -xi_plus and change sign at the end.</span>
            <span class="n">resmax</span><span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">fminbound</span><span class="p">(</span><span class="k">lambda</span> <span class="n">S</span><span class="p">:</span> <span class="o">-</span><span class="mf">1.</span><span class="o">*</span><span class="n">xi_plus</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">),</span> <span class="n">St_min</span><span class="p">,</span> <span class="n">St_max</span><span class="p">,</span><span class="n">xtol</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">,</span><span class="n">full_output</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">S_xiup</span><span class="o">=</span><span class="n">resmax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> 
            <span class="n">xi_up</span><span class="o">=-</span><span class="mf">1.</span><span class="o">*</span><span class="n">resmax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c"># Run a root finders on the derivative of the effective potentials. </span>
        <span class="k">elif</span> <span class="n">use_derivative</span><span class="o">==</span><span class="bp">True</span><span class="p">:</span>
        
            <span class="k">if</span> <span class="n">q</span><span class="o">&lt;</span><span class="mf">0.1</span><span class="p">:</span> <span class="c"># bisect behaves better for extreme mass ratios...</span>
                <span class="n">S_xilow</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">bisect</span><span class="p">(</span><span class="k">lambda</span> <span class="n">S</span><span class="p">:</span> <span class="n">dxidS_plus</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">),</span> <span class="n">St_min</span><span class="p">,</span> <span class="n">St_max</span><span class="p">,</span><span class="n">xtol</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">)</span>     
                <span class="n">S_xiup</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">bisect</span><span class="p">(</span><span class="k">lambda</span> <span class="n">S</span><span class="p">:</span> <span class="n">dxidS_minus</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">),</span> <span class="n">St_min</span><span class="p">,</span> <span class="n">St_max</span><span class="p">,</span><span class="n">xtol</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span> <span class="c"># ... but brentq is faster</span>
                <span class="n">S_xilow</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="k">lambda</span> <span class="n">S</span><span class="p">:</span> <span class="n">dxidS_plus</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">),</span> <span class="n">St_min</span><span class="p">,</span> <span class="n">St_max</span><span class="p">,</span><span class="n">xtol</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">)</span>    
                <span class="n">S_xiup</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="k">lambda</span> <span class="n">S</span><span class="p">:</span> <span class="n">dxidS_minus</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">),</span> <span class="n">St_min</span><span class="p">,</span> <span class="n">St_max</span><span class="p">,</span><span class="n">xtol</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">)</span>
            <span class="n">xi_low</span><span class="o">=</span><span class="n">xi_minus</span><span class="p">(</span><span class="n">S_xilow</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
            <span class="n">xi_up</span> <span class="o">=</span><span class="n">xi_plus</span><span class="p">(</span><span class="n">S_xiup</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&quot;[xi_allowed] xi_low&quot;</span><span class="p">,</span> <span class="n">xi_low</span><span class="p">,</span> <span class="s">&quot; xi_up=&quot;</span><span class="p">,</span> <span class="n">xi_up</span>
    <span class="k">if</span> <span class="n">more</span><span class="p">:</span> <span class="c"># Return the S values as well</span>
        <span class="k">return</span> <span class="n">xi_low</span><span class="p">,</span> <span class="n">xi_up</span><span class="p">,</span> <span class="n">S_xilow</span><span class="p">,</span> <span class="n">S_xiup</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">xi_low</span><span class="p">,</span> <span class="n">xi_up</span>


<span class="k">def</span> <span class="nf">resonant_finder</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">,</span> <span class="n">more</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Find the spin-orbit resonances, for given xi, as extrema of the allowed</span>
<span class="sd">    region in the parameter space. Two resonances are present for DeltaPhi=0 and</span>
<span class="sd">    DeltaPhi=pi. They maximize (0) and minimize (pi) J for fixed xi. This is an</span>
<span class="sd">    alternative (and more powerful) approach to solving the Schnittman equation,</span>
<span class="sd">    given in Eq.(35) of [PRD</span>
<span class="sd">    70,124020(2004)](http://journals.aps.org/prd/abstract/10.1103/PhysRevD.70.</span>
<span class="sd">    124020).</span>
<span class="sd">    </span>
<span class="sd">    **Call:**</span>

<span class="sd">        theta1_dp0,theta2_dp0,theta1_dp180,theta2_dp180=precession.resonant_finder(xi,q,S1,S2,r,more=False)</span>

<span class="sd">        J_dp0,S_dp0,theta1_dp0,theta2_dp0,J_dp180,S_dp180,theta1_dp180,theta2_dp180=precession.resonant_finder(xi,q,S1,S2,r,more=True)</span>

<span class="sd">    **Parameters:**</span>

<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `r`: binary separation.</span>
<span class="sd">    - `more`: if `True` returns additional quantities.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - J_dp0: (optional) value of J for the DeltaPhi=0 resonance.</span>
<span class="sd">    - S_dp0: (optional) value of S for the DeltaPhi=0 resonance.</span>
<span class="sd">    - theta1_dp0: value of theta1 for the DeltaPhi=0 resonance.</span>
<span class="sd">    - theta2_dp0: value of theta2 for the DeltaPhi=pi resonance.</span>
<span class="sd">    - J_dp180: (optional) value of J for the DeltaPhi=pi resonance.</span>
<span class="sd">    - S_dp180: (optional) value of S for the DeltaPhi=pi resonance.</span>
<span class="sd">    - theta1_dp180: value of theta1 for the DeltaPhi=pi resonance.</span>
<span class="sd">    - theta2_dp180: value of theta2 for the DeltaPhi=pi resonance. </span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="n">Jmin</span><span class="p">,</span><span class="n">Jmax</span><span class="o">=</span><span class="n">J_lim</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>    
    <span class="n">L</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>    
    
    <span class="c">#DeltaPhi=0 resonance.</span>
    <span class="n">J_dp0</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="k">lambda</span> <span class="n">J</span><span class="p">:</span> <span class="n">xi_allowed</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span><span class="n">xi</span> <span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">),</span> <span class="n">Jmax</span><span class="p">,</span><span class="n">xtol</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">q</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> 
        <span class="c"># Find S. St_max</span>
        <span class="n">S_dp0</span><span class="o">=</span><span class="n">St_limits</span><span class="p">(</span><span class="n">J_dp0</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="c"># Find angles</span>
        <span class="n">theta1_dp0</span><span class="p">,</span><span class="n">theta2_dp0</span><span class="p">,</span><span class="n">deltaphi_dp0</span><span class="p">,</span><span class="n">dummy</span> <span class="o">=</span> <span class="n">parametric_angles</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">J_dp0</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>   
                
    <span class="k">else</span><span class="p">:</span>
        <span class="c"># Find S. Minimum of effective potential       </span>
        <span class="n">dummy</span><span class="p">,</span><span class="n">dummy</span><span class="p">,</span><span class="n">S_dp0</span><span class="p">,</span><span class="n">dummy</span><span class="o">=</span> <span class="n">xi_allowed</span><span class="p">(</span><span class="n">J_dp0</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">more</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="c"># Find angles</span>
        <span class="n">theta1_dp0</span><span class="p">,</span><span class="n">theta2_dp0</span><span class="p">,</span><span class="n">deltaphi_dp0</span><span class="p">,</span><span class="n">dummy</span> <span class="o">=</span> <span class="n">parametric_angles</span><span class="p">(</span><span class="n">S_dp0</span><span class="p">,</span><span class="n">J_dp0</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>

    <span class="c">#DeltaPhi=180 resonance.</span>
    <span class="n">xi_Jmin</span><span class="p">,</span><span class="n">xi_Jmax</span><span class="o">=</span> <span class="n">xi_at_Jlim</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
            
    <span class="k">if</span> <span class="n">xi</span><span class="o">&gt;</span><span class="n">xi_Jmin</span><span class="p">:</span>
        <span class="c"># Find J. Solution always on xi_max, between Jmin and Jmax</span>
        <span class="n">J_dp180</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="k">lambda</span> <span class="n">J</span><span class="p">:</span> <span class="n">xi_allowed</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span><span class="n">xi</span> <span class="p">,</span> <span class="n">Jmin</span><span class="p">,</span> <span class="n">Jmax</span><span class="p">,</span><span class="n">xtol</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">q</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="c"># Find S. St_min</span>
            <span class="n">S_dp180</span><span class="o">=</span><span class="n">St_limits</span><span class="p">(</span><span class="n">J_dp180</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c"># Find angles</span>
            <span class="n">theta1_dp180</span><span class="p">,</span><span class="n">theta2_dp180</span><span class="p">,</span><span class="n">deltaphi_dp0</span><span class="p">,</span><span class="n">dummy</span> <span class="o">=</span> <span class="n">parametric_angles</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">J_dp180</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>   
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># Find S. Maximum of effective potential</span>
            <span class="n">dummy</span><span class="p">,</span><span class="n">dummy</span><span class="p">,</span><span class="n">dummy</span><span class="p">,</span><span class="n">S_dp180</span><span class="o">=</span> <span class="n">xi_allowed</span><span class="p">(</span><span class="n">J_dp180</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">more</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="c"># Find angles</span>
            <span class="n">theta1_dp180</span><span class="p">,</span><span class="n">theta2_dp180</span><span class="p">,</span><span class="n">deltaphi_dp180</span><span class="p">,</span><span class="n">dummy</span> <span class="o">=</span> <span class="n">parametric_angles</span><span class="p">(</span><span class="n">S_dp180</span><span class="p">,</span><span class="n">J_dp180</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c"># Find J. Solution still on xi_min, between Jmin and L-S1-S2. You&#39;re not here if Jmin=L-S1-S2, because xi_Jmin is the lower allowed value for xi in that case.</span>
        <span class="n">J_dp180</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="k">lambda</span> <span class="n">J</span><span class="p">:</span> <span class="n">xi_allowed</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span><span class="n">xi</span> <span class="p">,</span><span class="n">Jmin</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">),</span><span class="n">xtol</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">q</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="c"># Find S. St_max</span>
            <span class="n">S_dp180</span><span class="o">=</span><span class="n">St_limits</span><span class="p">(</span><span class="n">J_dp180</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
            <span class="c"># Find angles</span>
            <span class="n">theta1_dp180</span><span class="p">,</span><span class="n">theta2_dp180</span><span class="p">,</span><span class="n">deltaphi_dp0</span><span class="p">,</span><span class="n">dummy</span> <span class="o">=</span> <span class="n">parametric_angles</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">J_dp180</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>   
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># Find S. Minimum of effective potential</span>
            <span class="n">dummy</span><span class="p">,</span><span class="n">dummy</span><span class="p">,</span><span class="n">S_dp180</span><span class="p">,</span><span class="n">dummy</span><span class="o">=</span> <span class="n">xi_allowed</span><span class="p">(</span><span class="n">J_dp180</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">more</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="c"># Find angles</span>
            <span class="n">theta1_dp180</span><span class="p">,</span><span class="n">theta2_dp180</span><span class="p">,</span><span class="n">deltaphi_dp180</span><span class="p">,</span><span class="n">dummy</span> <span class="o">=</span> <span class="n">parametric_angles</span><span class="p">(</span><span class="n">S_dp180</span><span class="p">,</span><span class="n">J_dp180</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
       
    <span class="k">if</span> <span class="bp">False</span><span class="p">:</span> <span class="c"># Sanity check. </span>
        <span class="k">print</span> <span class="s">&quot;DeltaPhi=0?&quot;</span><span class="p">,</span> <span class="n">deltaphi_dp0</span>
        <span class="k">print</span> <span class="s">&quot;DeltaPhi=pi?&quot;</span><span class="p">,</span> <span class="n">deltaphi_dp180</span>
    
    <span class="k">if</span> <span class="n">more</span><span class="p">:</span> <span class="c"># return everything you got</span>
        <span class="k">return</span> <span class="n">J_dp0</span><span class="p">,</span> <span class="n">S_dp0</span><span class="p">,</span> <span class="n">theta1_dp0</span><span class="p">,</span> <span class="n">theta2_dp0</span><span class="p">,</span> <span class="n">J_dp180</span><span class="p">,</span> <span class="n">S_dp180</span><span class="p">,</span> <span class="n">theta1_dp180</span><span class="p">,</span> <span class="n">theta2_dp180</span>
    <span class="k">else</span><span class="p">:</span> <span class="c"># return the angles only</span>
        <span class="k">return</span> <span class="n">theta1_dp0</span><span class="p">,</span> <span class="n">theta2_dp0</span><span class="p">,</span> <span class="n">theta1_dp180</span><span class="p">,</span> <span class="n">theta2_dp180</span>


<span class="k">def</span> <span class="nf">J_allowed</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Find allowed values of J for fixed xi, i.e the spin-orbit resonances. See</span>
<span class="sd">    `precession.resonant_finder`.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        J_low,J_up=precession.J_allowed(xi,q,S1,S2,r)</span>
<span class="sd">    </span>
<span class="sd">    **Parameters:**</span>

<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `r`: binary separation.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `J_low`: minimum allowed value of J, given the input parameters.</span>
<span class="sd">    - `J_up`: maximum allowed value of J, given the input parameters.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="n">J_dp0</span><span class="p">,</span> <span class="n">dummy</span><span class="p">,</span> <span class="n">dummy</span><span class="p">,</span> <span class="n">dummy</span><span class="p">,</span> <span class="n">J_dp180</span><span class="p">,</span> <span class="n">dummy</span><span class="p">,</span> <span class="n">dummy</span><span class="p">,</span> <span class="n">dummy</span> <span class="o">=</span> <span class="n">resonant_finder</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">,</span> <span class="n">more</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">J_dp0</span><span class="p">,</span><span class="n">J_dp180</span><span class="p">),</span><span class="nb">max</span><span class="p">(</span><span class="n">J_dp0</span><span class="p">,</span><span class="n">J_dp180</span><span class="p">)</span>
 
 
<span class="k">def</span> <span class="nf">thetas_inf</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">kappa_inf</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Find the asymptotic (constant) values of theta1 and theta2 given xi and</span>
<span class="sd">    kappa_inf.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        theta1_inf,theta2_inf=precession.thetas_inf(xi,kappa_inf,q,S1,S2)</span>

<span class="sd">    **Parameters:**</span>

<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `kappa_inf`: asymptotic value of kappa at large separations.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `theta1_inf`: asymptotic value of theta1 at large separations.</span>
<span class="sd">    - `theta2_inf`: asymptotic value of theta2 at large separations.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="k">if</span> <span class="n">q</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">assert</span> <span class="bp">False</span><span class="p">,</span> <span class="s">&quot;[thetas_inf] Error: I&#39;m sorry, can&#39;t run for q=1. The angles theta1 and theta2 are not constant at large separations.&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ct1</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="n">xi</span> <span class="o">+</span> <span class="n">kappa_inf</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)))</span><span class="o">/</span><span class="p">(</span><span class="n">S1</span><span class="o">*</span><span class="p">(</span><span class="n">q</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="n">q</span><span class="p">))</span>
        <span class="n">ct2</span><span class="o">=</span><span class="p">(</span><span class="n">xi</span> <span class="o">-</span> <span class="n">kappa_inf</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="n">S2</span><span class="o">*</span><span class="p">(</span><span class="n">q</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="n">q</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">ct1</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">ct2</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">from_the_angles_inf</span><span class="p">(</span><span class="n">theta1_inf</span><span class="p">,</span><span class="n">theta2_inf</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">):</span>
    
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Find xi and kappa_inf given the asymptotic (constant) values of theta1 and</span>
<span class="sd">    theta2.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        xi,kappa_inf=precession.from_the_angles_inf(theta1_inf,theta2_inf,q,S1,S2)</span>
<span class="sd">    </span>
<span class="sd">    **Parameters:**</span>

<span class="sd">    - `theta1_inf`: asymptotic value of theta1 at large separations.</span>
<span class="sd">    - `theta2_inf`: asymptotic value of theta2 at large separations.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    </span>
<span class="sd">    **Returns:**</span>

<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `kappa_inf`: asymptotic value of kappa at large separations.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="k">if</span> <span class="n">q</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">assert</span> <span class="bp">False</span><span class="p">,</span> <span class="s">&quot;[from_the_angles_inf] Error: I&#39;m sorry, can&#39;t run for q=1. The angles theta1 and theta2 are not constant at large separations.&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">xi</span><span class="o">=</span> <span class="p">((</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">S1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta1_inf</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="o">**-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">S2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta2_inf</span><span class="p">))</span><span class="o">*</span><span class="n">M</span><span class="o">**-</span><span class="mi">2</span>
        <span class="n">kappa_inf</span><span class="o">=</span> <span class="p">(</span><span class="n">S1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta1_inf</span><span class="p">)</span><span class="o">+</span><span class="n">S2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta2_inf</span><span class="p">))</span><span class="o">*</span><span class="n">M</span><span class="o">**-</span><span class="mi">2</span>
        <span class="k">return</span> <span class="n">xi</span><span class="p">,</span><span class="n">kappa_inf</span>

    
<span class="k">def</span> <span class="nf">aligned_configurations</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Values of xi and J corresponding to the four (anti)aligned configuration:</span>
<span class="sd">    up-up (spins of both primary and secondary BH aligned with L); up-up (spins</span>
<span class="sd">    of both primary and secondary BH antialigned with L); up-down (spin of the</span>
<span class="sd">    primary BH aligned with L; spin of the secondary BH antialigned with L);</span>
<span class="sd">    down-up (spin of the primary BH aligned with L; spin of the secondary BH</span>
<span class="sd">    antialigned with L).</span>

<span class="sd">    **Call:**</span>

<span class="sd">        xiupup,xidowndown,xiupdown,xidownup,Jupup,Jdowndown,Jupdown,Jdownup=precession.aligned_configurations(q,S1,S2,r)</span>

<span class="sd">    **Parameters:**</span>

<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">     - `r`: binary separation.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `xiupup`: xi of the up-up configuration.</span>
<span class="sd">    - `xidowndown`: xi of the down-down configuration.</span>
<span class="sd">    - `xiupdown`: xi of the up-down configuration.</span>
<span class="sd">    - `xidownup`: xi of the down-up configuration.</span>
<span class="sd">    - `Jupup`: J of the up-up configuration.</span>
<span class="sd">    - `Jdowndown`: J of the down-down configuration.</span>
<span class="sd">    - `Jupdown`: J of the up-down configuration.</span>
<span class="sd">    - `Jdownup`: J of the down-up configuration.</span>
<span class="sd">    &#39;&#39;&#39;</span>



    <span class="n">L</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
    
    <span class="n">xiupup</span><span class="o">=</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">S1</span><span class="o">+</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">q</span><span class="o">**-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">S2</span>
    <span class="n">xidowndown</span><span class="o">=-</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">S1</span><span class="o">-</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">q</span><span class="o">**-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">S2</span>
    <span class="n">xiupdown</span><span class="o">=</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">S1</span><span class="o">-</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">q</span><span class="o">**-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">S2</span>
    <span class="n">xidownup</span><span class="o">=-</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">S1</span><span class="o">+</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">q</span><span class="o">**-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">S2</span>

    <span class="n">Jupup</span><span class="o">=</span><span class="n">L</span><span class="o">+</span><span class="n">S1</span><span class="o">+</span><span class="n">S2</span>
    <span class="n">Jdowndown</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">)</span>
    <span class="n">Jupdown</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">L</span><span class="o">+</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">)</span>
    <span class="n">Jdownup</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="n">S1</span><span class="o">+</span><span class="n">S2</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">xiupup</span><span class="p">,</span><span class="n">xidowndown</span><span class="p">,</span><span class="n">xiupdown</span><span class="p">,</span><span class="n">xidownup</span><span class="p">,</span><span class="n">Jupup</span><span class="p">,</span><span class="n">Jdowndown</span><span class="p">,</span><span class="n">Jupdown</span><span class="p">,</span><span class="n">Jdownup</span>


<span class="k">def</span> <span class="nf">updown</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">):</span>
    
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Instability range for up-down aligned binaries. Binaries with the primary</span>
<span class="sd">    (secondary) spin aligned (antialigned) with the angular momentum are</span>
<span class="sd">    unstable between the two separations returned. Hack the code to compute also</span>
<span class="sd">    the function *switch*, for a sanity check on the property of the second</span>
<span class="sd">    threshold (whether that&#39;s on `precession.xi_plus` or on</span>
<span class="sd">    `precession.xi_minus`). All up-down binaries are stable in the equal-mass</span>
<span class="sd">    case: if q=1 returns Nones.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        r_udp,r_udm=precession.updown(q,S1,S2)</span>

<span class="sd">    **Parameters:**</span>

<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    </span>
<span class="sd">    **Returns:**</span>

<span class="sd">    - `r_udp`: upper separation for the up-down instability.</span>
<span class="sd">    - `r_udm`: lower separation for the up-down instability.    </span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="n">q</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&quot;[updown] Warning: up-down is always stable for q=1. Retuning Nones.&quot;</span>
        <span class="k">return</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span>

    <span class="n">r_udp</span><span class="o">=</span><span class="p">((</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span><span class="p">((</span><span class="n">q</span><span class="o">*</span><span class="n">S1</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span> <span class="o">+</span> <span class="n">S2</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">((</span><span class="mf">1.</span><span class="o">-</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">q</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">r_udm</span><span class="o">=</span><span class="p">((</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span><span class="p">((</span><span class="n">q</span><span class="o">*</span><span class="n">S1</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span> <span class="o">-</span> <span class="n">S2</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">((</span><span class="mf">1.</span><span class="o">-</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">q</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span>
    
    <span class="k">if</span> <span class="bp">False</span><span class="p">:</span>
        <span class="n">switch</span><span class="o">=</span><span class="n">q</span><span class="o">**</span><span class="mf">0.5</span><span class="o">+</span> <span class="n">q</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">S2</span><span class="o">/</span><span class="n">S1</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span> <span class="o">-</span> <span class="p">(</span><span class="n">S2</span><span class="o">/</span><span class="n">S1</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">r_udp</span><span class="p">,</span><span class="n">r_udm</span><span class="p">,</span><span class="n">switch</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">r_udp</span><span class="p">,</span><span class="n">r_udm</span>
    


    
<span class="c">#################################</span>
<span class="c">######### MORPHOLOGIES ##########</span>
<span class="c">#################################</span>


<span class="k">def</span> <span class="nf">find_morphology</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Compute the precessional morphology in DeltaPhi. Returns:</span>
<span class="sd">    </span>
<span class="sd">    - -1 if librating about DeltaPhi=0;</span>
<span class="sd">    - 0 if circulating in the whole DeltaPhi range [-pi,pi];</span>
<span class="sd">    - +1 if librating about DeltaPhi=pi.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        morphology=precession.find_morphology(xi,J,q,S1,S2,r)</span>

<span class="sd">    **Parameters:**</span>

<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `J`: magnitude of the total angular momentum.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `r`: binary separation.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - morphology: precessional morphology in DeltaPhi: -1 if librating about DeltaPhi=0; 0 if circulating; +1 if librating about DeltaPhi=pi.</span>
<span class="sd">    &#39;&#39;&#39;</span>
  
    <span class="k">if</span> <span class="n">q</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="c"># If q=1, the limits must be specified in cos(varphi)</span>
        <span class="n">Sb_min</span><span class="o">=-</span><span class="mi">1</span>
        <span class="n">Sb_max</span><span class="o">=</span><span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>    
        <span class="n">Sb_min</span><span class="p">,</span><span class="n">Sb_max</span><span class="o">=</span><span class="n">Sb_limits</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>      
    
    <span class="n">dummy</span><span class="p">,</span><span class="n">dummy</span><span class="p">,</span><span class="n">deltaphi_Sbmin</span><span class="p">,</span><span class="n">dummy</span> <span class="o">=</span> <span class="n">parametric_angles</span><span class="p">(</span><span class="n">Sb_min</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
    <span class="n">dummy</span><span class="p">,</span><span class="n">dummy</span><span class="p">,</span><span class="n">deltaphi_Sbmax</span><span class="p">,</span><span class="n">dummy</span> <span class="o">=</span> <span class="n">parametric_angles</span><span class="p">(</span><span class="n">Sb_max</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>

    <span class="c"># Both the initial and the final point in a precession cycle are &lt;pi/2. This is a libration about DeltaPhi=0</span>
    <span class="k">if</span> <span class="n">deltaphi_Sbmin</span><span class="o">&lt;</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">2.</span> <span class="ow">and</span> <span class="n">deltaphi_Sbmax</span><span class="o">&lt;</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">2.</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mf">1.</span>
    <span class="c"># Both the initial and the final point in a precession cycle are &gt;pi/2. This is a libration about DeltaPhi=180</span>
    <span class="k">elif</span> <span class="n">deltaphi_Sbmin</span><span class="o">&gt;</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">2.</span> <span class="ow">and</span> <span class="n">deltaphi_Sbmax</span><span class="o">&gt;</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">2.</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">1.</span>
    <span class="c"># The precession orbit crosses both DeltaPhi=0 and DeltaPhi=180. This is  circulation</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">0.</span>


<span class="k">def</span> <span class="nf">region_selection</span><span class="p">(</span><span class="n">varphi</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Get the morphology in the varphi plane. See `precession.find_morphology`.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        morphology=precession.region_selection(varphi,S,J,q,S1,S2,r)</span>

<span class="sd">    **Parameters:**</span>

<span class="sd">    - `varphi`: angle describing the rotation of S1 and S2 about S, in a frame aligned with J.</span>
<span class="sd">    - `S`: magnitude of the total spin.</span>
<span class="sd">    - `J`: magnitude of the total angular momentum.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `r`: binary separation.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - morphology: precessional morphology in DeltaPhi: -1 if librating about DeltaPhi=0; 0 if circulating; +1 if librating about DeltaPhi=pi.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="n">xi</span><span class="o">=</span><span class="n">xi_contour</span><span class="p">(</span><span class="n">varphi</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">find_morphology</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
    
    
<span class="k">def</span> <span class="nf">phase_checker</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Computes the number of different morphologies you MAY have for a given</span>
<span class="sd">    geometrical configuration (i.e. given the lengths of the vectors L, S1 and</span>
<span class="sd">    S2). These are just geometrical constraints: the actual number of allowed</span>
<span class="sd">    morphologies depends on J, as returned by `precession.phase_xi`, but it</span>
<span class="sd">    can&#39;t be out of what returned by this function. This function is basically a</span>
<span class="sd">    sanity check for `precession.phase_xi`.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        phases_vals=precession.phase_checker(q,S1,S2,r,verbose=False)</span>
<span class="sd">    </span>
<span class="sd">    **Parameters:**</span>

<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `r`: binary separation.</span>
<span class="sd">    - `verbose`: if True print additional information.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - phases_vals: number of coexisting morphologies: 1 if only the DeltaPhi~pi phase is present; 2 if two DeltaPhi~pi phases and a circulating phase are present; 3 if a librating DeltaPhi~0, a circulating, and a DeltaPhi~pi phase al all present (array).</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">L</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
    
    <span class="k">if</span> <span class="n">L</span> <span class="o">&gt;</span> <span class="n">S1</span> <span class="o">+</span> <span class="n">S2</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;L &gt; S1 + S2 : 3&quot;</span>
        <span class="n">phases</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    
    <span class="k">elif</span> <span class="p">(</span><span class="n">S1</span> <span class="o">+</span> <span class="n">S2</span> <span class="o">&gt;</span> <span class="n">L</span> <span class="ow">and</span> <span class="n">L</span> <span class="o">&gt;</span> <span class="nb">max</span><span class="p">(</span><span class="n">S1</span><span class="p">,</span> <span class="n">S2</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;S1 + S2 &gt; L &gt; max(S1, S2) : 3,1&quot;</span>
        <span class="n">phases</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">elif</span> <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">L</span> <span class="ow">and</span>  <span class="n">L</span><span class="o">&gt;</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;max(S1,S2) &gt; L &gt; |S1-S2| : 3,2,1&quot;</span>
        <span class="n">phases</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
    
    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">L</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;|S1 - S2| &gt; L : 3,2&quot;</span>
        <span class="n">phases</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="bp">False</span><span class="p">,</span> <span class="s">&quot;[phase_checker] Error. You should never be here!&quot;</span>        
        
    <span class="k">return</span> <span class="n">phases</span>


<span class="k">def</span> <span class="nf">phase_xi</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">):</span> 

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Return an integer number, phases, specifying the number of precessional</span>
<span class="sd">    morphologies that can coexist for a given value of J. Returns:</span>

<span class="sd">    - 1 if only the DeltaPhi~pi phase is present;</span>
<span class="sd">    - 2 if two DeltaPhi~pi phases</span>
<span class="sd">    and a circulating phase are present;</span>
<span class="sd">    - 3 if a librating DeltaPhi~0, a</span>
<span class="sd">    circulating, and a DeltaPhi~pi phase al all present.</span>

<span class="sd">    The latter is *standard* case studied in [our first</span>
<span class="sd">    PRL](http://journals.aps.org/prl/abstract/10.1103/PhysRevLett.114.081103).</span>
<span class="sd">    Additionally, return the values of xi that, for given J, separate the</span>
<span class="sd">    binaries with different morphologies. If there are no transitions (i.e.</span>
<span class="sd">    phase=1), the transition values of xi are returned as Nones. If transitions</span>
<span class="sd">    cannot be found for numerical reasons, assume they coincides with the</span>
<span class="sd">    extrema of xi (see `precession.xi_allowed`). The output of this function can</span>
<span class="sd">    be tested with `precession.phase_checker`.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        phase,xi_transit_low,xi_transit_up=precession.phase_xi(J,q,S1,S2,r)</span>
<span class="sd">    </span>
<span class="sd">    **Parameters:**</span>

<span class="sd">    - `J`: magnitude of the total angular momentum.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `r`: binary separation.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - phase: number of coexisting morphologies: 1 if only the DeltaPhi~pi phase is present; 2 if two DeltaPhi~pi phases and a circulating phase are present; 3 if a librating DeltaPhi~0, a circulating, and a DeltaPhi~pi phase al all present.</span>
<span class="sd">    - xi_transit_low: value of xi marking the transition between the low and the middle phase</span>
<span class="sd">    - xi_transit_up: value of xi marking the transition between the upper and the middle phase</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">xi_min</span><span class="p">,</span><span class="n">xi_max</span><span class="o">=</span><span class="n">xi_allowed</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
    <span class="n">L</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
    
    <span class="c"># The following should be equivalent to apply find_morphology at xi_min and xi_max but it turns out to be more stable to numerical noise because it doesn&#39;t rely on Sb_limits</span>
    <span class="n">St_min</span><span class="p">,</span><span class="n">St_max</span><span class="o">=</span><span class="n">St_limits</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
    <span class="n">morph_ximin</span><span class="o">=</span><span class="n">find_morphology</span><span class="p">(</span><span class="n">xi_plus</span><span class="p">(</span><span class="n">St_max</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">),</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
    <span class="n">morph_ximax</span><span class="o">=</span><span class="n">find_morphology</span><span class="p">(</span><span class="n">xi_plus</span><span class="p">(</span><span class="n">St_min</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">),</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
    
    
    <span class="c"># The morphology at xi_max must be librating about pi. The morphology at xi_min can&#39;t be circulating.  Check if, because of degeneracies and numerical issues, a different morphology is be detected... </span>
    <span class="k">if</span> <span class="n">morph_ximax</span><span class="o">!=</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">morph_ximin</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&quot;[phase_xi] I think this should never ever happen. morph_ximax=&quot;</span><span class="p">,</span><span class="n">morph_ximax</span><span class="p">,</span><span class="s">&quot; morph_ximin=&quot;</span><span class="p">,</span><span class="n">morph_ximin</span>
        <span class="k">if</span> <span class="n">morph_ximin</span><span class="o">==-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">phase</span><span class="o">=</span><span class="mf">3.</span>
            <span class="n">xi_transit_up</span><span class="o">=</span><span class="n">xi_plus</span><span class="p">(</span><span class="n">St_min</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span><span class="o">+</span><span class="mf">1e-9</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">xi_transit_low</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="k">lambda</span> <span class="n">xi</span><span class="p">:</span> <span class="p">(</span><span class="n">find_morphology</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span> <span class="o">+</span><span class="mf">0.5</span><span class="p">),</span> <span class="n">xi_min</span><span class="p">,</span><span class="n">xi_transit_up</span><span class="o">-</span><span class="mf">1e-5</span><span class="p">,</span> <span class="n">xtol</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">xi_transit_low</span><span class="o">=</span><span class="n">xi_min</span>

            <span class="k">return</span> <span class="n">phase</span><span class="p">,</span><span class="n">xi_transit_low</span><span class="p">,</span><span class="n">xi_transit_up</span>
        
    <span class="k">if</span> <span class="n">morph_ximin</span><span class="o">==-</span><span class="mi">1</span><span class="p">:</span> 

        <span class="n">phase</span><span class="o">=</span><span class="mf">3.</span> <span class="c"># This is a three-phase case: Deltaphi~pi close to xi_max, Deltaphi~0 at xi_min and a circulating phase in between</span>

        <span class="c">#Find transition Librating 180 - Circulating. Shift the find_morphology output, such that the zero is between the two phases</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">xi_transit_up</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="k">lambda</span> <span class="n">xi</span><span class="p">:</span> <span class="p">(</span><span class="n">find_morphology</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">),</span> <span class="n">xi_min</span><span class="p">,</span><span class="n">xi_max</span><span class="p">,</span> <span class="n">xtol</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">xi_transit_up</span><span class="o">=</span><span class="n">xi_max</span>
            
        <span class="c">#Find transition Librating 0 - Circulating. Shift the find_morphology output, such that the zero is between the two phases</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">xi_transit_low</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="k">lambda</span> <span class="n">xi</span><span class="p">:</span> <span class="p">(</span><span class="n">find_morphology</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span> <span class="o">+</span><span class="mf">0.5</span><span class="p">),</span> <span class="n">xi_min</span><span class="p">,</span><span class="n">xi_max</span><span class="p">,</span> <span class="n">xtol</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">xi_transit_low</span><span class="o">=</span><span class="n">xi_min</span>
            
        <span class="c">#xi_transit_low,xi_transit_up=sorted([xi_transit_0,xi_transit_180])</span>

    <span class="k">elif</span> <span class="n">morph_ximin</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>  <span class="c"># This is either a two-phase or a single-phase case.</span>
        <span class="c"># Here we need to bracket the interval to find two roots. Two possible bracketing points are checked: the values of S for which</span>
            <span class="c"># [first try] cos(theta1)=1 and cos(theta2)= -1 </span>
            <span class="c"># [second try] cos(theta1)=-1 and cos(theta2)= 1 </span>
        <span class="c"># Either one of the two choice typically gives the correct results for all the cases we tried; we cannot exclude the presence of pathological sets of parameters where both choices fail.</span>

        <span class="k">for</span> <span class="n">xi_bracket</span> <span class="ow">in</span> <span class="p">[</span> <span class="o">-</span><span class="mf">1.</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">S1</span><span class="o">+</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="mf">1.</span><span class="o">/</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">S2</span> <span class="p">,</span> <span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">S1</span><span class="o">-</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="mf">1.</span><span class="o">/</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">S2</span> <span class="p">]:</span>
            <span class="k">if</span> <span class="n">xi_bracket</span><span class="o">&gt;</span><span class="n">xi_max</span> <span class="ow">or</span> <span class="n">xi_bracket</span><span class="o">&lt;</span><span class="n">xi_min</span><span class="p">:</span>
                <span class="n">phase</span><span class="o">=</span><span class="mf">1.</span> <span class="c"># Either the bracketing is wrong or this is a single-phase case</span>
                <span class="n">xi_transit_low</span><span class="o">=</span><span class="n">xi_min</span>
                <span class="n">xi_transit_up</span><span class="o">=</span><span class="n">xi_max</span>
            <span class="k">elif</span> <span class="n">find_morphology</span><span class="p">(</span><span class="n">xi_bracket</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">phase</span><span class="o">=</span><span class="mf">2.</span> <span class="c"># You found a good bracketing point. This must be a two-phase case             </span>
            
                <span class="c">#Find the first transition Librating 180 - Circulating at lower xi. Shift the find_morphology output, such that the zero is between the two phase</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">xi_transit_low</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="k">lambda</span> <span class="n">xi</span><span class="p">:</span> <span class="p">(</span><span class="n">find_morphology</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">),</span> <span class="n">xi_min</span><span class="p">,</span><span class="n">xi_bracket</span><span class="p">,</span> <span class="n">xtol</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="n">xi_transit_low</span><span class="o">=</span><span class="n">xi_min</span>
   
                <span class="c">#Find the other transition Librating 180 - Circulating at larger xi. Shift the find_morphology output, such that the zero is between the two phase</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">xi_transit_up</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="k">lambda</span> <span class="n">xi</span><span class="p">:</span>  <span class="p">(</span><span class="n">find_morphology</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">),</span> <span class="n">xi_bracket</span><span class="p">,</span><span class="n">xi_max</span><span class="p">,</span> <span class="n">xtol</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="n">xi_transit_up</span><span class="o">=</span><span class="n">xi_max</span>
             
                <span class="k">break</span> <span class="c"># One bracketing point is enough. Get out if you found the solution</span>
            
            <span class="k">else</span><span class="p">:</span>
                <span class="n">phase</span><span class="o">=</span><span class="mf">1.</span>  <span class="c"># Either the bracketing is wrong or this is a single-phase case</span>
                <span class="n">xi_transit_low</span><span class="o">=</span><span class="n">xi_min</span>
                <span class="n">xi_transit_up</span><span class="o">=</span><span class="n">xi_max</span>
                          
    <span class="k">if</span> <span class="n">phase</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">phase_checker</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">&quot;[phase_xi] Warning: detected phases not allowed by geometry!&quot;</span>

    <span class="k">return</span> <span class="n">phase</span><span class="p">,</span> <span class="n">xi_transit_low</span><span class="p">,</span><span class="n">xi_transit_up</span>


<span class="k">def</span> <span class="nf">Jframe_projection</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">):</span>    

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Project the three momenta on the reference frame aligned with the total</span>
<span class="sd">    angular momentum J. The z axis points in the J direction, and the x axis</span>
<span class="sd">    lies in the plane spanned by J and L. The y axis complete an orthonormal</span>
<span class="sd">    triad. Note that this is not an inertial frame (not even on the precession</span>
<span class="sd">    time) because it precesses together with L.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        Jvec,Lvec,S1vec,S2vec,Svec=precession.Jframe_projection(xi,S,J,q,S1,S2,r)</span>
<span class="sd">    </span>
<span class="sd">    **Parameters:**</span>

<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `S`: magnitude of the total spin.</span>
<span class="sd">    - `J`: magnitude of the total angular momentum.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `r`: binary separation.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `Jvec`: components of J in a reference frame (3 values for x,y,z).</span>
<span class="sd">    - `Lvec`: components of L in a reference frame (3 values for x,y,z).</span>
<span class="sd">    - `S1vec`: components of S1 in a reference frame (3 values for x,y,z).</span>
<span class="sd">    - `S2vec`: components of S2 in a reference frame (3 values for x,y,z).</span>
<span class="sd">    - `Svec`: components of S in a reference frame (3 values for x,y,z).</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="k">global</span> <span class="n">flags_q1</span>
    <span class="n">L</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
    
    <span class="k">if</span> <span class="n">q</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">flags_q1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">==</span><span class="bp">False</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;[Jframe_projection] Warning q=1: input here is cos(varphi), not S.&quot;</span>
            <span class="n">flags_q1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="bp">True</span>
        <span class="n">varphi</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
        <span class="n">S</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">xi</span><span class="o">*</span><span class="n">L</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">varphi</span><span class="o">=</span><span class="n">get_varphi</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">sign</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        
    <span class="n">Jx</span> <span class="o">=</span> <span class="mf">0.</span>
    <span class="n">Jy</span> <span class="o">=</span> <span class="mf">0.</span>
    <span class="n">Jz</span> <span class="o">=</span> <span class="n">J</span> <span class="c"># Definition!</span>
    
    <span class="n">Lx</span> <span class="o">=</span> <span class="p">(</span> <span class="p">(((</span><span class="n">L</span><span class="o">+</span><span class="n">S</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="n">S</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span><span class="p">)</span> <span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">J</span><span class="p">)</span>
    <span class="n">Ly</span> <span class="o">=</span> <span class="mf">0.</span> <span class="c"># Definition!</span>
    <span class="n">Lz</span> <span class="o">=</span> <span class="p">(</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">J</span><span class="p">)</span>
    
    <span class="n">S1x</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="mf">4.</span><span class="o">*</span><span class="n">J</span><span class="o">*</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">*</span> \
          <span class="p">(</span> <span class="o">-</span><span class="mf">1.</span><span class="o">*</span><span class="p">(</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">S1</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(((</span><span class="n">L</span><span class="o">+</span><span class="n">S</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="n">S</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span><span class="p">)</span> \
          <span class="o">+</span> <span class="p">(</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(((</span><span class="n">S1</span><span class="o">+</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">varphi</span><span class="p">)</span> <span class="p">)</span>
    <span class="n">S1y</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">S</span><span class="p">))</span><span class="o">*</span> \
          <span class="p">(((</span><span class="n">S1</span><span class="o">+</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span><span class="p">)</span>  <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">varphi</span><span class="p">)</span>
    <span class="n">S1z</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="mf">4.</span><span class="o">*</span><span class="n">J</span><span class="o">*</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">*</span> \
          <span class="p">(</span> <span class="p">(</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">S1</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> \
          <span class="o">+</span> <span class="p">(((</span><span class="n">L</span><span class="o">+</span><span class="n">S</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="n">S</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span><span class="p">)</span> <span class="o">*</span><span class="p">(((</span><span class="n">S1</span><span class="o">+</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span><span class="p">)</span> <span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">varphi</span><span class="p">)</span> <span class="p">)</span>

    <span class="n">S2x</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="mf">4.</span><span class="o">*</span><span class="n">J</span><span class="o">*</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">*</span> \
          <span class="p">(</span> <span class="p">(</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">S2</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S1</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(((</span><span class="n">L</span><span class="o">+</span><span class="n">S</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="n">S</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span><span class="p">)</span> \
          <span class="o">+</span> <span class="p">(</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(((</span><span class="n">S1</span><span class="o">+</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">varphi</span><span class="p">)</span> <span class="p">)</span>
    <span class="n">S2y</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">S</span><span class="p">))</span><span class="o">*</span> \
          <span class="p">(((</span><span class="n">S1</span><span class="o">+</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span><span class="p">)</span>  <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">varphi</span><span class="p">)</span>
    <span class="n">S2z</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="mf">4.</span><span class="o">*</span><span class="n">J</span><span class="o">*</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">*</span> \
          <span class="p">(</span> <span class="p">(</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">S2</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S1</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> \
          <span class="o">-</span> <span class="p">(((</span><span class="n">L</span><span class="o">+</span><span class="n">S</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="n">S</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span><span class="p">)</span> <span class="o">*</span><span class="p">(((</span><span class="n">S1</span><span class="o">+</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span><span class="p">)</span> <span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">varphi</span><span class="p">)</span> <span class="p">)</span>    

    <span class="n">Jvec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Jx</span><span class="p">,</span><span class="n">Jy</span><span class="p">,</span><span class="n">Jz</span><span class="p">])</span>
    <span class="n">Lvec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Lx</span><span class="p">,</span><span class="n">Ly</span><span class="p">,</span><span class="n">Lz</span><span class="p">])</span>
    <span class="n">S1vec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">S1x</span><span class="p">,</span><span class="n">S1y</span><span class="p">,</span><span class="n">S1z</span><span class="p">])</span>
    <span class="n">S2vec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">S2x</span><span class="p">,</span><span class="n">S2y</span><span class="p">,</span><span class="n">S2z</span><span class="p">])</span>
    <span class="n">Svec</span><span class="o">=</span> <span class="n">S1vec</span><span class="o">+</span><span class="n">S2vec</span>

    <span class="k">if</span> <span class="bp">False</span><span class="p">:</span> <span class="c">#Sanity check. These sets of numbers should really be the same</span>
        <span class="k">print</span> <span class="s">&quot;[Jframe_projection] Check varphi&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">varphi</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">varphi</span><span class="p">)</span>
        <span class="k">print</span> <span class="s">&quot;[Jframe_projection] Check J norm&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Jvec</span><span class="p">),</span> <span class="n">J</span>
        <span class="k">print</span> <span class="s">&quot;[Jframe_projection] Check norm&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Lvec</span><span class="p">),</span> <span class="n">L</span>
        <span class="k">print</span> <span class="s">&quot;[Jframe_projection] Check norm&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">S1vec</span><span class="p">),</span> <span class="n">S1</span>
        <span class="k">print</span> <span class="s">&quot;[Jframe_projection] Check norm&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">S2vec</span><span class="p">),</span> <span class="n">S2</span>
        <span class="k">print</span> <span class="s">&quot;[Jframe_projection] Check norm&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Svec</span><span class="p">),</span> <span class="n">S</span>

    <span class="k">return</span> <span class="n">Jvec</span><span class="p">,</span><span class="n">Lvec</span><span class="p">,</span><span class="n">S1vec</span><span class="p">,</span><span class="n">S2vec</span><span class="p">,</span><span class="n">Svec</span>




<span class="c">#################################</span>
<span class="c">### TIME-DEPENDENT PRECESSION ###</span>
<span class="c">#################################</span>


<span class="k">def</span> <span class="nf">Omegaz</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Compute the (azimuthal) precessional frequency of the orbital angular</span>
<span class="sd">    momentum L about the total angular momentum J.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        Omega=precession.Omegaz(S,xi,J,q,S1,S2,r)</span>
<span class="sd">    </span>
<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `S`: magnitude of the total spin.</span>
<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `J`: magnitude of the total angular momentum.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `r`: binary separation.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `Omega`: precessional frequency of L about J.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">L</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
    <span class="n">eta</span><span class="o">=</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">t1</span><span class="o">=</span><span class="p">(</span><span class="n">J</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span><span class="o">*</span><span class="p">((</span><span class="n">eta</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="o">/</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">t2</span><span class="o">=</span><span class="p">(</span><span class="mf">3.</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">eta</span><span class="p">))</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="p">(</span><span class="n">eta</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">xi</span><span class="o">/</span><span class="n">L</span><span class="p">))</span>
    <span class="n">t3</span><span class="o">=</span><span class="p">(</span><span class="mf">3.</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">q</span><span class="o">*</span><span class="p">(</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="n">S</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">((</span><span class="n">L</span><span class="o">+</span><span class="n">S</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="p">)))</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="p">(</span><span class="n">eta</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">xi</span><span class="o">/</span><span class="n">L</span><span class="p">))</span>
    <span class="n">t4</span><span class="o">=</span><span class="mf">4.</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">S1</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">t5</span><span class="o">=</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="mf">4.</span><span class="o">*</span><span class="n">eta</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">L</span><span class="o">*</span><span class="n">xi</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">t1</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">t2</span><span class="o">-</span><span class="n">t3</span><span class="o">*</span><span class="p">(</span><span class="n">t4</span><span class="o">-</span><span class="n">t5</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">dSdt</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">sign</span><span class="o">=</span><span class="mf">1.</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Compute the derivative of S with respect to t (on the precessional time</span>
<span class="sd">    only, i.e. assuming J is constant). Uses the spin-precession equations, but</span>
<span class="sd">    not the radiation reaction equation. The additional sign lets you specifiy</span>
<span class="sd">    the sign of the angle deltaphi: for consistency with what presented in our</span>
<span class="sd">    papers, use sign=1 if you are in the second half of the precession cycle</span>
<span class="sd">    (deltaphi is in [0,pi]) and sign=-1 if you are in the first half of the</span>
<span class="sd">    precession cycle (deltaphi is in [-pi,0]). If q=1, this function computes</span>
<span class="sd">    d(cos(varphi))/dt.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        dSdt=precession.dSdt(S,xi,J,q,S1,S2,r,sign=1.)</span>
<span class="sd">    </span>
<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `S`: magnitude of the total spin.</span>
<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `J`: magnitude of the total angular momentum.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `r`: binary separation.</span>
<span class="sd">    - `sign`: if 1 return angle in [0,pi], if -1 return angle in [-pi,0].</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `dSdt`: precessional-cycle speed.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">global</span> <span class="n">flags_q1</span>   

    <span class="n">L</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
    <span class="n">eta</span><span class="o">=</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>

    <span class="k">if</span> <span class="n">q</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">flags_q1</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">==</span><span class="bp">False</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;[dSdt] Warning q=1: input here is cos(varphi), not S; now computing d(cos(varphi))/dt &quot;</span>
            <span class="n">flags_q1</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">=</span><span class="bp">True</span>
        
        <span class="n">cosvarphi</span> <span class="o">=</span> <span class="n">S</span> <span class="c"># The input variable is actually cos(varphi)</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">xi</span><span class="o">*</span><span class="n">L</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">S_min</span><span class="p">,</span><span class="n">S_max</span><span class="o">=</span><span class="n">St_limits</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">S</span><span class="o">-</span><span class="n">S_min</span><span class="p">)</span><span class="o">&lt;</span><span class="mf">1e-8</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">S</span><span class="o">-</span><span class="n">S_max</span><span class="p">)</span><span class="o">&lt;</span><span class="mf">1e-8</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;[dSdt] Warning: you are at resonance, varphi is ill-defined here.&quot;</span>
            <span class="k">return</span> <span class="mf">0.</span>
        
        <span class="c"># Compute d(cos(varphi))/dt</span>
        <span class="n">t6</span><span class="o">=</span><span class="p">((</span><span class="n">S1</span><span class="o">+</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">t7</span><span class="o">=</span><span class="p">(</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>        
        <span class="n">B</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">xi</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span><span class="o">*</span><span class="n">t6</span><span class="o">*</span><span class="n">t7</span>
        <span class="c">#B=max(0.0,B)</span>
        <span class="n">t1</span><span class="o">=</span> <span class="p">(</span><span class="mi">12</span><span class="o">*</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">S1</span><span class="o">*</span><span class="n">S2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">B</span><span class="p">))</span>
        <span class="n">t2</span><span class="o">=</span> <span class="p">(</span><span class="n">eta</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span><span class="o">/</span><span class="n">L</span><span class="o">**</span><span class="mi">6</span>
        <span class="n">t3</span><span class="o">=</span> <span class="mi">1</span><span class="o">-</span><span class="p">(</span><span class="n">eta</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">xi</span><span class="p">)</span><span class="o">/</span><span class="n">L</span>
        <span class="n">ct1</span><span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">S1</span><span class="o">*</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">*</span><span class="p">(</span><span class="n">xi</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">S1</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">B</span><span class="p">)</span><span class="o">*</span><span class="n">cosvarphi</span><span class="p">)</span>
        <span class="n">ct2</span><span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">S2</span><span class="o">*</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">*</span><span class="p">(</span><span class="n">xi</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">S2</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S1</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">B</span><span class="p">)</span><span class="o">*</span><span class="n">cosvarphi</span><span class="p">)</span>
        <span class="n">ct12</span><span class="o">=</span><span class="p">(</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S1</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">S1</span><span class="o">*</span><span class="n">S2</span><span class="p">)</span>
        <span class="n">t4</span><span class="o">=</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">ct1</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">ct2</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">ct12</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span><span class="mf">2.</span><span class="o">*</span><span class="n">ct1</span><span class="o">*</span><span class="n">ct2</span><span class="o">*</span><span class="n">ct12</span><span class="p">))</span><span class="o">**.</span><span class="mi">5</span>        
        <span class="n">der</span><span class="o">=</span><span class="n">sign</span><span class="o">*</span><span class="n">t1</span><span class="o">*</span><span class="n">t2</span><span class="o">*</span><span class="n">t3</span><span class="o">*</span><span class="n">t4</span>

    <span class="k">else</span><span class="p">:</span>
        
        <span class="c"># Compute dS/dt</span>
        <span class="n">t1</span><span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mf">3.</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">q</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span><span class="n">S1</span><span class="o">*</span><span class="n">S2</span><span class="o">*</span><span class="n">eta</span><span class="o">**</span><span class="mi">6</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">9</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">q</span><span class="o">*</span><span class="n">S</span><span class="o">*</span><span class="n">L</span><span class="o">**</span><span class="mi">5</span><span class="p">)</span>
        <span class="n">t2</span><span class="o">=</span> <span class="mf">1.</span><span class="o">-</span><span class="p">((</span><span class="n">eta</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">xi</span><span class="p">)</span><span class="o">/</span><span class="n">L</span><span class="p">)</span>
        <span class="c">#It&#39;s faster if you don&#39;t call [parametric_angles] here. Equivalent to </span>
            <span class="c">#theta1,theta2,deltaphi,theta12 = parametric_angles(S,J,xi,q,S1,S2,r)    </span>
            <span class="c">#der=sign*t1*t2*np.sin(theta1)*np.sin(theta2)*np.sin(deltaphi)</span>
        <span class="n">ct1</span><span class="o">=</span> <span class="p">(</span> <span class="p">((</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="n">L</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">q</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">xi</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span> <span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">S1</span><span class="p">)</span>
        <span class="n">ct2</span><span class="o">=</span> <span class="p">(</span> <span class="p">((</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">q</span><span class="o">/</span><span class="n">L</span><span class="p">))</span> <span class="o">+</span> <span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">q</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">xi</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span> <span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">S2</span><span class="p">)</span>
        <span class="n">ct12</span><span class="o">=</span><span class="p">(</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S1</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">S1</span><span class="o">*</span><span class="n">S2</span><span class="p">)</span>
        <span class="n">t3</span><span class="o">=</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">ct1</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">ct2</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">ct12</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span><span class="mf">2.</span><span class="o">*</span><span class="n">ct1</span><span class="o">*</span><span class="n">ct2</span><span class="o">*</span><span class="n">ct12</span><span class="p">))</span><span class="o">**.</span><span class="mi">5</span> <span class="c"># I know abs is dirty, but does the job</span>
        <span class="n">der</span><span class="o">=</span><span class="n">sign</span><span class="o">*</span><span class="n">t1</span><span class="o">*</span><span class="n">t2</span><span class="o">*</span><span class="n">t3</span>
        
    <span class="k">return</span> <span class="n">der</span>
    
    
<span class="k">def</span> <span class="nf">dtdS</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">sign</span><span class="o">=</span><span class="mf">1.</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Auxiliary function dt/dS=(dS/dt)^-1. See `precession.dSdt`.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        dtdS=precession.dtdS(S,xi,J,q,S1,S2,r,sign=1.)</span>
<span class="sd">    </span>
<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `S`: magnitude of the total spin.</span>
<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `J`: magnitude of the total angular momentum.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `r`: binary separation.</span>
<span class="sd">    - `sign`: if 1 return angle in [0,pi], if -1 return angle in [-pi,0].</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `dtdS`: inverse of the precessional-cycle speed.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">return</span> <span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">dSdt</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">sign</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">t_of_S</span><span class="p">(</span> <span class="n">S_initial</span><span class="p">,</span><span class="n">S_final</span> <span class="p">,</span><span class="n">Sb_min</span><span class="p">,</span><span class="n">Sb_max</span> <span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">,</span> <span class="n">t_initial</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">sign</span><span class="o">=</span><span class="mf">1.</span> <span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Integrate `precession.dSdt` to find t (time) as a function of S (magnitude</span>
<span class="sd">    of the total spin). Since dS/dt depends on S and not on t, finding t(S) only</span>
<span class="sd">    requires a numnerical integration; S(t) is provided in `precession.t_of_S`.</span>
<span class="sd">    Sb_min and Sb_max are passed to this function (and not computed within it)</span>
<span class="sd">    for computational efficiency. This function can only integrate over half</span>
<span class="sd">    precession period (i.e. from Sb_min to Sb_max at most). If you want t(S)</span>
<span class="sd">    over more precession periods you should stich different solutions together,</span>
<span class="sd">    consistently with the argument sign (in particular, flip sign every half</span>
<span class="sd">    period).</span>

<span class="sd">    **Call:**</span>

<span class="sd">        t=precession.t_of_S(S_initial,S_final,Sb_min,Sb_max,xi,J,q,S1,S2,r,t_initial=0,sign=1.)</span>
<span class="sd">    </span>
<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `S_initial`: lower edge of the integration domain.</span>
<span class="sd">    - `S_final`: upper edge of the integration domain.</span>
<span class="sd">    - `Sb_min`: minimum value of S from geometrical constraints. This is S- in our papers.</span>
<span class="sd">    - `Sb_max`: maximum value of S from geometrical constraints. This is S+ in our papers.</span>
<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `J`: magnitude of the total angular momentum.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `r`: binary separation.</span>
<span class="sd">    - `t_initial`: intial integration time.</span>
<span class="sd">    - `sign`: if 1 return angle in [0,pi], if -1 return angle in [-pi,0].</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `t`: time (in total mass units).</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">global</span> <span class="n">flags_q1</span>
    <span class="k">if</span> <span class="n">q</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">flags_q1</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">==</span><span class="bp">False</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;[t_of_S] Warning q=1: input here is cos(varphi) not S; now computing t( cos(varphi) )&quot;</span>
            <span class="n">flags_q1</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">=</span><span class="bp">True</span>
            
        <span class="n">L</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">xi</span><span class="o">*</span><span class="n">L</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">S_min</span><span class="p">,</span><span class="n">S_max</span><span class="o">=</span><span class="n">St_limits</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">S</span><span class="o">-</span><span class="n">S_min</span><span class="p">)</span><span class="o">&lt;</span><span class="mf">1e-8</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">S</span><span class="o">-</span><span class="n">S_max</span><span class="p">)</span><span class="o">&lt;</span><span class="mf">1e-8</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;[t_of_S] Warning: you are at resonance, varphi is ill defined here.&quot;</span>
            <span class="k">return</span> <span class="mf">0.</span>
        <span class="k">elif</span> <span class="nb">min</span><span class="p">(</span><span class="n">S_initial</span><span class="p">,</span><span class="n">S_final</span><span class="p">)</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="nb">max</span><span class="p">(</span><span class="n">S_initial</span><span class="p">,</span><span class="n">S_final</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">False</span><span class="p">,</span> <span class="s">&quot;[t_of_S] Error. You&#39;re trying to integrate over more than one (half)period&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">integrate</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="n">dtdS</span><span class="p">,</span> <span class="n">S_initial</span><span class="p">,</span> <span class="n">S_final</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">sign</span><span class="p">),</span><span class="n">full_output</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">t_initial</span> <span class="o">+</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Sb_min</span><span class="o">-</span><span class="n">Sb_max</span><span class="p">)</span><span class="o">&lt;</span><span class="mf">1e-8</span><span class="p">:</span> <span class="c"># This happens when [Sb_limits] fails in bracketing of the solutions. In practice, this is a resonant binary.</span>
        <span class="k">return</span> <span class="mf">0.</span>
    <span class="k">elif</span> <span class="nb">min</span><span class="p">(</span><span class="n">S_initial</span><span class="p">,</span><span class="n">S_final</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">Sb_min</span> <span class="ow">or</span> <span class="nb">max</span><span class="p">(</span><span class="n">S_initial</span><span class="p">,</span><span class="n">S_final</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">Sb_max</span><span class="p">:</span>
        <span class="k">assert</span> <span class="bp">False</span><span class="p">,</span> <span class="s">&quot;[t_of_S] Error. You&#39;re trying to integrate over more than one (half)period&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">res</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">integrate</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="n">dtdS</span><span class="p">,</span> <span class="n">S_initial</span><span class="p">,</span> <span class="n">S_final</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">sign</span><span class="p">),</span><span class="n">full_output</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>               
        <span class="k">return</span> <span class="n">t_initial</span> <span class="o">+</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    
<span class="k">def</span> <span class="nf">S_of_t</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">Sb_min</span><span class="p">,</span><span class="n">Sb_max</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Integrate `precession.dSdt` to find S (time) as a function of t (magnitude</span>
<span class="sd">    of the total spin). In practice, this is done by inverting </span>
<span class="sd">    `precession.t_of_S`. Sb_min and Sb_max are passed to this function (and not</span>
<span class="sd">    computed within it) for computational efficiency. This function can only</span>
<span class="sd">    integrate over half precession period (i.e. from 0 to tau/2 at most). If you</span>
<span class="sd">    want S(t) over more precession periods you should stich different solutions</span>
<span class="sd">    together, consistently with the argument sign (in particular, flip sign</span>
<span class="sd">    every half period).</span>

<span class="sd">    **Call:**</span>

<span class="sd">        S=precession.S_of_t(t,Sb_min,Sb_max,xi,J,q,S1,S2,r,t_initial=0,sign=1.)</span>
<span class="sd">    </span>
<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `t`: time (in total mass units).</span>
<span class="sd">    - `S_final`: upper edge of the integration domain.</span>
<span class="sd">    - `Sb_min`: minimum value of S from geometrical constraints. This is S- in our papers.</span>
<span class="sd">    - `Sb_max`: maximum value of S from geometrical constraints. This is S+ in our papers.</span>
<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `J`: magnitude of the total angular momentum.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `r`: binary separation.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `S`: magnitude of the total spin.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">tau</span><span class="o">=</span><span class="n">precession_period</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>

    <span class="k">global</span> <span class="n">flags_q1</span>
    <span class="k">if</span> <span class="n">q</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">flags_q1</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">==</span><span class="bp">False</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;[S_of_t] Warning q=1: output here is cos(varphi) not S; now computing cos(varphi)(t) )&quot;</span>
            <span class="n">flags_q1</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">=</span><span class="bp">True</span>
            
        <span class="n">L</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">xi</span><span class="o">*</span><span class="n">L</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">S_min</span><span class="p">,</span><span class="n">S_max</span><span class="o">=</span><span class="n">St_limits</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">S</span><span class="o">-</span><span class="n">S_min</span><span class="p">)</span><span class="o">&lt;</span><span class="mf">1e-8</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">S</span><span class="o">-</span><span class="n">S_max</span><span class="p">)</span><span class="o">&lt;</span><span class="mf">1e-8</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;[S_of_t] Warning: you are at resonance, varphi is ill defined here.&quot;</span>
            <span class="k">return</span> <span class="mf">0.</span>
        <span class="k">elif</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">t</span> <span class="o">&gt;</span> <span class="n">tau</span><span class="o">/</span><span class="mf">2.</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">False</span><span class="p">,</span> <span class="s">&quot;[S_of_t] Error. You&#39;re trying to integrate over more than one (half)period&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">S</span><span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="k">lambda</span> <span class="n">S</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span> <span class="n">sp</span><span class="o">.</span><span class="n">integrate</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="n">dtdS</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">))[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="n">t</span> <span class="p">,</span> <span class="n">Sb_min</span><span class="p">,</span> <span class="n">Sb_max</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">S</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Sb_min</span><span class="o">-</span><span class="n">Sb_max</span><span class="p">)</span><span class="o">&lt;</span><span class="mf">1e-8</span><span class="p">:</span> <span class="c"># This happens when [Sb_limits] fails in bracketing of the solutions. In practice, this is a resonant binary.</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">Sb_min</span><span class="p">,</span><span class="n">Sb_min</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">t</span> <span class="o">&gt;</span> <span class="n">tau</span><span class="o">/</span><span class="mf">2.</span><span class="p">:</span>
        <span class="k">assert</span> <span class="bp">False</span><span class="p">,</span> <span class="s">&quot;[S_of_t] Error. You&#39;re trying to integrate over more than one (half)period&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">S</span><span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="k">lambda</span> <span class="n">S</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span> <span class="n">sp</span><span class="o">.</span><span class="n">integrate</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="n">dtdS</span><span class="p">,</span> <span class="n">Sb_min</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">))[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="n">t</span> <span class="p">,</span> <span class="n">Sb_min</span><span class="p">,</span> <span class="n">Sb_max</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">S</span>


<span class="k">def</span> <span class="nf">precession_period</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">):</span>
    
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Find the period of S, i.e. the precessional timescale. This is</span>
<span class="sd">    `precession.t_of_S` integrated from Sb_min to Sb_max times 2.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        tau=precession.precession_period(xi,J,q,S1,S2,r)</span>
<span class="sd">    </span>
<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `J`: magnitude of the total angular momentum.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `r`: binary separation.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `tau`: precessional period (in total mass units).</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="k">if</span> <span class="n">q</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="c"># If q=1, the limits must be specified in cos(varphi)</span>
       <span class="n">Sb_min</span><span class="o">=-</span><span class="mi">1</span>
       <span class="n">Sb_max</span><span class="o">=</span><span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Sb_min</span><span class="p">,</span><span class="n">Sb_max</span><span class="o">=</span><span class="n">Sb_limits</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
    
    <span class="n">halfperiod</span> <span class="o">=</span> <span class="n">t_of_S</span><span class="p">(</span><span class="n">Sb_min</span><span class="p">,</span><span class="n">Sb_max</span><span class="p">,</span><span class="n">Sb_min</span><span class="p">,</span><span class="n">Sb_max</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
    <span class="c">#abs because here you don&#39;t care about the &lt;sign&gt; issue in dS/dt here</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">halfperiod</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">OmegazdtdS</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">sign</span><span class="o">=</span><span class="mf">1.</span><span class="p">):</span>
    
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Auxiliary function Omega_z * dt/dS. See `precession.Omegaz` and `precession.dSdt`.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        OmegadtdS=precession.OmegazdtdS(S,xi,J,q,S1,S2,r,sign=1.):</span>
<span class="sd">    </span>
<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `S`: magnitude of the total spin.</span>
<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `J`: magnitude of the total angular momentum.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `r`: binary separation.</span>
<span class="sd">    - `sign`: if 1 return angle in [0,pi], if -1 return angle in [-pi,0].</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `OmegadtdS`: Omega_z * dt/dS.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">global</span> <span class="n">flags_q1</span>
    <span class="k">if</span> <span class="n">q</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">flags_q1</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="o">==</span><span class="bp">False</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;[OmegazdtdS] Warning q=1: input here is cos(varphi), not S; now computing Omegaz * dt / d(cos(varphi))&quot;</span>
            <span class="n">flags_q1</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="o">=</span><span class="bp">True</span>
        <span class="n">cosvarphi</span><span class="o">=</span><span class="n">S</span> <span class="c"># The input variable is actually cos(varphi)</span>
        <span class="n">L</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
        <span class="n">S</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">xi</span><span class="o">*</span><span class="n">L</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Omegaz</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dSdt</span><span class="p">(</span><span class="n">cosvarphi</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">sign</span><span class="p">))</span>
    
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Omegaz</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dSdt</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">sign</span><span class="p">))</span> 


<span class="k">def</span> <span class="nf">alpha_of_S</span><span class="p">(</span> <span class="n">S_initial</span><span class="p">,</span><span class="n">S_final</span> <span class="p">,</span><span class="n">Sb_min</span><span class="p">,</span><span class="n">Sb_max</span> <span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">,</span> <span class="n">alpha_initial</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">sign</span><span class="o">=</span><span class="mf">1.</span><span class="p">):</span>
    
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Integrate `precession.Omegaz&#39; to find the precession angle spanned by L</span>
<span class="sd">    about J, phiL, as a function of S. Sb_min and Sb_max are passed to this</span>
<span class="sd">    function (and not computed in it) to speed things up. This function can only</span>
<span class="sd">    integrate over half precession period (i.e. from Sb_min to Sb_max at most).</span>
<span class="sd">    If you want phiL(S) over more precession periods you should stich different</span>
<span class="sd">    solutions together, consistently with the argument sign (in particular, flip</span>
<span class="sd">    sign every half period).</span>

<span class="sd">    **Call:**</span>

<span class="sd">        phiL=precession.alpha_of_S(S_initial,S_final,Sb_min,Sb_max,xi,J,q,S1,S2,r,alpha_initial=0,sign=1.):</span>
<span class="sd">    </span>
<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `S_initial`: lower edge of the integration domain.</span>
<span class="sd">    - `S_final`: upper edge of the integration domain.</span>
<span class="sd">    - `Sb_min`: minimum value of S from geometrical constraints. This is S- in our papers.</span>
<span class="sd">    - `Sb_max`: maximum value of S from geometrical constraints. This is S+ in our papers.</span>
<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `J`: magnitude of the total angular momentum.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `r`: binary separation.</span>
<span class="sd">    - `alpha_initial`: initial integration angle.</span>
<span class="sd">    - `sign`: if 1 return angle in [0,pi], if -1 return angle in [-pi,0].</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `phiL`: azimuthal angle spanned by L about J.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">global</span> <span class="n">flags_q1</span>
    <span class="k">if</span> <span class="n">q</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">flags_q1</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="o">==</span><span class="bp">False</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;[alpha_of_S] Warning q=1: input here is cos(varphi), not S; now computing alpha(cosvarphi)&quot;</span>
            <span class="n">flags_q1</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="o">=</span><span class="bp">True</span>
        
        <span class="n">L</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">xi</span><span class="o">*</span><span class="n">L</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">S_min</span><span class="p">,</span><span class="n">S_max</span><span class="o">=</span><span class="n">St_limits</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">S</span><span class="o">-</span><span class="n">S_min</span><span class="p">)</span><span class="o">&lt;</span><span class="mf">1e-8</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">S</span><span class="o">-</span><span class="n">S_max</span><span class="p">)</span><span class="o">&lt;</span><span class="mf">1e-8</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;[alpha_of_S] Warning: you are at resonance, varphi is ill defined here.&quot;</span>
            <span class="k">return</span> <span class="mf">0.</span>
        <span class="k">elif</span> <span class="nb">min</span><span class="p">(</span><span class="n">S_initial</span><span class="p">,</span><span class="n">S_final</span><span class="p">)</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="nb">max</span><span class="p">(</span><span class="n">S_initial</span><span class="p">,</span><span class="n">S_final</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">False</span><span class="p">,</span> <span class="s">&quot;[alpha_of_S] Error. You&#39;re trying to integrate over more than one (half)period&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># If q=1, S is constant and therefore Omegaz is also constant. It can be taken out of the integral.</span>
            <span class="n">deltat</span><span class="o">=</span><span class="n">t_of_S</span><span class="p">(</span><span class="n">S_initial</span><span class="p">,</span><span class="n">S_final</span><span class="p">,</span><span class="n">Sb_min</span><span class="p">,</span><span class="n">Sb_max</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">alpha_initial</span> <span class="o">+</span> <span class="n">Omegaz</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span> <span class="o">*</span><span class="n">deltat</span>            
    
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Sb_min</span><span class="o">-</span><span class="n">Sb_max</span><span class="p">)</span><span class="o">&lt;</span><span class="mf">1e-8</span><span class="p">:</span> <span class="c"># This typically happen when [Sb_limits] fails in bracketing of the solutions. In practice, this is a resonant binary.</span>
        <span class="k">return</span> <span class="mf">0.</span>
    <span class="k">elif</span> <span class="nb">min</span><span class="p">(</span><span class="n">S_initial</span><span class="p">,</span><span class="n">S_final</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">Sb_min</span> <span class="ow">or</span> <span class="nb">max</span><span class="p">(</span><span class="n">S_initial</span><span class="p">,</span><span class="n">S_final</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">Sb_max</span><span class="p">:</span>
        <span class="k">assert</span> <span class="bp">False</span><span class="p">,</span> <span class="s">&quot;[alpha_of_S] Error. You&#39;re trying to integrate over more than one (half)period&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c"># Actual integration</span>
        <span class="n">res</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">integrate</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="n">OmegazdtdS</span><span class="p">,</span> <span class="n">S_initial</span><span class="p">,</span> <span class="n">S_final</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">sign</span><span class="p">),</span><span class="n">full_output</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>               
        <span class="k">return</span> <span class="n">alpha_initial</span> <span class="o">+</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">alphaz</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Angle spanned by L about J in a single precession cycle. This is</span>
<span class="sd">    `precession.alpha_of_S` integrated from Sb_min to Sb_max times 2.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        alpha=precession.alphaz(xi,J,q,S1,S2,r)</span>
<span class="sd">    </span>
<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `J`: magnitude of the total angular momentum.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `r`: binary separation.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `alpha`: azimuthal angle spanned by L about J in an entire precession cycle.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="n">q</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="c"># If q=1, the limits must be specified in cos(varphi)</span>
        <span class="n">Sb_min</span><span class="o">=-</span><span class="mi">1</span>
        <span class="n">Sb_max</span><span class="o">=</span><span class="mi">1</span>
        <span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="n">alpha_of_S</span><span class="p">(</span><span class="n">Sb_min</span><span class="p">,</span><span class="n">Sb_max</span><span class="p">,</span><span class="n">Sb_min</span><span class="p">,</span><span class="n">Sb_max</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span> 
        
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Sb_min</span><span class="p">,</span><span class="n">Sb_max</span><span class="o">=</span><span class="n">Sb_limits</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Sb_min</span><span class="o">-</span><span class="n">Sb_max</span><span class="p">)</span><span class="o">&lt;</span><span class="mf">1e-8</span><span class="p">:</span> <span class="c"># This typically happen when [Sb_limits] fails in bracketing of the solutions. In practice, this is a resonant binary.</span>
            <span class="k">return</span> <span class="mf">0.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">integrate</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="n">OmegazdtdS</span><span class="p">,</span> <span class="n">Sb_min</span><span class="p">,</span> <span class="n">Sb_max</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">),</span> <span class="n">full_output</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">samplingS</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">):</span>
    
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Select a value of S weighted with |dt/dS|. Sampling implemented using the</span>
<span class="sd">    cumulative distribution:</span>
<span class="sd">    </span>
<span class="sd">    1. select a random number epsilon in [0,1];</span>
<span class="sd">    2. find the value of S at which the cumulative probability distribution is</span>
<span class="sd">    equal to epsilon.</span>

<span class="sd">    The cumulative-distribution method is particualry suitable because the</span>
<span class="sd">    probability distribution function |dt/dS| diverges at the extrema Sb_min and</span>
<span class="sd">    Sb_max (and is troubling to apply a hit-or-miss approach).</span>

<span class="sd">    **Call:**</span>

<span class="sd">        S=precession.samplingS(xi,J,q,S1,S2,r)</span>
<span class="sd">    </span>
<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `J`: magnitude of the total angular momentum.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `r`: binary separation.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `S`: magnitude of the total spin.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">global</span> <span class="n">flags_q1</span>
    <span class="k">if</span> <span class="n">q</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">flags_q1</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="o">==</span><span class="bp">False</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;[samplingS] Warning q=1: sampling is cos(varphi), not S&quot;</span>
            <span class="n">flags_q1</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="o">=</span><span class="bp">True</span>
            
        <span class="c"># If q=1, the limits must be specified in cos(varphi)</span>
        <span class="n">tol</span><span class="o">=</span><span class="mf">1e-10</span> <span class="c"># Don&#39;t go too close to the actual limits</span>
        <span class="n">Sb_min</span><span class="o">=-</span><span class="mf">1.</span><span class="o">+</span><span class="n">tol</span>
        <span class="n">Sb_max</span><span class="o">=</span><span class="mf">1.</span><span class="o">-</span><span class="n">tol</span>
        
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Sb_min</span><span class="p">,</span><span class="n">Sb_max</span><span class="o">=</span><span class="n">Sb_limits</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Sb_min</span><span class="o">-</span><span class="n">Sb_max</span><span class="p">)</span><span class="o">&lt;</span><span class="mf">1e-8</span><span class="p">:</span> <span class="c"># This typically happen when [Sb_limits] fails in bracketing of the solutions. In practice, this is a resonant binary.</span>
        <span class="n">S_sol</span><span class="o">=</span><span class="p">(</span><span class="n">Sb_min</span><span class="o">+</span><span class="n">Sb_max</span><span class="p">)</span><span class="o">/</span><span class="mf">2.</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">halfperiod</span><span class="o">=</span><span class="n">t_of_S</span><span class="p">(</span><span class="n">Sb_min</span><span class="p">,</span><span class="n">Sb_max</span><span class="p">,</span><span class="n">Sb_min</span><span class="p">,</span><span class="n">Sb_max</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
        
        <span class="n">eps</span><span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>    
        
        <span class="n">S_sol</span><span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="k">lambda</span> <span class="n">S</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">t_of_S</span><span class="p">(</span><span class="n">Sb_min</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">Sb_min</span><span class="p">,</span><span class="n">Sb_max</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span> <span class="o">/</span> <span class="n">halfperiod</span><span class="p">)</span> <span class="o">-</span> <span class="n">eps</span><span class="p">,</span> <span class="n">Sb_min</span><span class="p">,</span> <span class="n">Sb_max</span><span class="p">)</span> <span class="c"># The brentq algorithm works very well with a monotonic function like the cumulative distribution</span>

    <span class="k">return</span> <span class="n">S_sol</span>            




<span class="c">#################################</span>
<span class="c"># PRECESSION-AVERAGED INSPIRAL ##</span>
<span class="c">#################################</span>

<span class="k">def</span> <span class="nf">St_limits_comp</span><span class="p">(</span><span class="n">kappa</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">u</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Auxiliary function, see `precession.St_limits`.</span>
<span class="sd">    </span>
<span class="sd">    **Call:**</span>

<span class="sd">        St_min,St_max=precession.St_limits_comp(kappa,q,S1,S2,u)</span>

<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `kappa`: rescaling of the total angular momentum to compactify the inspiral domain.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `u`: rescaling of the orbital angular momentum to compactify the inspiral domain.</span>

<span class="sd">    **Returns:**</span>
<span class="sd">    </span>
<span class="sd">    - `St_min`: minimum value of S from geometrical constraints. This is S_min in our papers.</span>
<span class="sd">    - `St_max`: maximum value of S from geometrical constraints. This is S_max in our papers.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="n">u</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">St_min</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">kappa</span><span class="p">))</span>
        <span class="n">St_max</span><span class="o">=</span><span class="n">S1</span><span class="o">+</span><span class="n">S2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">St_min</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span> <span class="p">((</span><span class="mf">1.</span><span class="o">+</span><span class="mi">4</span><span class="o">*</span><span class="n">kappa</span><span class="o">*</span><span class="n">u</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">u</span><span class="p">)))</span>
        <span class="n">St_max</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="n">S1</span><span class="o">+</span><span class="n">S2</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span> <span class="p">((</span><span class="mf">1.</span><span class="o">+</span><span class="mi">4</span><span class="o">*</span><span class="n">kappa</span><span class="o">*</span><span class="n">u</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">u</span><span class="p">)))</span>

    <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">St_min</span><span class="p">),</span><span class="nb">float</span><span class="p">(</span><span class="n">St_max</span><span class="p">)</span>
    
    
<span class="k">def</span> <span class="nf">xi_plus_comp</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">kappa</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">u</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Auxiliary function, see `precession.xi_plus`.</span>
<span class="sd">    </span>
<span class="sd">    **Call:**</span>

<span class="sd">        xi=precession.xi_plus_comp(S,kappa,q,S1,S2,u)</span>

<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `S`: magnitude of the total spin.</span>
<span class="sd">    - `kappa`: rescaling of the total angular momentum to compactify the inspiral domain.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `u`: rescaling of the orbital angular momentum to compactify the inspiral domain.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">t1</span><span class="o">=</span> <span class="n">kappa</span><span class="o">-</span><span class="n">u</span><span class="o">*</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">t2</span><span class="o">=</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">S1</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">q</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">S</span> <span class="ow">in</span> <span class="n">St_limits_comp</span><span class="p">(</span><span class="n">kappa</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">u</span><span class="p">):</span> <span class="c">#if you&#39;re on the limits, the second bit must be zero</span>
        <span class="n">t3</span><span class="o">=</span><span class="n">t4</span><span class="o">=</span><span class="n">t5</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">t3</span><span class="o">=</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">q</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">kappa</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">u</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">S</span><span class="o">**</span><span class="mi">4</span><span class="o">+</span><span class="mf">2.</span><span class="o">*</span><span class="n">u</span><span class="o">*</span><span class="n">kappa</span><span class="o">*</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span>        
        <span class="n">t4</span><span class="o">=</span><span class="p">((</span><span class="n">S1</span><span class="o">+</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
        <span class="n">t5</span><span class="o">=</span><span class="p">(</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>    
    <span class="n">t6</span><span class="o">=</span> <span class="mf">2.</span><span class="o">*</span><span class="n">q</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">t1</span><span class="o">*</span><span class="n">t2</span> <span class="o">+</span> <span class="n">t3</span><span class="o">*</span><span class="n">t4</span><span class="o">*</span><span class="n">t5</span><span class="p">)</span><span class="o">/</span><span class="n">t6</span>
    
    
<span class="k">def</span> <span class="nf">xi_minus_comp</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">kappa</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">u</span><span class="p">):</span>
    
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Auxiliary function, see `precession.xi_minus`.</span>
<span class="sd">        </span>
<span class="sd">    **Call:**</span>

<span class="sd">        xi=precession.xi_minus_comp(S,kappa,q,S1,S2,u)</span>

<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `S`: magnitude of the total spin.</span>
<span class="sd">    - `kappa`: rescaling of the total angular momentum to compactify the inspiral domain.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `u`: rescaling of the orbital angular momentum to compactify the inspiral domain.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="n">t1</span><span class="o">=</span> <span class="n">kappa</span><span class="o">-</span><span class="n">u</span><span class="o">*</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">t2</span><span class="o">=</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">S1</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">q</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">S</span> <span class="ow">in</span> <span class="n">St_limits_comp</span><span class="p">(</span><span class="n">kappa</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">u</span><span class="p">):</span> <span class="c">#if you&#39;re on the limits, the second bit must be zero</span>
        <span class="n">t3</span><span class="o">=</span><span class="n">t4</span><span class="o">=</span><span class="n">t5</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">t3</span><span class="o">=</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">q</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">kappa</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">u</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">S</span><span class="o">**</span><span class="mi">4</span><span class="o">+</span><span class="mf">2.</span><span class="o">*</span><span class="n">u</span><span class="o">*</span><span class="n">kappa</span><span class="o">*</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span>
        <span class="n">t4</span><span class="o">=</span><span class="p">((</span><span class="n">S1</span><span class="o">+</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
        <span class="n">t5</span><span class="o">=</span><span class="p">(</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>    
    <span class="n">t6</span><span class="o">=</span> <span class="mf">2.</span><span class="o">*</span><span class="n">q</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">t1</span><span class="o">*</span><span class="n">t2</span> <span class="o">-</span> <span class="n">t3</span><span class="o">*</span><span class="n">t4</span><span class="o">*</span><span class="n">t5</span><span class="p">)</span><span class="o">/</span><span class="n">t6</span>
   
   
<span class="k">def</span> <span class="nf">Sb_limits_comp</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">kappa</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">u</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Auxiliary function, see `precession.Sb_limits`.</span>
<span class="sd">        </span>
<span class="sd">    **Call:**</span>

<span class="sd">        Sb_min,Sb_max=precession.Sb_limits_comp(xi,kappa,q,S1,S2,u)</span>

<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `kappa`: rescaling of the total angular momentum to compactify the inspiral domain.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `u`: rescaling of the orbital angular momentum to compactify the inspiral domain.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `Sb_min`: minimum value of S from geometrical constraints. This is S- in our papers.</span>
<span class="sd">    - `Sb_max`: maximum value of S from geometrical constraints. This is S+ in our papers.   </span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">global</span> <span class="n">flags_q1</span>
    <span class="k">if</span> <span class="n">q</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">u</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">flags_q1</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span><span class="o">==</span><span class="bp">False</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&quot;[Sb_limits_comp] Warning q=1,u=0: input for kappa means S&quot;</span>
                <span class="n">flags_q1</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span><span class="o">=</span><span class="bp">True</span>
            <span class="n">Sb_both</span><span class="o">=</span><span class="n">kappa</span>
        <span class="k">else</span><span class="p">:</span>
           <span class="n">Sb_both</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">kappa</span><span class="o">/</span><span class="n">u</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">xi</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">u</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Sb_both</span><span class="p">,</span><span class="n">Sb_both</span>

    <span class="n">St_min</span><span class="p">,</span><span class="n">St_max</span><span class="o">=</span><span class="n">St_limits_comp</span><span class="p">(</span><span class="n">kappa</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">u</span><span class="p">)</span>
    <span class="n">xi_low</span><span class="o">=</span><span class="n">xi_minus_comp</span><span class="p">(</span><span class="n">St_min</span><span class="p">,</span><span class="n">kappa</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">u</span><span class="p">)</span> 
    <span class="n">xi_up</span><span class="o">=</span><span class="n">xi_minus_comp</span><span class="p">(</span><span class="n">St_max</span><span class="p">,</span><span class="n">kappa</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">u</span><span class="p">)</span>
 
    <span class="c">#Debug option: print the parameter-space region of the initial guess</span>
    <span class="n">whereareyou</span><span class="o">=</span><span class="bp">False</span>
 
    <span class="c"># Both roots on xi_plus. Split the interval first</span>
    <span class="k">if</span> <span class="n">xi</span> <span class="o">&gt;</span> <span class="n">xi_low</span> <span class="ow">and</span> <span class="n">xi</span> <span class="o">&gt;</span> <span class="n">xi_up</span><span class="p">:</span>    

        <span class="k">if</span> <span class="n">whereareyou</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;[Sb_limits_comp] Both roots on xi_plus&quot;</span>

        <span class="n">resmax</span><span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">fminbound</span><span class="p">(</span><span class="k">lambda</span> <span class="n">S</span><span class="p">:</span> <span class="o">-</span><span class="mf">1.</span><span class="o">*</span><span class="n">xi_plus_comp</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">kappa</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">u</span><span class="p">),</span> <span class="n">St_min</span><span class="p">,</span> <span class="n">St_max</span><span class="p">,</span><span class="n">full_output</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">S_up</span><span class="o">=</span><span class="n">resmax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">xi_max</span><span class="o">=-</span><span class="mf">1.</span><span class="o">*</span><span class="n">resmax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">xi_max</span><span class="o">&lt;</span><span class="n">xi</span><span class="p">:</span> <span class="c">#Braket failed!</span>
            <span class="k">print</span> <span class="s">&quot;[Sb_limits_comp] Braket failed on xi_plus at u=&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">+</span><span class="s">&quot;. Assume Sb_min=Sb_max&quot;</span>
            <span class="c">#print  xi_plus(S_up,J,q,S1,S2,r), xi</span>
            <span class="n">Sb_min</span><span class="o">=</span><span class="n">S_up</span>
            <span class="n">Sb_max</span><span class="o">=</span><span class="n">S_up</span>  
        <span class="k">else</span><span class="p">:</span> <span class="c">#Braket succeeded!</span>
                    
            <span class="n">Sb_min</span><span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="k">lambda</span> <span class="n">S</span><span class="p">:</span> <span class="n">xi_plus_comp</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">kappa</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">u</span><span class="p">)</span><span class="o">-</span><span class="n">xi</span><span class="p">,</span> <span class="n">St_min</span><span class="p">,</span> <span class="n">S_up</span><span class="p">)</span>
            <span class="n">Sb_max</span><span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="k">lambda</span> <span class="n">S</span><span class="p">:</span> <span class="n">xi_plus_comp</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">kappa</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">u</span><span class="p">)</span><span class="o">-</span><span class="n">xi</span><span class="p">,</span> <span class="n">S_up</span><span class="p">,</span> <span class="n">St_max</span><span class="p">)</span>

    <span class="c"># Both roots on xi_minus. Split the interval first</span>
    <span class="k">elif</span> <span class="n">xi</span> <span class="o">&lt;</span> <span class="n">xi_low</span> <span class="ow">and</span> <span class="n">xi</span> <span class="o">&lt;</span> <span class="n">xi_up</span><span class="p">:</span>    
        
        <span class="k">if</span> <span class="n">whereareyou</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;[Sb_limits_comp] Both roots on xi_minus&quot;</span>
            
        <span class="n">resmin</span><span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">fminbound</span><span class="p">(</span><span class="k">lambda</span> <span class="n">S</span><span class="p">:</span> <span class="n">xi_minus_comp</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">kappa</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">u</span><span class="p">),</span> <span class="n">St_min</span><span class="p">,</span> <span class="n">St_max</span><span class="p">,</span><span class="n">full_output</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">S_low</span><span class="o">=</span><span class="n">resmin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">xi_min</span><span class="o">=</span><span class="n">resmin</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                 
        <span class="k">if</span> <span class="n">xi_min</span><span class="o">&gt;</span><span class="n">xi</span><span class="p">:</span> <span class="c">#Braket failed! </span>
            <span class="k">print</span> <span class="s">&quot;[Sb_limits_comp] Braket failed on xi_minus at u=&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">+</span><span class="s">&quot;. Assume Sb_min=Sb_max&quot;</span>
            <span class="n">Sb_min</span><span class="o">=</span><span class="n">S_low</span>
            <span class="n">Sb_max</span><span class="o">=</span><span class="n">S_low</span>  
        <span class="k">else</span><span class="p">:</span> <span class="c">#Braket succeeded!</span>
            <span class="n">Sb_min</span><span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="k">lambda</span> <span class="n">S</span><span class="p">:</span> <span class="n">xi_minus_comp</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">kappa</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">u</span><span class="p">)</span><span class="o">-</span><span class="n">xi</span><span class="p">,</span> <span class="n">St_min</span><span class="p">,</span> <span class="n">S_low</span><span class="p">)</span>
            <span class="n">Sb_max</span><span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="k">lambda</span> <span class="n">S</span><span class="p">:</span> <span class="n">xi_minus_comp</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">kappa</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">u</span><span class="p">)</span><span class="o">-</span><span class="n">xi</span><span class="p">,</span> <span class="n">S_low</span><span class="p">,</span> <span class="n">St_max</span><span class="p">)</span>

    <span class="c"># One root on xi_plus and the other one on xi_plus. No additional maximization is neeeded</span>
    <span class="k">elif</span> <span class="n">xi</span> <span class="o">&gt;=</span> <span class="n">xi_low</span> <span class="ow">and</span> <span class="n">xi</span> <span class="o">&lt;=</span> <span class="n">xi_up</span><span class="p">:</span>    

        <span class="k">if</span> <span class="n">whereareyou</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;[Sb_limits_comp] Sb_min on xi_plus, Sb_max on xi_minus&quot;</span>

        <span class="n">Sb_min</span><span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="k">lambda</span> <span class="n">S</span><span class="p">:</span> <span class="n">xi_plus_comp</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">kappa</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">u</span><span class="p">)</span><span class="o">-</span><span class="n">xi</span><span class="p">,</span> <span class="n">St_min</span><span class="p">,</span> <span class="n">St_max</span><span class="p">)</span>
        <span class="n">Sb_max</span><span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="k">lambda</span> <span class="n">S</span><span class="p">:</span> <span class="n">xi_minus_comp</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">kappa</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">u</span><span class="p">)</span><span class="o">-</span><span class="n">xi</span><span class="p">,</span> <span class="n">St_min</span><span class="p">,</span> <span class="n">St_max</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">xi</span> <span class="o">&lt;=</span> <span class="n">xi_low</span> <span class="ow">and</span> <span class="n">xi</span> <span class="o">&gt;=</span> <span class="n">xi_up</span><span class="p">:</span>    
    
        <span class="k">if</span> <span class="n">whereareyou</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;[Sb_limits_comp] Sb_min on xi_minus, Sb_max on xi_plus&quot;</span>

        <span class="n">Sb_min</span><span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="k">lambda</span> <span class="n">S</span><span class="p">:</span> <span class="n">xi_minus_comp</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">kappa</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">u</span><span class="p">)</span><span class="o">-</span><span class="n">xi</span><span class="p">,</span> <span class="n">St_min</span><span class="p">,</span> <span class="n">St_max</span><span class="p">)</span>
        <span class="n">Sb_max</span><span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="k">lambda</span> <span class="n">S</span><span class="p">:</span> <span class="n">xi_plus_comp</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">kappa</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">u</span><span class="p">)</span><span class="o">-</span><span class="n">xi</span><span class="p">,</span> <span class="n">St_min</span><span class="p">,</span> <span class="n">St_max</span><span class="p">)</span>
                    
    <span class="k">else</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&quot;[Sb_limits_comp] Erorr in case selection&quot;</span>
        <span class="k">print</span> <span class="s">&quot;xi=&quot;</span><span class="p">,</span> <span class="n">xi</span>
        <span class="k">print</span> <span class="s">&quot;xi(stmin)=&quot;</span><span class="p">,</span> <span class="n">xi_low</span>
        <span class="k">print</span> <span class="s">&quot;xi(stmax)=&quot;</span><span class="p">,</span> <span class="n">xi_up</span>
        <span class="k">print</span> <span class="s">&quot;Stmin=&quot;</span><span class="p">,</span> <span class="n">St_min</span>
        <span class="k">print</span> <span class="s">&quot;Stmax&quot;</span><span class="p">,</span> <span class="n">St_max</span>
        <span class="k">print</span> <span class="s">&quot;kappa=&quot;</span><span class="p">,</span> <span class="n">kappa</span>
        <span class="k">print</span> <span class="s">&quot;u=&quot;</span><span class="p">,</span> <span class="n">u</span>
        <span class="k">assert</span> <span class="bp">False</span><span class="p">,</span> <span class="s">&quot;[Sb_limits_comp] Erorr in case selection&quot;</span>
        
    <span class="n">btol</span><span class="o">=</span><span class="mf">1e-8</span> <span class="c"># Never go to close to the actual limits, because everything blows up there</span>
    <span class="n">Sb_min</span><span class="o">+=</span><span class="n">btol</span>
    <span class="n">Sb_max</span><span class="o">-=</span><span class="n">btol</span>
    
    <span class="k">if</span> <span class="n">whereareyou</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&quot;[Sb_limits_comp] Results:&quot;</span><span class="p">,</span> <span class="n">Sb_min</span><span class="p">,</span><span class="n">Sb_max</span>
    
    
    <span class="k">if</span> <span class="n">Sb_min</span><span class="o">&gt;</span><span class="n">Sb_max</span><span class="p">:</span> <span class="c"># This may happen (numerically) if they&#39;re too close to each other. Assume they&#39;re the same.</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">Sb_min</span><span class="p">,</span><span class="n">Sb_max</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">Sb_min</span><span class="p">,</span><span class="n">Sb_max</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span> 
        <span class="k">return</span> <span class="n">Sb_min</span><span class="p">,</span> <span class="n">Sb_max</span>

      
<span class="k">def</span> <span class="nf">S3sines_comp</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">kappa</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">u</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Auxiliary function, see `precession.dkappadu`.</span>
<span class="sd">        </span>
<span class="sd">    **Call:**</span>

<span class="sd">        denominator=precession.S3sines_comp(S,xi,kappa,q,S1,S2,u)</span>

<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `S`: magnitude of the total spin.</span>
<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `kappa`: rescaling of the total angular momentum to compactify the inspiral domain.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `u`: rescaling of the orbital angular momentum to compactify the inspiral domain.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `denominator`: denominator in integrand `precession.dkappapu`.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">ct1</span><span class="o">=</span> <span class="p">(</span> <span class="n">kappa</span> <span class="o">-</span> <span class="n">u</span><span class="o">*</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span>  <span class="o">-</span> <span class="n">q</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">xi</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span> <span class="p">)</span><span class="o">/</span><span class="p">((</span><span class="mf">1.</span><span class="o">-</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">S1</span><span class="p">)</span>
    <span class="n">ct2</span><span class="o">=</span> <span class="n">q</span><span class="o">*</span><span class="p">(</span> <span class="o">-</span><span class="n">kappa</span> <span class="o">+</span> <span class="n">u</span><span class="o">*</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span>  <span class="o">+</span> <span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">xi</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span> <span class="p">)</span><span class="o">/</span><span class="p">((</span><span class="mf">1.</span><span class="o">-</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">S2</span><span class="p">)</span>
    <span class="n">ct12</span><span class="o">=</span><span class="p">(</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S1</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">S1</span><span class="o">*</span><span class="n">S2</span><span class="p">)</span>
    <span class="n">t3</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">ct1</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">ct2</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">ct12</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span><span class="mf">2.</span><span class="o">*</span><span class="n">ct1</span><span class="o">*</span><span class="n">ct2</span><span class="o">*</span><span class="n">ct12</span><span class="p">))</span><span class="o">**.</span><span class="mi">5</span><span class="p">,</span> <span class="mf">1e-20</span><span class="p">)</span> <span class="c"># I know abs is dirty, but does the job </span>
    <span class="k">if</span> <span class="n">t3</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="c"># prevent occasional crash</span>
        <span class="n">t3</span><span class="o">=</span><span class="mf">1e-20</span>
    <span class="k">return</span> <span class="n">S</span><span class="o">**</span><span class="mi">3</span><span class="o">/</span><span class="n">t3</span>


<span class="k">def</span> <span class="nf">Ssines_comp</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">kappa</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">u</span><span class="p">):</span>
    
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Auxiliary function, see `precession.dkappadu`.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        numerator=precession.Ssines_comp(S,xi,kappa,q,S1,S2,u)</span>

<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `S`: magnitude of the total spin.</span>
<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `kappa`: rescaling of the total angular momentum to compactify the inspiral domain.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `u`: rescaling of the orbital angular momentum to compactify the inspiral domain.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `numerator`: numerator in integrand `precession.dkappapu`.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="n">ct1</span><span class="o">=</span> <span class="p">(</span> <span class="n">kappa</span> <span class="o">-</span> <span class="n">u</span><span class="o">*</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span>  <span class="o">-</span> <span class="n">q</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">xi</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span> <span class="p">)</span><span class="o">/</span><span class="p">((</span><span class="mf">1.</span><span class="o">-</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">S1</span><span class="p">)</span>
    <span class="n">ct2</span><span class="o">=</span> <span class="n">q</span><span class="o">*</span><span class="p">(</span> <span class="o">-</span><span class="n">kappa</span> <span class="o">+</span> <span class="n">u</span><span class="o">*</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span>  <span class="o">+</span> <span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">xi</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span> <span class="p">)</span><span class="o">/</span><span class="p">((</span><span class="mf">1.</span><span class="o">-</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">S2</span><span class="p">)</span>
    <span class="n">ct12</span><span class="o">=</span><span class="p">(</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S1</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">S1</span><span class="o">*</span><span class="n">S2</span><span class="p">)</span>
    <span class="n">t3</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">ct1</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">ct2</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">ct12</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span><span class="mf">2.</span><span class="o">*</span><span class="n">ct1</span><span class="o">*</span><span class="n">ct2</span><span class="o">*</span><span class="n">ct12</span><span class="p">))</span><span class="o">**.</span><span class="mi">5</span><span class="p">,</span> <span class="mf">1e-20</span><span class="p">)</span> <span class="c"># I know abs is dirty, but does the job </span>
    <span class="k">return</span> <span class="n">S</span><span class="o">/</span><span class="n">t3</span>
    
    
<span class="k">def</span> <span class="nf">dkappadu</span><span class="p">(</span><span class="n">kappa</span><span class="p">,</span><span class="n">u</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">):</span>    
      
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Inspiral ODE to perform precession-averaged inspiral: dkappa/du = S^2_pre.</span>
<span class="sd">    We use variables kappa and u (rather than J and L, see `precession.dJdL`)</span>
<span class="sd">    because this formulation naturally allows for integration from infinitely</span>
<span class="sd">    large separations, i.e. u=0. This function is only the actual equation, not</span>
<span class="sd">    the ODE solver.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        dkappadu=precession.dkappadu(kappa,u,xi,q,S1,S2)</span>
<span class="sd">    </span>
<span class="sd">    **Parameters:**</span>

<span class="sd">    - `kappa`: rescaling of the total angular momentum to compactify the inspiral domain.</span>
<span class="sd">    - `u`: rescaling of the orbital angular momentum to compactify the inspiral domain.</span>
<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `dkappadu`: precession-averaged derivative of kappa with respect to u.</span>
<span class="sd">    &#39;&#39;&#39;</span>
  
    <span class="n">dkappadu_debug</span><span class="o">=</span><span class="bp">False</span> <span class="c">#Debug option</span>
    <span class="k">if</span> <span class="n">dkappadu_debug</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&quot;[dkappadu] ODE int: u=&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">+</span><span class="s">&quot;</span><span class="se">\t\t</span><span class="s">kappa=&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">kappa</span><span class="p">))</span>
    
    <span class="n">Sb_min</span><span class="p">,</span><span class="n">Sb_max</span> <span class="o">=</span> <span class="n">Sb_limits_comp</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">kappa</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">u</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Sb_min</span><span class="o">-</span><span class="n">Sb_max</span><span class="p">)</span><span class="o">&lt;</span><span class="mf">1e-8</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">dkappadu_debug</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;[dkappadu] Warning. Applyting analytical approximation. u=&quot;</span><span class="p">,</span><span class="n">u</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">Sb_min</span><span class="p">,</span><span class="n">Sb_max</span><span class="p">]))</span><span class="o">**</span><span class="mi">2</span>
    <span class="k">else</span><span class="p">:</span>      
        <span class="n">up</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">integrate</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="n">S3sines_comp</span><span class="p">,</span> <span class="n">Sb_min</span><span class="p">,</span> <span class="n">Sb_max</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">kappa</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">u</span><span class="p">),</span> <span class="n">full_output</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">down</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">integrate</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="n">Ssines_comp</span> <span class="p">,</span> <span class="n">Sb_min</span><span class="p">,</span> <span class="n">Sb_max</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">kappa</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">u</span><span class="p">),</span> <span class="n">full_output</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">up</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">down</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">dJdr</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Inspiral ODE describing the evolution of the magnitude of the total angular</span>
<span class="sd">    momentum vs. the separation r. This function is NOT used by the ODE solvers</span>
<span class="sd">    (see `precession.dkappadu`).</span>

<span class="sd">    **Call:**</span>

<span class="sd">        dJdr=precession.dJdr(J,r,xi,q,S1,S2)</span>
<span class="sd">    </span>
<span class="sd">    **Parameters:**</span>

<span class="sd">    - `J`: magnitude of the total angular momentum.</span>
<span class="sd">    - `r`: binary separation.</span>
<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `dJdr`: precession-averaged derivative of J with respect to r.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">L</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>    
    <span class="n">kappa</span><span class="o">=</span><span class="p">(</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">L</span><span class="p">)</span>
    <span class="n">u</span><span class="o">=</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">L</span><span class="p">)</span>
    <span class="n">S2pre</span><span class="o">=</span><span class="n">dkappadu</span><span class="p">(</span><span class="n">kappa</span><span class="p">,</span><span class="n">u</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">)</span>
    <span class="n">dJdL</span><span class="o">=</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">L</span><span class="o">*</span><span class="n">J</span><span class="p">))</span><span class="o">*</span><span class="p">(</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S2pre</span><span class="p">)</span>
    <span class="n">dLdr</span><span class="o">=</span><span class="n">L</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">r</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dJdL</span><span class="o">*</span><span class="n">dLdr</span>


<span class="k">def</span> <span class="nf">dJdL</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Inspiral ODE describing the evolution of the magnitude of the total angular</span>
<span class="sd">    momentum vs. the separation r. This function is NOT used by the ODE solvers</span>
<span class="sd">    (see `precession.dkappadu`).</span>

<span class="sd">    **Call:**</span>

<span class="sd">        dJdL=precession.dJdL(J,r,xi,q,S1,S2)</span>
<span class="sd">    </span>
<span class="sd">    **Parameters:**</span>

<span class="sd">    - `J`: magnitude of the total angular momentum.</span>
<span class="sd">    - `r`: binary separation.</span>
<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `dJdL`: precession-averaged derivative of J with respect to L.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">L</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>    
    <span class="n">kappa</span><span class="o">=</span><span class="p">(</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">L</span><span class="p">)</span>
    <span class="n">u</span><span class="o">=</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">L</span><span class="p">)</span>
    <span class="n">S2pre</span><span class="o">=</span><span class="n">dkappadu</span><span class="p">(</span><span class="n">kappa</span><span class="p">,</span><span class="n">u</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">)</span>
    <span class="n">dJdL</span><span class="o">=</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">L</span><span class="o">*</span><span class="n">J</span><span class="p">))</span><span class="o">*</span><span class="p">(</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S2pre</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dJdL</span>


<span class="k">def</span> <span class="nf">Jofr</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">J_initial</span><span class="p">,</span><span class="n">r_vals</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Single integration of the dJ/dL equation to perfom precession-averaged</span>
<span class="sd">    inspiral. Input/output are provided in J and r, but the internal integrator</span>
<span class="sd">    uses kappa and u (see `precession.dkappadu`). Integration is performed using</span>
<span class="sd">    scipy&#39;s `odeint`.</span>
<span class="sd">    </span>
<span class="sd">    This function integrates to/from FINITE separations only.</span>
<span class="sd">    </span>
<span class="sd">    It takes the desired output separations r_vals, and the intial condition for</span>
<span class="sd">    the total angular momentum J_initial. The latter must be consistent with the</span>
<span class="sd">    initial separation (i.e. r_vals[0]) and the value of xi; an error is raised</span>
<span class="sd">    in case of inconsistencies. It doesn&#39;t matter if you integrate from large to</span>
<span class="sd">    small separations of the other way round, as long as J_initial is consistent</span>
<span class="sd">    with r_vals[0]. It returns a vector with the values of J at each input</span>
<span class="sd">    separation, the first item being just the initial condition.</span>
<span class="sd">    </span>
<span class="sd">    We recommend to use this function through the wrapper `precession.evolve_J`</span>
<span class="sd">    provided.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        J_vals=precession.Jofr(xi,J_initial,r_vals,q,S1,S2)</span>
<span class="sd">    </span>
<span class="sd">    **Parameters:**</span>

<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `J_initial`: initial condition for numerical integration.</span>
<span class="sd">    - `r_vals`: binary separation (array).</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `J_vals`: magnitude of the total angular momentum (array).</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">L_vals</span><span class="o">=</span><span class="p">[</span> <span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">r_vals</span><span class="p">]</span>
    <span class="n">kappa_initial</span><span class="o">=</span> <span class="p">(</span><span class="n">J_initial</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="p">(</span><span class="n">L_vals</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">L_vals</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">u_vals</span><span class="o">=</span><span class="p">[</span> <span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">L</span><span class="p">)</span> <span class="k">for</span> <span class="n">L</span> <span class="ow">in</span> <span class="n">L_vals</span><span class="p">]</span>

    <span class="c"># Analytical solution for q=1. S is constant on the radiation-reaction time</span>
    <span class="k">if</span> <span class="n">q</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">L_initial</span><span class="o">=</span><span class="n">L_vals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">Ssq</span><span class="o">=</span><span class="n">J_initial</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L_initial</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">xi</span><span class="o">*</span><span class="n">L_initial</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">J_vals</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Ssq</span><span class="o">+</span><span class="p">((</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">xi</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">((</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span><span class="p">))</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">r_vals</span><span class="p">]</span>
    
    <span class="c"># Numerical integration</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c">#sing = [ M*((1.+q)**2*(S1+S2)/(q*M**2))**2 ,  M*((1.+q)**2*(S1-S2)/(q*M**2))**2 ] # Expected singularities. Not needed</span>
        <span class="c"># Increase h0 to prevent occasional slowing down of the integration</span>
        <span class="n">res</span> <span class="o">=</span><span class="n">integrate</span><span class="o">.</span><span class="n">odeint</span><span class="p">(</span><span class="n">dkappadu</span><span class="p">,</span> <span class="n">kappa_initial</span><span class="p">,</span> <span class="n">u_vals</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">),</span> <span class="n">mxstep</span><span class="o">=</span><span class="mi">50000</span><span class="p">,</span> <span class="n">full_output</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">printmessg</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="c">#,h0=0.001)#,tcrit=sing)</span>
        <span class="n">kappa_vals</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">res</span><span class="p">]</span>
        <span class="n">J_vals</span><span class="o">=</span> <span class="p">[</span> <span class="p">(</span><span class="n">k</span><span class="o">*</span><span class="mf">2.</span><span class="o">*</span><span class="n">L</span> <span class="o">+</span> <span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">L</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">kappa_vals</span><span class="p">,</span><span class="n">L_vals</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">J_vals</span>
    
    
<span class="k">def</span> <span class="nf">Jofr_checkpoint</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">J_initial</span><span class="p">,</span><span class="n">r_vals</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Auxiliary function, see `precession.evolve_J`.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        savename=precession.Jofr_checkpoint(xi,J_initial,r_vals,q,S1,S2)</span>
<span class="sd">    </span>
<span class="sd">    **Parameters:**</span>

<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `J_initial`: initial condition for numerical integration.</span>
<span class="sd">    - `r_vals`: binary separation (array).</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `savename`: checkpoint filename.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s">&quot;mkdir -p &quot;</span><span class="o">+</span><span class="n">storedir</span><span class="p">)</span> 
    <span class="n">savename</span><span class="o">=</span> <span class="n">storedir</span><span class="o">+</span><span class="s">&quot;/evJ_&quot;</span><span class="o">+</span><span class="s">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">J_initial</span><span class="p">,</span><span class="nb">max</span><span class="p">(</span><span class="n">r_vals</span><span class="p">),</span><span class="nb">min</span><span class="p">(</span><span class="n">r_vals</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">r_vals</span><span class="p">),</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">)])</span><span class="o">+</span><span class="s">&quot;.dat&quot;</span>
        
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">savename</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">&quot;[evolve_J] Transferring binary. Output:&quot;</span><span class="p">,</span> <span class="n">savename</span>
        <span class="n">outfilesave</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">savename</span><span class="p">,</span><span class="s">&quot;w&quot;</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
       
        <span class="n">J_vals</span><span class="o">=</span> <span class="n">Jofr</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">J_initial</span><span class="p">,</span><span class="n">r_vals</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">J_f</span><span class="p">,</span><span class="n">r_f</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">J_vals</span><span class="p">,</span><span class="n">r_vals</span><span class="p">):</span>        
            <span class="n">outfilesave</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">r_f</span><span class="p">)</span><span class="o">+</span><span class="s">&quot; &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">J_f</span><span class="p">)</span><span class="o">+</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
        <span class="n">outfilesave</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="c">#else:</span>
    <span class="c">#    print &quot;[evolve_J] Skipping. Output:&quot;, savename</span>
    
    <span class="k">return</span> <span class="n">savename</span>


<span class="k">def</span> <span class="nf">evolve_J</span><span class="p">(</span><span class="n">xi_vals</span><span class="p">,</span><span class="n">J_vals</span><span class="p">,</span><span class="n">r_vals</span><span class="p">,</span><span class="n">q_vals</span><span class="p">,</span><span class="n">S1_vals</span><span class="p">,</span><span class="n">S2_vals</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Wrapper of `precession.Jofr` to enable parallelization through the python</span>
<span class="sd">    `parmap` module; the number of available cores can be specified using the</span>
<span class="sd">    integer global variable `precession.CPUs` (all available cores will be used</span>
<span class="sd">    by default). Evolve a sequence of binaries with the different q, S1, S2, xi</span>
<span class="sd">    and initial values of J and save outputs at the SAME r_vals. Output is a 2D</span>
<span class="sd">    array, where e.g. J_vals[0] is the first binary (1D array at all output</span>
<span class="sd">    separations) and J_vals[0][0] is the first binary at the first output</span>
<span class="sd">    separation (this is a scalar). We strongly reccommend using this function,</span>
<span class="sd">    even for a single binary.</span>

<span class="sd">    Checkpointing is implemented: results are stored in `precession.storedir`.</span>
<span class="sd"> </span>
<span class="sd">    **Call:**</span>

<span class="sd">        Jf_vals=precession.evolve_J(xi_vals,Ji_vals,r_vals,q_vals,S1_vals,S2_vals)</span>
<span class="sd">     </span>
<span class="sd">    **Parameters:**</span>

<span class="sd">    - `xi_vals`: projection of the effective spin along the orbital angular momentum (array).</span>
<span class="sd">    - `Ji_vals`: initial condition for numerical integration (array).</span>
<span class="sd">    - `r_vals`: binary separation (array).</span>
<span class="sd">    - `q_vals`: binary mass ratio. Must be q&lt;=1 (array).</span>
<span class="sd">    - `S1_vals`: spin magnitude of the primary BH (array).</span>
<span class="sd">    - `S2_vals`: spin magnitude of the secondary BH (array).</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `Jf_vals`: magnitude of the total angular momentum (2D array).</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">global</span> <span class="n">CPUs</span>
    <span class="n">single_flag</span><span class="o">=</span><span class="bp">False</span>
    
    <span class="k">try</span><span class="p">:</span> <span class="c"># Convert float to array if you&#39;re evolving just one binary</span>
        <span class="nb">len</span><span class="p">(</span><span class="n">q_vals</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">xi_vals</span><span class="o">=</span><span class="p">[</span><span class="n">xi_vals</span><span class="p">]</span>
        <span class="n">J_vals</span><span class="o">=</span><span class="p">[</span><span class="n">J_vals</span><span class="p">]</span>
        <span class="n">q_vals</span><span class="o">=</span><span class="p">[</span><span class="n">q_vals</span><span class="p">]</span>
        <span class="n">S1_vals</span><span class="o">=</span><span class="p">[</span><span class="n">S1_vals</span><span class="p">]</span>
        <span class="n">S2_vals</span><span class="o">=</span><span class="p">[</span><span class="n">S2_vals</span><span class="p">]</span>
        <span class="n">single_flag</span><span class="o">=</span><span class="bp">True</span>
    <span class="k">try</span><span class="p">:</span> <span class="c"># Set default</span>
        <span class="n">CPUs</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">CPUs</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">print</span> <span class="s">&quot;[evolve_J] Default parallel computation&quot;</span>
    <span class="c"># Parallelization.</span>
    <span class="k">if</span> <span class="n">CPUs</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="c"># Run on all cpus on the current machine! (default option)</span>
        <span class="n">filelist</span><span class="o">=</span><span class="n">parmap</span><span class="o">.</span><span class="n">starmap</span><span class="p">(</span><span class="n">Jofr_checkpoint</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xi_vals</span><span class="p">,</span><span class="n">J_vals</span><span class="p">,</span> <span class="p">[</span><span class="n">r_vals</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q_vals</span><span class="p">))],</span><span class="n">q_vals</span><span class="p">,</span><span class="n">S1_vals</span><span class="p">,</span><span class="n">S2_vals</span><span class="p">),</span><span class="n">parallel</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> 
    <span class="k">elif</span> <span class="n">CPUs</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="c"># 1 cpus done by explicitely switching parallelization off</span>
        <span class="n">filelist</span><span class="o">=</span><span class="n">parmap</span><span class="o">.</span><span class="n">starmap</span><span class="p">(</span><span class="n">Jofr_checkpoint</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xi_vals</span><span class="p">,</span><span class="n">J_vals</span><span class="p">,</span> <span class="p">[</span><span class="n">r_vals</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q_vals</span><span class="p">))],</span><span class="n">q_vals</span><span class="p">,</span><span class="n">S1_vals</span><span class="p">,</span><span class="n">S2_vals</span><span class="p">),</span><span class="n">parallel</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> 
    <span class="k">else</span><span class="p">:</span> <span class="c"># Run on a given number of CPUs        </span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">CPUs</span><span class="p">)</span>
        <span class="n">filelist</span><span class="o">=</span><span class="n">parmap</span><span class="o">.</span><span class="n">starmap</span><span class="p">(</span><span class="n">Jofr_checkpoint</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xi_vals</span><span class="p">,</span><span class="n">J_vals</span><span class="p">,</span> <span class="p">[</span><span class="n">r_vals</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q_vals</span><span class="p">))],</span><span class="n">q_vals</span><span class="p">,</span><span class="n">S1_vals</span><span class="p">,</span><span class="n">S2_vals</span><span class="p">),</span><span class="n">pool</span><span class="o">=</span><span class="n">p</span><span class="p">)</span> 

    <span class="n">J_fvals</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="nb">file</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">filelist</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">&quot;[evolve_J] Reading:&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="nb">file</span>
        <span class="n">dummy</span><span class="p">,</span><span class="n">J_f</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="nb">file</span><span class="p">,</span><span class="n">unpack</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
             
        <span class="n">J_fvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">J_f</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">single_flag</span><span class="o">==</span><span class="bp">True</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">J_fvals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">J_fvals</span>


<span class="k">def</span> <span class="nf">evolve_angles_single</span><span class="p">(</span><span class="n">theta1_i</span><span class="p">,</span><span class="n">theta2_i</span><span class="p">,</span><span class="n">deltaphi_i</span><span class="p">,</span><span class="n">r_vals</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Auxiliary function, see `precession.evolve_angles`.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        savename=precession.evolve_angles(theta1_i,theta2_i,deltaphi_i,r_vals,q,S1,S2)</span>

<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `theta1_i`: initial condition for theta1.</span>
<span class="sd">    - `theta2_i`: initial condition for theta2</span>
<span class="sd">    - `deltaphi_i`: initial condition for deltaphi.</span>
<span class="sd">    - `r_vals`: binary separation (array).</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `savename`: checkpoint filename.</span>
<span class="sd">    &#39;&#39;&#39;</span>


    <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s">&quot;mkdir -p &quot;</span><span class="o">+</span><span class="n">storedir</span><span class="p">)</span> 
    <span class="n">savename</span><span class="o">=</span> <span class="n">storedir</span><span class="o">+</span><span class="s">&quot;/eva_&quot;</span><span class="o">+</span><span class="s">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">(</span><span class="n">theta1_i</span><span class="p">,</span><span class="n">theta2_i</span><span class="p">,</span><span class="n">deltaphi_i</span><span class="p">,</span><span class="nb">max</span><span class="p">(</span><span class="n">r_vals</span><span class="p">),</span><span class="nb">min</span><span class="p">(</span><span class="n">r_vals</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">r_vals</span><span class="p">),</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">)])</span><span class="o">+</span><span class="s">&quot;.dat&quot;</span>
        
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">savename</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">&quot;[evolve_angles] Transferring binary. Output:&quot;</span><span class="p">,</span> <span class="n">savename</span>
        <span class="n">outfilesave</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">savename</span><span class="p">,</span><span class="s">&quot;w&quot;</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
       
        <span class="c"># Step 1. Get xi and J for each intial angle. Forget S    </span>
        <span class="n">xi</span><span class="p">,</span><span class="n">J_i</span><span class="p">,</span><span class="n">dummy</span><span class="o">=</span> <span class="n">from_the_angles</span><span class="p">(</span><span class="n">theta1_i</span><span class="p">,</span><span class="n">theta2_i</span><span class="p">,</span><span class="n">deltaphi_i</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r_vals</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> 
                
        <span class="c"># Step 2. Evolve binaires with the dJ/dr ODE.</span>
        <span class="n">J_vals</span><span class="o">=</span> <span class="n">Jofr</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">J_i</span><span class="p">,</span><span class="n">r_vals</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">J_f</span><span class="p">,</span><span class="n">r_f</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">J_vals</span><span class="p">,</span><span class="n">r_vals</span><span class="p">):</span>
            <span class="c"># Step 3. Select S at the final separation with weight dt/dS</span>
            <span class="n">S_f</span><span class="o">=</span><span class="n">samplingS</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">J_f</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r_f</span><span class="p">)</span>
            <span class="c"># Step 4. Back to theta1, theta2, deltaphi</span>
            <span class="n">theta1_f</span><span class="p">,</span><span class="n">theta2_f</span><span class="p">,</span><span class="n">deltaphi_f</span><span class="p">,</span><span class="n">dummy</span><span class="o">=</span> <span class="n">parametric_angles</span><span class="p">(</span><span class="n">S_f</span><span class="p">,</span><span class="n">J_f</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r_f</span><span class="p">)</span>
            <span class="n">deltaphi_f</span><span class="o">*=</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">([</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">])</span>
            <span class="c"># Step 5. Store data            </span>
            <span class="c">#outfilesave.write(str(r_f)+&quot; &quot;+str(xi)+&quot; &quot;+str(J_f)+&quot; &quot;+str(S_f)+&quot; &quot;+str(theta1_f)+&quot; &quot;+str(theta2_f)+&quot; &quot;+str(deltaphi_f)+&quot;\n&quot;)</span>
            <span class="n">outfilesave</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">r_f</span><span class="p">)</span><span class="o">+</span><span class="s">&quot; &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">theta1_f</span><span class="p">)</span><span class="o">+</span><span class="s">&quot; &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">theta2_f</span><span class="p">)</span><span class="o">+</span><span class="s">&quot; &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">deltaphi_f</span><span class="p">)</span><span class="o">+</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
        <span class="n">outfilesave</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="c">#else:</span>
    <span class="c">#    print &quot;[evolve_angles] Skipping. Output:&quot;, savename</span>
    
    <span class="k">return</span> <span class="n">savename</span>


<span class="k">def</span> <span class="nf">evolve_angles</span><span class="p">(</span><span class="n">theta1_vals</span><span class="p">,</span><span class="n">theta2_vals</span><span class="p">,</span><span class="n">deltaphi_vals</span><span class="p">,</span><span class="n">r_vals</span><span class="p">,</span><span class="n">q_vals</span><span class="p">,</span><span class="n">S1_vals</span><span class="p">,</span><span class="n">S2_vals</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Binary evolution from the angles theta1, theta2 and deltaphi as initial data</span>
<span class="sd">    (to/from FINITE separations only). This is our so-called *transfer</span>
<span class="sd">    function*. The transfer procedure is implemented as follows:</span>

<span class="sd">    1. Convert theta1,theta2, deltaphi into J, xi and S.</span>
<span class="sd">    2. Forget S and evolve J.</span>
<span class="sd">    3. Resample S at the final separation according to dt/dS.</span>
<span class="sd">    4. Covert J, xi and S back to theta1, theta2 and deltaphi; assign a random</span>
<span class="sd">    sign to deltaphi.</span>

<span class="sd">    Parallelization through the python `parmap` module is implemented; the</span>
<span class="sd">    number of available cores can be specified using the integer global variable</span>
<span class="sd">    `precession.CPUs` (all available cores will be used by default). Evolve a</span>
<span class="sd">    sequence of binaries with different values of q, S1,S2, theta1, theta2,</span>
<span class="sd">    deltaphi (assumed to be specified at r_vals[0]) and save outputs at SAME</span>
<span class="sd">    separations r_vals. Outputs are 2D arrays, where e.g theta1_fvals[0] is the</span>
<span class="sd">    first binary (1D array at all output separations) and theta1_fvals[0][0] is</span>
<span class="sd">    the first binary at the first output separation (this is a scalar).</span>

<span class="sd">    Checkpointing is implemented: results are stored in `precession.storedir`.</span>

<span class="sd">    **Call:**</span>
<span class="sd">        theta1f_vals,theta2f_vals,deltaphif_vals=precession.evolve_angles(theta1i_vals,theta2i_vals,deltaphii_vals,r_vals,q_vals,S1_vals,S2_vals)</span>
<span class="sd">         </span>
<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `theta1i_vals`: initial condition for theta1 (array).</span>
<span class="sd">    - `theta2i_vals`: initial condition for theta2 (array).</span>
<span class="sd">    - `deltaphii_vals`: initial condition for deltaphi (array).</span>
<span class="sd">    - `r_vals`: binary separation (array).</span>
<span class="sd">    - `q_vals`: binary mass ratio. Must be q&lt;=1 (array).</span>
<span class="sd">    - `S1_vals`: spin magnitude of the primary BH (array).</span>
<span class="sd">    - `S2_vals`: spin magnitude of the secondary BH (array).</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `theta1f_vals`: solutions for theta1 (2D array).</span>
<span class="sd">    - `theta2f_vals`: solutions for theta2 (2D array).</span>
<span class="sd">    - `deltaphif_vals`: solutions for deltaphi (2D array).</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">global</span> <span class="n">CPUs</span>
    <span class="n">single_flag</span><span class="o">=</span><span class="bp">False</span>

    <span class="k">try</span><span class="p">:</span> <span class="c"># Convert float to array if you&#39;re evolving just one binary</span>
        <span class="nb">len</span><span class="p">(</span><span class="n">q_vals</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">single_flag</span><span class="o">=</span><span class="bp">True</span>
        <span class="n">theta1_vals</span><span class="o">=</span><span class="p">[</span><span class="n">theta1_vals</span><span class="p">]</span>
        <span class="n">theta2_vals</span><span class="o">=</span><span class="p">[</span><span class="n">theta2_vals</span><span class="p">]</span>
        <span class="n">deltaphi_vals</span><span class="o">=</span><span class="p">[</span><span class="n">deltaphi_vals</span><span class="p">]</span>
        <span class="n">q_vals</span><span class="o">=</span><span class="p">[</span><span class="n">q_vals</span><span class="p">]</span>
        <span class="n">S1_vals</span><span class="o">=</span><span class="p">[</span><span class="n">S1_vals</span><span class="p">]</span>
        <span class="n">S2_vals</span><span class="o">=</span><span class="p">[</span><span class="n">S2_vals</span><span class="p">]</span>
    <span class="k">try</span><span class="p">:</span> <span class="c"># Set default</span>
        <span class="n">CPUs</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">CPUs</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">print</span> <span class="s">&quot;[evolve_angles] Default parallel computation&quot;</span>

    <span class="n">loopflag</span><span class="o">=</span><span class="bp">True</span>
    <span class="k">while</span> <span class="n">loopflag</span><span class="p">:</span> <span class="c"># Restart is some of the cores crashed. This happend if you run too many binaries on too many different machines. Nevermind, trash the file and do it again.</span>
        <span class="n">loopflag</span><span class="o">=</span><span class="bp">False</span>

        <span class="c">#Parallelization</span>
        <span class="k">if</span> <span class="n">CPUs</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="c">#Run on all cpus on the current machine! (default option)    </span>
            <span class="n">filelist</span><span class="o">=</span><span class="n">parmap</span><span class="o">.</span><span class="n">starmap</span><span class="p">(</span><span class="n">evolve_angles_single</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">theta1_vals</span><span class="p">,</span><span class="n">theta2_vals</span><span class="p">,</span><span class="n">deltaphi_vals</span><span class="p">,[</span><span class="n">r_vals</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q_vals</span><span class="p">))],</span><span class="n">q_vals</span><span class="p">,</span><span class="n">S1_vals</span><span class="p">,</span><span class="n">S2_vals</span><span class="p">),</span><span class="n">parallel</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> 
        <span class="k">elif</span> <span class="n">CPUs</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="c">#1 cpus done by explicitely removing parallelization</span>
            <span class="n">filelist</span><span class="o">=</span><span class="n">parmap</span><span class="o">.</span><span class="n">starmap</span><span class="p">(</span><span class="n">evolve_angles_single</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">theta1_vals</span><span class="p">,</span><span class="n">theta2_vals</span><span class="p">,</span><span class="n">deltaphi_vals</span><span class="p">,[</span><span class="n">r_vals</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q_vals</span><span class="p">))],</span><span class="n">q_vals</span><span class="p">,</span><span class="n">S1_vals</span><span class="p">,</span><span class="n">S2_vals</span><span class="p">),</span><span class="n">parallel</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> 
        <span class="k">else</span><span class="p">:</span> <span class="c"># Run on a given number of CPUs        </span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">CPUs</span><span class="p">)</span>
            <span class="n">filelist</span><span class="o">=</span><span class="n">parmap</span><span class="o">.</span><span class="n">starmap</span><span class="p">(</span><span class="n">evolve_angles_single</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">theta1_vals</span><span class="p">,</span><span class="n">theta2_vals</span><span class="p">,</span><span class="n">deltaphi_vals</span><span class="p">,[</span><span class="n">r_vals</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q_vals</span><span class="p">))],</span><span class="n">q_vals</span><span class="p">,</span><span class="n">S1_vals</span><span class="p">,</span><span class="n">S2_vals</span><span class="p">),</span><span class="n">pool</span><span class="o">=</span><span class="n">p</span><span class="p">)</span> 

        <span class="n">theta1_fvals</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">theta2_fvals</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">deltaphi_fvals</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="nb">file</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">filelist</span><span class="p">):</span>
            <span class="k">print</span> <span class="s">&quot;[evolve_angles] Reading:&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="nb">file</span>
            <span class="n">numlines</span><span class="o">=</span><span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">open</span><span class="p">(</span><span class="nb">file</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">numlines</span><span class="o">!=</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">numlines</span><span class="o">!=</span><span class="nb">len</span><span class="p">(</span><span class="n">r_vals</span><span class="p">):</span> <span class="c"># Restart if core(s) crashed</span>
                <span class="k">print</span> <span class="s">&quot;[evolve_angles] Error on file&quot;</span><span class="p">,</span> <span class="nb">file</span><span class="p">,</span><span class="s">&quot;. Jobs are being restarted!&quot;</span>
                <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s">&quot;rm &quot;</span><span class="o">+</span><span class="nb">file</span><span class="p">)</span> 
                <span class="n">loopflag</span><span class="o">=</span><span class="bp">True</span>
 
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dummy</span><span class="p">,</span><span class="n">theta1_f</span><span class="p">,</span><span class="n">theta2_f</span><span class="p">,</span><span class="n">deltaphi_f</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="nb">file</span><span class="p">,</span><span class="n">unpack</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                <span class="n">theta1_fvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">theta1_f</span><span class="p">)</span>
                <span class="n">theta2_fvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">theta2_f</span><span class="p">)</span>
                <span class="n">deltaphi_fvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">deltaphi_f</span><span class="p">)</span>        
        
    <span class="k">if</span> <span class="n">single_flag</span><span class="o">==</span><span class="bp">True</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">theta1_fvals</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">theta2_fvals</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">deltaphi_fvals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">theta1_fvals</span><span class="p">,</span> <span class="n">theta2_fvals</span><span class="p">,</span> <span class="n">deltaphi_fvals</span>

      
<span class="k">def</span> <span class="nf">Jofr_infinity</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">kappa_inf</span><span class="p">,</span><span class="n">r_vals</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">):</span> 

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Single integration of the dJ/dL equation to perfom precession-averaged</span>
<span class="sd">    inspiral. Input/output are provided in J and r, but the internal integrator</span>
<span class="sd">    uses kappa and u (see `precession.dkappadu`). Integration is performed using</span>
<span class="sd">    scipy&#39;s `odeint`.</span>

<span class="sd">    This function integrates FROM INFINITE separation (u=0) only.</span>

<span class="sd">    The latter must be consistent with `precession.kappainf_lim`; an error is</span>
<span class="sd">    raised in case of inconsistencies. It assume that the array r_vals is sorted</span>
<span class="sd">    in reversed order, i.e. that you are integrating from large to small</span>
<span class="sd">    separations. It returns a vector with the values of J at each input</span>
<span class="sd">    separation. The initial condition is NOT returned by this function (unlike</span>
<span class="sd">    the `precession.Jofr` for integrations to/from finite separations). If q=1,</span>
<span class="sd">    kappa_inf is degenerate with xi: the required initial condition is assumed</span>
<span class="sd">    to be S (which is constant).</span>

<span class="sd">    We recommend to use this function through the wrapper</span>
<span class="sd">    `precession.evolve_J_infinity` provided.</span>
<span class="sd"> </span>
<span class="sd">    **Call:**</span>

<span class="sd">        J_vals=precession.Jofr_infinity(xi,kappa_inf,r_vals,q,S1,S2)</span>

<span class="sd">    **Parameters:**</span>

<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `kappa_inf`: asymptotic value of kappa at large separations.</span>
<span class="sd">    - `r_vals`: binary separation (array).</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `J_vals`: magnitude of the total angular momentum (array).</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="c"># ASSUMES r_vals is sorted in reversed order!!!</span>
    <span class="n">L_vals</span><span class="o">=</span><span class="p">[</span> <span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">r_vals</span><span class="p">]</span>

    <span class="k">global</span> <span class="n">flags_q1</span> 
    <span class="k">if</span> <span class="n">q</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">flags_q1</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="o">==</span><span class="bp">False</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;[Jofr_infinity] Warning q=1: required intial condition is S, not kappa_inf.&quot;</span>
            <span class="n">flags_q1</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="o">=</span><span class="bp">True</span> <span class="c"># Suppress future warnings</span>
        <span class="n">S</span><span class="o">=</span><span class="n">kappa_inf</span>
        <span class="n">J_vals</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">xi</span><span class="o">*</span><span class="n">L</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">L</span> <span class="ow">in</span> <span class="n">L_vals</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">u_vals</span><span class="o">=</span><span class="p">[</span> <span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">L</span><span class="p">)</span> <span class="k">for</span> <span class="n">L</span> <span class="ow">in</span> <span class="n">L_vals</span><span class="p">]</span>
        <span class="n">u_vals</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.</span><span class="p">)</span> <span class="c"># Add initial condition, r=inifinty u=0</span>
    
        <span class="c"># Numerical integration from u=0   </span>
        <span class="c"># Increase h0 to prevent occasional slowing down of the integration</span>
        <span class="n">res</span> <span class="o">=</span><span class="n">integrate</span><span class="o">.</span><span class="n">odeint</span><span class="p">(</span><span class="n">dkappadu</span><span class="p">,</span> <span class="n">kappa_inf</span><span class="p">,</span> <span class="n">u_vals</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">),</span> <span class="n">mxstep</span><span class="o">=</span><span class="mi">50000</span><span class="p">,</span> <span class="n">full_output</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">printmessg</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">h0</span><span class="o">=</span><span class="mf">2e-4</span><span class="p">)</span>

        <span class="n">kappa_vals</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">res</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span> <span class="c"># Remove initial condition (not present in r_vals...)</span>
        <span class="n">J_vals</span><span class="o">=</span> <span class="p">[</span> <span class="p">(</span><span class="n">k</span><span class="o">*</span><span class="mf">2.</span><span class="o">*</span><span class="n">L</span> <span class="o">+</span> <span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">L</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">kappa_vals</span><span class="p">,</span><span class="n">L_vals</span><span class="p">)]</span>
    
    <span class="k">return</span> <span class="n">J_vals</span>

   
<span class="k">def</span> <span class="nf">Jofr_infinity_checkpoint</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">kappa_inf</span><span class="p">,</span><span class="n">r_vals</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">):</span>
    
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Auxiliary function, see `precession.evolve_J_infinity`.</span>
<span class="sd"> </span>
<span class="sd">    **Call:**</span>

<span class="sd">        savename=precession.Jofr_infinity_checkpoint(xi,kappa_inf,r_vals,q,S1,S2)</span>

<span class="sd">    **Parameters:**</span>

<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `kappa_inf`: asymptotic value of kappa at large separations.</span>
<span class="sd">    - `r_vals`: binary separation (array).</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `savename`: checkpoint filename.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s">&quot;mkdir -p &quot;</span><span class="o">+</span><span class="n">storedir</span><span class="p">)</span> 
    <span class="n">savename</span><span class="o">=</span> <span class="n">storedir</span><span class="o">+</span><span class="s">&quot;/evJinf_&quot;</span><span class="o">+</span><span class="s">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">kappa_inf</span><span class="p">,</span><span class="nb">max</span><span class="p">(</span><span class="n">r_vals</span><span class="p">),</span><span class="nb">min</span><span class="p">(</span><span class="n">r_vals</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">r_vals</span><span class="p">),</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">)])</span><span class="o">+</span><span class="s">&quot;.dat&quot;</span>
        
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">savename</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">&quot;[evolve_J_infinity] Transferring binary. Output:&quot;</span><span class="p">,</span> <span class="n">savename</span>
        <span class="n">outfilesave</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">savename</span><span class="p">,</span><span class="s">&quot;w&quot;</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
       
        <span class="n">J_vals</span><span class="o">=</span> <span class="n">Jofr_infinity</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">kappa_inf</span><span class="p">,</span><span class="n">r_vals</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">J_f</span><span class="p">,</span><span class="n">r_f</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">J_vals</span><span class="p">,</span><span class="n">r_vals</span><span class="p">):</span>        
            <span class="n">outfilesave</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">r_f</span><span class="p">)</span><span class="o">+</span><span class="s">&quot; &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">J_f</span><span class="p">)</span><span class="o">+</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
        <span class="n">outfilesave</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="c">#else:</span>
    <span class="c">#    print &quot;[evolve_J_infinity] Skipping. Output:&quot;, savename</span>
    
    <span class="k">return</span> <span class="n">savename</span>


<span class="k">def</span> <span class="nf">evolve_J_infinity</span><span class="p">(</span><span class="n">xi_vals</span><span class="p">,</span><span class="n">kappainf_vals</span><span class="p">,</span><span class="n">r_vals</span><span class="p">,</span><span class="n">q_vals</span><span class="p">,</span><span class="n">S1_vals</span><span class="p">,</span><span class="n">S2_vals</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Wrapper of `precession.Jofr_infinity` to enable parallelization through the</span>
<span class="sd">    python `parmap` module; the number of available cores can be specified using</span>
<span class="sd">    the integer global variable `precession.CPUs` (all available cores will be</span>
<span class="sd">    used by default). Evolve a sequence of binaries with the different q, S1,</span>
<span class="sd">    S2, xi and initial values of J and save outputs at the SAME separations</span>
<span class="sd">    r_vals. Output is a 2D array, where e.g. J_vals[0] is the first binary (1D</span>
<span class="sd">    array at all output separations) and J_vals[0][0] is the first binary at the</span>
<span class="sd">    first output separation (this is a scalar). We strongly reccommend using</span>
<span class="sd">    this function, even for a single binary.</span>

<span class="sd">    Checkpointing is implemented: results are stored in `precession.storedir`.</span>
<span class="sd"> </span>
<span class="sd">    **Call:**</span>

<span class="sd">        Jf_vals=precession.evolve_J_infinity(xi_vals,kappainf_vals,r_vals,q_vals,S1_vals,S2_vals)</span>

<span class="sd">    **Parameters:**</span>

<span class="sd">    - `xi_vals`: projection of the effective spin along the orbital angular momentum (array).</span>
<span class="sd">    - `kappainf_vals`: asymptotic value of kappa at large separations (array).</span>
<span class="sd">    - `r_vals`: binary separation (array).</span>
<span class="sd">    - `q_vals`: binary mass ratio. Must be q&lt;=1 (array).</span>
<span class="sd">    - `S1_vals`: spin magnitude of the primary BH (array).</span>
<span class="sd">    - `S2_vals`: spin magnitude of the secondary BH (array).</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `Jf_vals`: magnitude of the total angular momentum (2D array).</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">global</span> <span class="n">CPUs</span>

    <span class="n">single_flag</span><span class="o">=</span><span class="bp">False</span>
    <span class="k">try</span><span class="p">:</span> <span class="c">#Convert float to array if you&#39;re evolving just one binary</span>
        <span class="nb">len</span><span class="p">(</span><span class="n">q_vals</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">xi_vals</span><span class="o">=</span><span class="p">[</span><span class="n">xi_vals</span><span class="p">]</span>
        <span class="n">kappainf_vals</span><span class="o">=</span><span class="p">[</span><span class="n">kappainf_vals</span><span class="p">]</span>
        <span class="n">q_vals</span><span class="o">=</span><span class="p">[</span><span class="n">q_vals</span><span class="p">]</span>
        <span class="n">S1_vals</span><span class="o">=</span><span class="p">[</span><span class="n">S1_vals</span><span class="p">]</span>
        <span class="n">S2_vals</span><span class="o">=</span><span class="p">[</span><span class="n">S2_vals</span><span class="p">]</span>
        <span class="n">single_flag</span><span class="o">=</span><span class="bp">True</span>
    <span class="k">try</span><span class="p">:</span> <span class="c"># Set default</span>
        <span class="n">CPUs</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">CPUs</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">print</span> <span class="s">&quot;[evolve_J_infinity] Default parallel computation&quot;</span>
    <span class="c"># Parallelization</span>
    <span class="k">if</span> <span class="n">CPUs</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="c"># Run on all cpus on the current machine! (default option)</span>
        <span class="n">filelist</span><span class="o">=</span><span class="n">parmap</span><span class="o">.</span><span class="n">starmap</span><span class="p">(</span><span class="n">Jofr_infinity_checkpoint</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xi_vals</span><span class="p">,</span><span class="n">kappainf_vals</span><span class="p">,[</span><span class="n">r_vals</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q_vals</span><span class="p">))],</span><span class="n">q_vals</span><span class="p">,</span><span class="n">S1_vals</span><span class="p">,</span><span class="n">S2_vals</span><span class="p">),</span><span class="n">parallel</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> 
    <span class="k">elif</span> <span class="n">CPUs</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="c"># 1 cpus done by explicitely removing parallelization</span>
        <span class="n">filelist</span><span class="o">=</span><span class="n">parmap</span><span class="o">.</span><span class="n">starmap</span><span class="p">(</span><span class="n">Jofr_infinity_checkpoint</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xi_vals</span><span class="p">,</span><span class="n">kappainf_vals</span><span class="p">,[</span><span class="n">r_vals</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q_vals</span><span class="p">))],</span><span class="n">q_vals</span><span class="p">,</span><span class="n">S1_vals</span><span class="p">,</span><span class="n">S2_vals</span><span class="p">),</span><span class="n">parallel</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> 
    <span class="k">else</span><span class="p">:</span> <span class="c"># Run on a given number of CPUs        </span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">CPUs</span><span class="p">)</span>
        <span class="n">filelist</span><span class="o">=</span><span class="n">parmap</span><span class="o">.</span><span class="n">starmap</span><span class="p">(</span><span class="n">Jofr_infinity_checkpoint</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xi_vals</span><span class="p">,</span><span class="n">kappainf_vals</span><span class="p">,[</span><span class="n">r_vals</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q_vals</span><span class="p">))],</span><span class="n">q_vals</span><span class="p">,</span><span class="n">S1_vals</span><span class="p">,</span><span class="n">S2_vals</span><span class="p">),</span><span class="n">pool</span><span class="o">=</span><span class="n">p</span><span class="p">)</span> 

    <span class="n">J_fvals</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="nb">file</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">filelist</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">&quot;[evolve_J_infinity] Reading:&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="nb">file</span>
        <span class="n">dummy</span><span class="p">,</span><span class="n">J_f</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="nb">file</span><span class="p">,</span><span class="n">unpack</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
             
        <span class="n">J_fvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">J_f</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">single_flag</span><span class="o">==</span><span class="bp">True</span><span class="p">:</span>    
        <span class="k">return</span> <span class="n">J_fvals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">J_fvals</span>


<span class="k">def</span> <span class="nf">kappa_backwards</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Single integration of the dJ/dL equation to perfom precession-averaged</span>
<span class="sd">    inspiral. Input/output are provided in J and r, but the internal integrator</span>
<span class="sd">    uses kappa and u (see `precession.dkappadu`). Integration is performed using</span>
<span class="sd">    scipy&#39;s `odeint`.</span>

<span class="sd">    This function integrates from some finite separation TO INFINITE separation</span>
<span class="sd">    (u=0) only.</span>

<span class="sd">    The initial binary is specified at the input separation r through J and xi</span>
<span class="sd">    (S not needed). The binary is evolved backwards to r=infinity (u=0) and the</span>
<span class="sd">    asymptotic value kappa_inf is returned. If q=1, kappa_inf is degenerate with</span>
<span class="sd">    xi: the constant value of S is returned instead.</span>

<span class="sd">    We recommend to use this function through the wrapper</span>
<span class="sd">    `precession.evolve_J_backwards` provided.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        kappa_inf=precession.kappa_backwards(xi,J,r,q,S1,S2)</span>

<span class="sd">    **Parameters:**</span>

<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `J`: magnitude of the total angular momentum.</span>
<span class="sd">    - `r`: binary separation.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `kappa_inf`: asymptotic value of kappa at large separations.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">L</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>

    <span class="k">global</span> <span class="n">flags_q1</span>
    <span class="k">if</span> <span class="n">q</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">flags_q1</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span><span class="o">==</span><span class="bp">False</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;[kappa_backwards] Warning q=1: sensible output is S, not kappa_inf.&quot;</span>
            <span class="n">flags_q1</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span><span class="o">=</span><span class="bp">True</span> <span class="c"># Suppress future warnings</span>
        <span class="n">S</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">xi</span><span class="o">*</span><span class="n">L</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">S</span>
    
    <span class="k">else</span><span class="p">:</span>
        <span class="n">u</span><span class="o">=</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">L</span><span class="p">)</span>
        <span class="n">kappa</span><span class="o">=</span> <span class="p">(</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">L</span><span class="p">)</span>
        <span class="n">u_vals</span><span class="o">=</span><span class="p">[</span><span class="n">u</span><span class="p">,</span><span class="mf">0.</span><span class="p">]</span><span class="c"># Add final condition, r=inifinty u=0</span>
        <span class="c"># Numerical integration to u=0    </span>
        <span class="n">res</span> <span class="o">=</span><span class="n">integrate</span><span class="o">.</span><span class="n">odeint</span><span class="p">(</span><span class="n">dkappadu</span><span class="p">,</span> <span class="n">kappa</span><span class="p">,</span> <span class="n">u_vals</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">),</span> <span class="n">mxstep</span><span class="o">=</span><span class="mi">50000</span><span class="p">,</span> <span class="n">full_output</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">printmessg</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="c">#,tcrit=sing)</span>
        <span class="n">kappa_inf</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">res</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">kappa_inf</span>


<span class="k">def</span> <span class="nf">kappa_backwards_checkpoint</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Auxiliary function, see `precession.evolve_J_backwards`.</span>
<span class="sd"> </span>
<span class="sd">    **Call:**</span>

<span class="sd">        savename=precession.kappa_backwards_checkpoint(xi,J,r,q,S1,S2)</span>

<span class="sd">    **Parameters:**</span>

<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `J`: magnitude of the total angular momentum.</span>
<span class="sd">    - `r`: binary separation.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `savename`: checkpoint filename.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s">&quot;mkdir -p &quot;</span><span class="o">+</span><span class="n">storedir</span><span class="p">)</span> 
    <span class="n">savename</span><span class="o">=</span> <span class="n">storedir</span><span class="o">+</span><span class="s">&quot;/evback&quot;</span><span class="o">+</span><span class="s">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">)])</span><span class="o">+</span><span class="s">&quot;.dat&quot;</span>
        
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">savename</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">&quot;[evolve_J_backwards] Transferring binary. Output:&quot;</span><span class="p">,</span> <span class="n">savename</span>
        <span class="n">outfilesave</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">savename</span><span class="p">,</span><span class="s">&quot;w&quot;</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
       
        <span class="n">kappa_inf</span><span class="o">=</span><span class="n">kappa_backwards</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">)</span>
        <span class="n">outfilesave</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">kappa_inf</span><span class="p">))</span>
        <span class="n">outfilesave</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="c">#else:</span>
    <span class="c">#    print &quot;[evolve_J_infinity] Skipping. Output:&quot;, savename</span>
    
    <span class="k">return</span> <span class="n">savename</span>


<span class="k">def</span> <span class="nf">evolve_J_backwards</span><span class="p">(</span><span class="n">xi_vals</span><span class="p">,</span><span class="n">J_vals</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">q_vals</span><span class="p">,</span><span class="n">S1_vals</span><span class="p">,</span><span class="n">S2_vals</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Wrapper of `precession.kappa_backwards` to enable parallelization through</span>
<span class="sd">    the python `parmap` module; the number of available cores can be specified</span>
<span class="sd">    using the integer global variable `precession.CPUs` (all available cores</span>
<span class="sd">    will be used by default). Evolve a sequence of binaries with the different</span>
<span class="sd">    q, S1,S2, xi and kappa_inf from the SAME separation r.</span>

<span class="sd">    Checkpointing is implemented: results are stored in `precession.storedir`.</span>
<span class="sd"> </span>
<span class="sd">    **Call:**</span>

<span class="sd">        kappainf_vals=precession.evolve_J_backwards(xi_vals,J_vals,r,q_vals,S1_vals,S2_vals)</span>

<span class="sd">    **Parameters:**</span>

<span class="sd">    - `xi_vals`: projection of the effective spin along the orbital angular momentum (array).</span>
<span class="sd">    - `J`: magnitude of the total angular momentum (array).</span>
<span class="sd">    - `r`: binary separation.</span>
<span class="sd">    - `q_vals`: binary mass ratio. Must be q&lt;=1 (array).</span>
<span class="sd">    - `S1_vals`: spin magnitude of the primary BH (array).</span>
<span class="sd">    - `S2_vals`: spin magnitude of the secondary BH (array).</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `kappainf_vals`: asymptotic value of kappa at large separations (array).</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">global</span> <span class="n">CPUs</span>

    <span class="n">flag</span><span class="o">=</span><span class="bp">False</span>
    <span class="k">try</span><span class="p">:</span> <span class="c">#Convert float to array, if you&#39;re evolving just one binary</span>
        <span class="nb">len</span><span class="p">(</span><span class="n">q_vals</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">xi_vals</span><span class="o">=</span><span class="p">[</span><span class="n">xi_vals</span><span class="p">]</span>
        <span class="n">J_vals</span><span class="o">=</span><span class="p">[</span><span class="n">J_vals</span><span class="p">]</span>
        <span class="n">q_vals</span><span class="o">=</span><span class="p">[</span><span class="n">q_vals</span><span class="p">]</span>
        <span class="n">S1_vals</span><span class="o">=</span><span class="p">[</span><span class="n">S1_vals</span><span class="p">]</span>
        <span class="n">S2_vals</span><span class="o">=</span><span class="p">[</span><span class="n">S2_vals</span><span class="p">]</span>
        <span class="n">flag</span><span class="o">=</span><span class="bp">True</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">CPUs</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">CPUs</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">print</span> <span class="s">&quot;[evolve_J_backwards] Default parallel computation&quot;</span>
    <span class="c">#Parallelization... python is cool indeed</span>
    <span class="k">if</span> <span class="n">CPUs</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="c">#Run on all cpus on the current machine! (default option)</span>
        <span class="n">filelist</span><span class="o">=</span><span class="n">parmap</span><span class="o">.</span><span class="n">starmap</span><span class="p">(</span><span class="n">kappa_backwards_checkpoint</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xi_vals</span><span class="p">,</span><span class="n">J_vals</span><span class="p">,[</span><span class="n">r</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q_vals</span><span class="p">))],</span><span class="n">q_vals</span><span class="p">,</span><span class="n">S1_vals</span><span class="p">,</span><span class="n">S2_vals</span><span class="p">),</span><span class="n">parallel</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> 
    <span class="k">elif</span> <span class="n">CPUs</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="c">#1 cpus done by explicitely removing parallelization</span>
        <span class="n">filelist</span><span class="o">=</span><span class="n">parmap</span><span class="o">.</span><span class="n">starmap</span><span class="p">(</span><span class="n">kappa_backwards_checkpoint</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xi_vals</span><span class="p">,</span><span class="n">J_vals</span><span class="p">,[</span><span class="n">r</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q_vals</span><span class="p">))],</span><span class="n">q_vals</span><span class="p">,</span><span class="n">S1_vals</span><span class="p">,</span><span class="n">S2_vals</span><span class="p">),</span><span class="n">parallel</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> 
    <span class="k">else</span><span class="p">:</span> <span class="c"># Run on a given number of CPUs        </span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">CPUs</span><span class="p">)</span>
        <span class="n">filelist</span><span class="o">=</span><span class="n">parmap</span><span class="o">.</span><span class="n">starmap</span><span class="p">(</span><span class="n">kappa_backwards_checkpoint</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xi_vals</span><span class="p">,</span><span class="n">J_vals</span><span class="p">,[</span><span class="n">r</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q_vals</span><span class="p">))],</span><span class="n">q_vals</span><span class="p">,</span><span class="n">S1_vals</span><span class="p">,</span><span class="n">S2_vals</span><span class="p">),</span><span class="n">pool</span><span class="o">=</span><span class="n">p</span><span class="p">)</span> 

    <span class="n">kappainf_vals</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="nb">file</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">filelist</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">&quot;[evolve_J_backwards] Reading:&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="nb">file</span>
        <span class="n">kappa_inf</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="nb">file</span><span class="p">,</span><span class="n">unpack</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>     
        <span class="n">kappainf_vals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kappa_inf</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">flag</span><span class="o">==</span><span class="bp">True</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">kappainf_vals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">kappainf_vals</span>




<span class="c">#################################</span>
<span class="c">#### ORBIT-AVERAGED INSPIRAL ####</span>
<span class="c">#################################</span>


<span class="k">def</span> <span class="nf">orbav_eqs</span><span class="p">(</span><span class="n">allvars</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">eta</span><span class="p">,</span><span class="n">m1</span><span class="p">,</span><span class="n">m2</span><span class="p">,</span><span class="n">chi1</span><span class="p">,</span><span class="n">chi2</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Right-hand side of the orbit-averaged PN equations: d[allvars]/dv=RHS, where</span>
<span class="sd">    allvars is an array with the cartesian components of the unit vectors L, S1</span>
<span class="sd">    and S2. This function is only the actual system of equations, not the ODE</span>
<span class="sd">    solver.</span>

<span class="sd">    Equations are the ones reported in Gerosa et al. [Phys.Rev. D87 (2013) 10,</span>
<span class="sd">    104028](http://journals.aps.org/prd/abstract/10.1103/PhysRevD.87.104028);</span>
<span class="sd">    see references therein. In particular, the quadrupole-monopole term computed</span>
<span class="sd">    by Racine is included. The results presented in Gerosa et al. 2013 actually</span>
<span class="sd">    use additional unpublished terms, that are not listed in the published</span>
<span class="sd">    equations and are NOT included here. Radiation reaction is included up to</span>
<span class="sd">    3.5PN.</span>

<span class="sd">    The internal quadrupole_formula flag switches off all PN corrections in</span>
<span class="sd">    radiation reaction.</span>

<span class="sd">    The integration is carried over in the orbital velocity v (equivalent to the</span>
<span class="sd">    separation), not in time. If an expression for v(t) is needed, the code can</span>
<span class="sd">    be easiliy modified to return time as well.</span>
<span class="sd"> </span>
<span class="sd">    **Call:**</span>

<span class="sd">        allders=precession.orbav_eqs(allvars,v,q,S1,S2,eta,m1,m2,chi1,chi2)</span>

<span class="sd">    **Parameters:**</span>
<span class="sd">    - `allvars`: array of lenght 9 cointaining the initial condition for numerical integration for the components of the unit vectors L, S1 and S2.</span>
<span class="sd">    - `v`: orbital velocity.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `eta`: symmetric mass ratio.</span>
<span class="sd">    - `m1`: mass of the primary BH.</span>
<span class="sd">    - `m2`: mass of the secondary BH.</span>
<span class="sd">    - `chi1`: dimensionless spin magnitude of the primary BH. Must be 0&lt;=chi1&lt;=1</span>
<span class="sd">    - `chi2`: dimensionless spin magnitude of the secondary BH. Must be 0&lt;=chi2&lt;=1</span>
<span class="sd">    </span>
<span class="sd">    **Returns:**</span>

<span class="sd">    - `allders`: array of lenght 9 cointaining the derivatives of allvars with respect to the orbital velocity v.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="c"># Read variables in</span>
    <span class="n">Lhx</span><span class="o">=</span><span class="n">allvars</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">Lhy</span><span class="o">=</span><span class="n">allvars</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">Lhz</span><span class="o">=</span><span class="n">allvars</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">S1hx</span><span class="o">=</span><span class="n">allvars</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">S1hy</span><span class="o">=</span><span class="n">allvars</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
    <span class="n">S1hz</span><span class="o">=</span><span class="n">allvars</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
    <span class="n">S2hx</span><span class="o">=</span><span class="n">allvars</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>
    <span class="n">S2hy</span><span class="o">=</span><span class="n">allvars</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span>
    <span class="n">S2hz</span><span class="o">=</span><span class="n">allvars</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span>
    <span class="c">#t=allvars[9] # Uncomment if v(t) is needed</span>

    <span class="c"># Useful variables</span>
    <span class="n">ct1</span><span class="o">=</span><span class="p">(</span><span class="n">Lhx</span><span class="o">*</span><span class="n">S1hx</span><span class="o">+</span><span class="n">Lhy</span><span class="o">*</span><span class="n">S1hy</span><span class="o">+</span><span class="n">Lhz</span><span class="o">*</span><span class="n">S1hz</span><span class="p">)</span>
    <span class="n">ct2</span><span class="o">=</span><span class="p">(</span><span class="n">Lhx</span><span class="o">*</span><span class="n">S2hx</span><span class="o">+</span><span class="n">Lhy</span><span class="o">*</span><span class="n">S2hy</span><span class="o">+</span><span class="n">Lhz</span><span class="o">*</span><span class="n">S2hz</span><span class="p">)</span>
    <span class="n">ct12</span><span class="o">=</span><span class="p">(</span><span class="n">S1hx</span><span class="o">*</span><span class="n">S2hx</span><span class="o">+</span><span class="n">S1hy</span><span class="o">*</span><span class="n">S2hy</span><span class="o">+</span><span class="n">S1hz</span><span class="o">*</span><span class="n">S2hz</span><span class="p">)</span>

    <span class="c"># Spin precession for S1</span>
    <span class="n">Omega1x</span><span class="o">=</span> <span class="n">eta</span><span class="o">*</span><span class="n">v</span><span class="o">**</span><span class="mi">5</span><span class="o">*</span><span class="p">(</span><span class="mf">2.</span><span class="o">+</span><span class="mf">3.</span><span class="o">*</span><span class="n">q</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span><span class="o">*</span><span class="n">Lhx</span><span class="o">/</span><span class="n">M</span>  \
            <span class="o">+</span> <span class="n">v</span><span class="o">**</span><span class="mi">6</span><span class="o">*</span><span class="p">(</span><span class="n">S2</span><span class="o">*</span><span class="n">S2hx</span><span class="o">-</span><span class="mf">3.</span><span class="o">*</span><span class="n">S2</span><span class="o">*</span><span class="n">ct2</span><span class="o">*</span><span class="n">Lhx</span><span class="o">-</span><span class="mf">3.</span><span class="o">*</span><span class="n">q</span><span class="o">*</span><span class="n">S1</span><span class="o">*</span><span class="n">ct1</span><span class="o">*</span><span class="n">Lhx</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">Omega1y</span><span class="o">=</span> <span class="n">eta</span><span class="o">*</span><span class="n">v</span><span class="o">**</span><span class="mi">5</span><span class="o">*</span><span class="p">(</span><span class="mf">2.</span><span class="o">+</span><span class="mf">3.</span><span class="o">*</span><span class="n">q</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span><span class="o">*</span><span class="n">Lhy</span><span class="o">/</span><span class="n">M</span>  \
            <span class="o">+</span> <span class="n">v</span><span class="o">**</span><span class="mi">6</span><span class="o">*</span><span class="p">(</span><span class="n">S2</span><span class="o">*</span><span class="n">S2hy</span><span class="o">-</span><span class="mf">3.</span><span class="o">*</span><span class="n">S2</span><span class="o">*</span><span class="n">ct2</span><span class="o">*</span><span class="n">Lhy</span><span class="o">-</span><span class="mf">3.</span><span class="o">*</span><span class="n">q</span><span class="o">*</span><span class="n">S1</span><span class="o">*</span><span class="n">ct1</span><span class="o">*</span><span class="n">Lhy</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">Omega1z</span><span class="o">=</span> <span class="n">eta</span><span class="o">*</span><span class="n">v</span><span class="o">**</span><span class="mi">5</span><span class="o">*</span><span class="p">(</span><span class="mf">2.</span><span class="o">+</span><span class="mf">3.</span><span class="o">*</span><span class="n">q</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span><span class="o">*</span><span class="n">Lhz</span><span class="o">/</span><span class="n">M</span>  \
            <span class="o">+</span> <span class="n">v</span><span class="o">**</span><span class="mi">6</span><span class="o">*</span><span class="p">(</span><span class="n">S2</span><span class="o">*</span><span class="n">S2hz</span><span class="o">-</span><span class="mf">3.</span><span class="o">*</span><span class="n">S2</span><span class="o">*</span><span class="n">ct2</span><span class="o">*</span><span class="n">Lhz</span><span class="o">-</span><span class="mf">3.</span><span class="o">*</span><span class="n">q</span><span class="o">*</span><span class="n">S1</span><span class="o">*</span><span class="n">ct1</span><span class="o">*</span><span class="n">Lhz</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>

    <span class="n">dS1hxdt</span><span class="o">=</span> <span class="n">Omega1y</span><span class="o">*</span><span class="n">S1hz</span> <span class="o">-</span> <span class="n">Omega1z</span><span class="o">*</span><span class="n">S1hy</span>
    <span class="n">dS1hydt</span><span class="o">=</span> <span class="n">Omega1z</span><span class="o">*</span><span class="n">S1hx</span> <span class="o">-</span> <span class="n">Omega1x</span><span class="o">*</span><span class="n">S1hz</span>
    <span class="n">dS1hzdt</span><span class="o">=</span> <span class="n">Omega1x</span><span class="o">*</span><span class="n">S1hy</span> <span class="o">-</span> <span class="n">Omega1y</span><span class="o">*</span><span class="n">S1hx</span>

    <span class="c"># Spin precession for S2</span>
    <span class="n">Omega2x</span><span class="o">=</span> <span class="n">eta</span><span class="o">*</span><span class="n">v</span><span class="o">**</span><span class="mi">5</span><span class="o">*</span><span class="p">(</span><span class="mf">2.</span><span class="o">+</span><span class="mf">3.</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">q</span><span class="p">))</span><span class="o">*</span><span class="n">Lhx</span><span class="o">/</span><span class="n">M</span>  \
            <span class="o">+</span> <span class="n">v</span><span class="o">**</span><span class="mi">6</span><span class="o">*</span><span class="p">(</span><span class="n">S1</span><span class="o">*</span><span class="n">S1hx</span><span class="o">-</span><span class="mf">3.</span><span class="o">*</span><span class="n">S1</span><span class="o">*</span><span class="n">ct1</span><span class="o">*</span><span class="n">Lhx</span><span class="o">-</span><span class="mf">3.</span><span class="o">*</span><span class="n">S2</span><span class="o">*</span><span class="n">ct2</span><span class="o">*</span><span class="n">Lhx</span><span class="o">/</span><span class="n">q</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">Omega2y</span><span class="o">=</span> <span class="n">eta</span><span class="o">*</span><span class="n">v</span><span class="o">**</span><span class="mi">5</span><span class="o">*</span><span class="p">(</span><span class="mf">2.</span><span class="o">+</span><span class="mf">3.</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">q</span><span class="p">))</span><span class="o">*</span><span class="n">Lhy</span><span class="o">/</span><span class="n">M</span>  \
            <span class="o">+</span> <span class="n">v</span><span class="o">**</span><span class="mi">6</span><span class="o">*</span><span class="p">(</span><span class="n">S1</span><span class="o">*</span><span class="n">S1hy</span><span class="o">-</span><span class="mf">3.</span><span class="o">*</span><span class="n">S1</span><span class="o">*</span><span class="n">ct1</span><span class="o">*</span><span class="n">Lhy</span><span class="o">-</span><span class="mf">3.</span><span class="o">*</span><span class="n">S2</span><span class="o">*</span><span class="n">ct2</span><span class="o">*</span><span class="n">Lhy</span><span class="o">/</span><span class="n">q</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">Omega2z</span><span class="o">=</span> <span class="n">eta</span><span class="o">*</span><span class="n">v</span><span class="o">**</span><span class="mi">5</span><span class="o">*</span><span class="p">(</span><span class="mf">2.</span><span class="o">+</span><span class="mf">3.</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">q</span><span class="p">))</span><span class="o">*</span><span class="n">Lhz</span><span class="o">/</span><span class="n">M</span>  \
            <span class="o">+</span> <span class="n">v</span><span class="o">**</span><span class="mi">6</span><span class="o">*</span><span class="p">(</span><span class="n">S1</span><span class="o">*</span><span class="n">S1hz</span><span class="o">-</span><span class="mf">3.</span><span class="o">*</span><span class="n">S1</span><span class="o">*</span><span class="n">ct1</span><span class="o">*</span><span class="n">Lhz</span><span class="o">-</span><span class="mf">3.</span><span class="o">*</span><span class="n">S2</span><span class="o">*</span><span class="n">ct2</span><span class="o">*</span><span class="n">Lhz</span><span class="o">/</span><span class="n">q</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>

    <span class="n">dS2hxdt</span><span class="o">=</span> <span class="n">Omega2y</span><span class="o">*</span><span class="n">S2hz</span> <span class="o">-</span> <span class="n">Omega2z</span><span class="o">*</span><span class="n">S2hy</span>
    <span class="n">dS2hydt</span><span class="o">=</span> <span class="n">Omega2z</span><span class="o">*</span><span class="n">S2hx</span> <span class="o">-</span> <span class="n">Omega2x</span><span class="o">*</span><span class="n">S2hz</span>
    <span class="n">dS2hzdt</span><span class="o">=</span> <span class="n">Omega2x</span><span class="o">*</span><span class="n">S2hy</span> <span class="o">-</span> <span class="n">Omega2y</span><span class="o">*</span><span class="n">S2hx</span>

    <span class="c"># Conservation of angular momentum</span>
    <span class="n">dLhxdt</span><span class="o">=</span> <span class="o">-</span><span class="mf">1.</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="p">(</span><span class="n">S1</span><span class="o">*</span><span class="n">dS1hxdt</span><span class="o">+</span><span class="n">S2</span><span class="o">*</span><span class="n">dS2hxdt</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">eta</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">dLhydt</span><span class="o">=</span> <span class="o">-</span><span class="mf">1.</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="p">(</span><span class="n">S1</span><span class="o">*</span><span class="n">dS1hydt</span><span class="o">+</span><span class="n">S2</span><span class="o">*</span><span class="n">dS2hydt</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">eta</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">dLhzdt</span><span class="o">=</span> <span class="o">-</span><span class="mf">1.</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="p">(</span><span class="n">S1</span><span class="o">*</span><span class="n">dS1hzdt</span><span class="o">+</span><span class="n">S2</span><span class="o">*</span><span class="n">dS2hzdt</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">eta</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="c"># Radiation reaction</span>
    <span class="n">quadrupole_formula</span><span class="o">=</span><span class="bp">False</span>
    <span class="k">if</span> <span class="n">quadrupole_formula</span><span class="p">:</span>
        <span class="n">dvdt</span><span class="o">=</span> <span class="p">(</span><span class="mf">32.</span><span class="o">*</span><span class="n">eta</span><span class="o">*</span><span class="n">v</span><span class="o">**</span><span class="mi">9</span><span class="o">/</span><span class="p">(</span><span class="mf">5.</span><span class="o">*</span><span class="n">M</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dvdt</span><span class="o">=</span> <span class="p">(</span><span class="mf">32.</span><span class="o">*</span><span class="n">eta</span><span class="o">*</span><span class="n">v</span><span class="o">**</span><span class="mi">9</span><span class="o">/</span><span class="p">(</span><span class="mf">5.</span><span class="o">*</span><span class="n">M</span><span class="p">))</span><span class="o">*</span> <span class="p">(</span> <span class="mf">1.</span>                               \
            <span class="o">-</span> <span class="n">v</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span> <span class="p">(</span><span class="mf">743.</span><span class="o">+</span><span class="mf">924.</span><span class="o">*</span><span class="n">eta</span><span class="p">)</span><span class="o">/</span><span class="mf">336.</span>                                \
            <span class="o">+</span> <span class="n">v</span><span class="o">**</span><span class="mi">3</span><span class="o">*</span> <span class="p">(</span><span class="mf">4.</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>                                           \
                     <span class="o">-</span> <span class="n">chi1</span><span class="o">*</span><span class="n">ct1</span><span class="o">*</span><span class="p">(</span><span class="mf">113.</span><span class="o">*</span><span class="n">m1</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="mf">12.</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mf">25.</span><span class="o">*</span><span class="n">eta</span><span class="o">/</span><span class="mf">4.</span> <span class="p">)</span>   \
                     <span class="o">-</span> <span class="n">chi2</span><span class="o">*</span><span class="n">ct2</span><span class="o">*</span><span class="p">(</span><span class="mf">113.</span><span class="o">*</span><span class="n">m2</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="mf">12.</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mf">25.</span><span class="o">*</span><span class="n">eta</span><span class="o">/</span><span class="mf">4.</span> <span class="p">))</span>  \
            <span class="o">+</span> <span class="n">v</span><span class="o">**</span><span class="mi">4</span><span class="o">*</span> <span class="p">(</span><span class="mf">34103.</span><span class="o">/</span><span class="mf">18144.</span> <span class="o">+</span> <span class="mf">13661.</span><span class="o">*</span><span class="n">eta</span><span class="o">/</span><span class="mf">2016.</span> <span class="o">+</span> <span class="mf">59.</span><span class="o">*</span><span class="n">eta</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mf">18.</span>  \
                     <span class="o">+</span> <span class="n">eta</span><span class="o">*</span><span class="n">chi1</span><span class="o">*</span><span class="n">chi2</span><span class="o">*</span> <span class="p">(</span><span class="mf">721.</span><span class="o">*</span><span class="n">ct1</span><span class="o">*</span><span class="n">ct2</span> <span class="o">-</span> <span class="mf">247.</span><span class="o">*</span><span class="n">ct12</span><span class="p">)</span> <span class="o">/</span><span class="mf">48.</span>   \
                     <span class="o">+</span> <span class="p">((</span><span class="n">m1</span><span class="o">*</span><span class="n">chi1</span><span class="o">/</span><span class="n">M</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mf">719.</span><span class="o">*</span><span class="n">ct1</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="mf">233.</span><span class="p">))</span><span class="o">/</span><span class="mf">96.</span>        \
                     <span class="o">+</span> <span class="p">((</span><span class="n">m2</span><span class="o">*</span><span class="n">chi2</span><span class="o">/</span><span class="n">M</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mf">719.</span><span class="o">*</span><span class="n">ct2</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="mf">233.</span><span class="p">))</span><span class="o">/</span><span class="mf">96.</span><span class="p">)</span>       \
            <span class="o">-</span> <span class="n">v</span><span class="o">**</span><span class="mi">5</span><span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="mf">4159.</span><span class="o">+</span><span class="mf">15876.</span><span class="o">*</span><span class="n">eta</span><span class="p">)</span><span class="o">/</span><span class="mf">672.</span>                       \
            <span class="o">+</span> <span class="n">v</span><span class="o">**</span><span class="mi">6</span><span class="o">*</span> <span class="p">(</span><span class="mf">16447322263.</span><span class="o">/</span><span class="mf">139708800.</span> <span class="o">+</span> <span class="mf">16.</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mf">3.</span>          \
                     <span class="o">-</span><span class="mf">1712.</span><span class="o">*</span><span class="p">(</span><span class="mf">0.5772156649</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">4.</span><span class="o">*</span><span class="n">v</span><span class="p">))</span><span class="o">/</span><span class="mf">105.</span>            \
                     <span class="o">+</span><span class="p">(</span><span class="mf">451.</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mf">48.</span> <span class="o">-</span> <span class="mf">56198689.</span><span class="o">/</span><span class="mf">217728.</span><span class="p">)</span><span class="o">*</span><span class="n">eta</span>       \
                     <span class="o">+</span><span class="mf">541.</span><span class="o">*</span><span class="n">eta</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mf">896.</span> <span class="o">-</span> <span class="mi">5605</span><span class="o">*</span><span class="n">eta</span><span class="o">**</span><span class="mi">3</span><span class="o">/</span><span class="mf">2592.</span><span class="p">)</span>             \
            <span class="o">+</span> <span class="n">v</span><span class="o">**</span><span class="mi">7</span><span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span> <span class="o">-</span><span class="mf">4415.</span><span class="o">/</span><span class="mf">4032.</span> <span class="o">+</span> <span class="mf">358675.</span><span class="o">*</span><span class="n">eta</span><span class="o">/</span><span class="mf">6048.</span>            \
                     <span class="o">+</span> <span class="mf">91495.</span><span class="o">*</span><span class="n">eta</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mf">1512.</span><span class="p">)</span>                             \
            <span class="p">)</span>

    <span class="c"># Integrate in v, not in time</span>
    <span class="n">dtdv</span><span class="o">=</span><span class="mf">1.</span><span class="o">/</span><span class="n">dvdt</span>
    <span class="n">dLhxdv</span><span class="o">=</span><span class="n">dLhxdt</span><span class="o">*</span><span class="n">dtdv</span>
    <span class="n">dLhydv</span><span class="o">=</span><span class="n">dLhydt</span><span class="o">*</span><span class="n">dtdv</span>
    <span class="n">dLhzdv</span><span class="o">=</span><span class="n">dLhzdt</span><span class="o">*</span><span class="n">dtdv</span>
    <span class="n">dS1hxdv</span><span class="o">=</span><span class="n">dS1hxdt</span><span class="o">*</span><span class="n">dtdv</span>
    <span class="n">dS1hydv</span><span class="o">=</span><span class="n">dS1hydt</span><span class="o">*</span><span class="n">dtdv</span>
    <span class="n">dS1hzdv</span><span class="o">=</span><span class="n">dS1hzdt</span><span class="o">*</span><span class="n">dtdv</span>
    <span class="n">dS2hxdv</span><span class="o">=</span><span class="n">dS2hxdt</span><span class="o">*</span><span class="n">dtdv</span>
    <span class="n">dS2hydv</span><span class="o">=</span><span class="n">dS2hydt</span><span class="o">*</span><span class="n">dtdv</span>
    <span class="n">dS2hzdv</span><span class="o">=</span><span class="n">dS2hzdt</span><span class="o">*</span><span class="n">dtdv</span>
    
    <span class="c"># Uncomment if v(t) is needed</span>
    <span class="c">#return dLhxdv, dLhydv, dLhzdv, dS1hxdv, dS1hydv, dS1hzdv, dS2hxdv, dS2hydv, dS2hzdv , dtdv</span>
    
    <span class="k">return</span> <span class="n">dLhxdv</span><span class="p">,</span> <span class="n">dLhydv</span><span class="p">,</span> <span class="n">dLhzdv</span><span class="p">,</span> <span class="n">dS1hxdv</span><span class="p">,</span> <span class="n">dS1hydv</span><span class="p">,</span> <span class="n">dS1hzdv</span><span class="p">,</span> <span class="n">dS2hxdv</span><span class="p">,</span> <span class="n">dS2hydv</span><span class="p">,</span> <span class="n">dS2hzdv</span> 


<span class="k">def</span> <span class="nf">orbav_integrator</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">r_vals</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">):</span>
    
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Single orbit-averaged integration. Integrate the system of ODEs specified in</span>
<span class="sd">    `precession.orbav_eqs`. The initial configuration (at r_vals[0]) is</span>
<span class="sd">    specified through J, xi and S. The components of the unit vectors L, S1 and</span>
<span class="sd">    S2 are returned at the output separations specified by r_vals. The initial</span>
<span class="sd">    values of J and S must be compatible with the initial separation r_vals[0],</span>
<span class="sd">    otherwise an error is raised. Integration is performed in a reference frame</span>
<span class="sd">    in which the z axis is along J and L lies in the x-z plane at the initial</span>
<span class="sd">    separation. Equations are integrated in v (orbital velocity) but outputs are</span>
<span class="sd">    converted to r (separation).</span>

<span class="sd">    Of course, this can only integrate to/from FINITE separations.</span>

<span class="sd">    Bear in mind that orbit-averaged integrations are tpically possible from</span>
<span class="sd">    r&lt;10000; integrations from larger separations take a very long time and can</span>
<span class="sd">    occasionally crash. If q=1, the initial binary configuration is specified</span>
<span class="sd">    through cos(varphi), not S.</span>

<span class="sd">    We recommend to use one of the wrappers `precession.orbit_averaged` and</span>
<span class="sd">    `precession.orbit_angles` provided.</span>
<span class="sd"> </span>
<span class="sd">    **Call:**</span>
<span class="sd">        Lhx_fvals,Lhy_fvals,Lhz_fvals,S1hx_fvals,S1hy_fvals,S1hz_fvals,S2hx_fvals,S2hy_fvals,S2hz_fvals=precession.orbav_integrator(J,xi,S,r_vals,q,S1,S2)</span>

<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `J`: magnitude of the total angular momentum.</span>
<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `S`: magnitude of the total spin.</span>
<span class="sd">    - `r_vals`: binary separation (array).</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `Lhx_vals`: x component of the unit vector L/|L|.</span>
<span class="sd">    - `Lhy_vals`: y component of the unit vector L/|L|.</span>
<span class="sd">    - `Lhz_vals`: z component of the unit vector L/|L|.</span>
<span class="sd">    - `S1hx_vals`: x component of the unit vector S1/|S1|.</span>
<span class="sd">    - `S1hy_vals`: y component of the unit vector S1/|S1|.</span>
<span class="sd">    - `S1hz_vals`: z component of the unit vector S1/|S1|.</span>
<span class="sd">    - `S2hx_vals`: x component of the unit vector S2/|S2|.</span>
<span class="sd">    - `S2hy_vals`: y component of the unit vector S2/|S2|.</span>
<span class="sd">    - `S2hz_vals`: z component of the unit vector S2/|S2|.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="c"># Get initial condition in a cartesian frame. Use the frame aligned to J at the initial separation</span>
    <span class="k">global</span> <span class="n">flags_q1</span>
    <span class="k">if</span> <span class="n">q</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">flags_q1</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span><span class="o">==</span><span class="bp">False</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;[orbav_integrator] Warning q=1: input here is cos(varphi), not S.&quot;</span>
            <span class="n">flags_q1</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span><span class="o">=</span><span class="bp">True</span>
    
    <span class="n">L_vals</span><span class="o">=</span><span class="p">[(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">comp</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span> <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">r_vals</span><span class="p">]</span>
    <span class="n">v_vals</span><span class="o">=</span><span class="p">[(</span><span class="n">M</span><span class="o">/</span><span class="n">comp</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span> <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">r_vals</span><span class="p">]</span>
    <span class="n">Jvec</span><span class="p">,</span><span class="n">Lvec</span><span class="p">,</span><span class="n">S1vec</span><span class="p">,</span><span class="n">S2vec</span><span class="p">,</span><span class="n">dummy</span><span class="o">=</span><span class="n">Jframe_projection</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r_vals</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    
    <span class="n">Lh_initial</span><span class="o">=</span><span class="p">[</span><span class="n">comp</span><span class="o">/</span><span class="n">L_vals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">Lvec</span><span class="p">]</span>  
    <span class="n">S1h_initial</span><span class="o">=</span><span class="p">[</span><span class="n">comp</span><span class="o">/</span><span class="n">S1</span> <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">S1vec</span><span class="p">]</span>
    <span class="n">S2h_initial</span><span class="o">=</span><span class="p">[</span><span class="n">comp</span><span class="o">/</span><span class="n">S2</span> <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">S2vec</span><span class="p">]</span>
    
    <span class="c">#t_initial=0 # Uncomment if v(t) is needed</span>
    <span class="n">allvars_initial</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">Lh_initial</span><span class="p">)</span><span class="o">+</span><span class="nb">list</span><span class="p">(</span><span class="n">S1h_initial</span><span class="p">)</span><span class="o">+</span><span class="nb">list</span><span class="p">(</span><span class="n">S2h_initial</span><span class="p">)</span> <span class="c">#+list([t_initial])</span>

    <span class="c">#Compute these numbers only once</span>
    <span class="n">eta</span><span class="o">=</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> 
    <span class="n">m1</span><span class="o">=</span><span class="n">M</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span>
    <span class="n">m2</span><span class="o">=</span><span class="n">q</span><span class="o">*</span><span class="n">M</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span> 
    <span class="n">chi1</span><span class="o">=</span><span class="n">S1</span><span class="o">/</span><span class="n">m1</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">chi2</span><span class="o">=</span><span class="n">S2</span><span class="o">/</span><span class="n">m2</span><span class="o">**</span><span class="mi">2</span>

    <span class="c"># Actual integration</span>
    <span class="n">res</span> <span class="o">=</span><span class="n">integrate</span><span class="o">.</span><span class="n">odeint</span><span class="p">(</span><span class="n">orbav_eqs</span><span class="p">,</span> <span class="n">allvars_initial</span><span class="p">,</span> <span class="n">v_vals</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">eta</span><span class="p">,</span><span class="n">m1</span><span class="p">,</span><span class="n">m2</span><span class="p">,</span><span class="n">chi1</span><span class="p">,</span><span class="n">chi2</span><span class="p">),</span> <span class="n">mxstep</span><span class="o">=</span><span class="mi">5000000</span><span class="p">,</span> <span class="n">full_output</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">printmessg</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">rtol</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">,</span><span class="n">atol</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">)</span><span class="c">#,tcrit=sing)</span>

    <span class="c"># Unzip output</span>
    <span class="n">traxres</span><span class="o">=</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">res</span><span class="p">)</span>
    <span class="n">Lhx_fvals</span><span class="o">=</span><span class="n">traxres</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">Lhy_fvals</span><span class="o">=</span><span class="n">traxres</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">Lhz_fvals</span><span class="o">=</span><span class="n">traxres</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">S1hx_fvals</span><span class="o">=</span><span class="n">traxres</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">S1hy_fvals</span><span class="o">=</span><span class="n">traxres</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
    <span class="n">S1hz_fvals</span><span class="o">=</span><span class="n">traxres</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
    <span class="n">S2hx_fvals</span><span class="o">=</span><span class="n">traxres</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>
    <span class="n">S2hy_fvals</span><span class="o">=</span><span class="n">traxres</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span>
    <span class="n">S2hz_fvals</span><span class="o">=</span><span class="n">traxres</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span>
    <span class="c">#t_fvals=traxres[9] # Uncomment if v(t) is needed</span>
    
    <span class="k">return</span> <span class="n">Lhx_fvals</span><span class="p">,</span><span class="n">Lhy_fvals</span><span class="p">,</span><span class="n">Lhz_fvals</span><span class="p">,</span><span class="n">S1hx_fvals</span><span class="p">,</span><span class="n">S1hy_fvals</span><span class="p">,</span><span class="n">S1hz_fvals</span><span class="p">,</span><span class="n">S2hx_fvals</span><span class="p">,</span><span class="n">S2hy_fvals</span><span class="p">,</span><span class="n">S2hz_fvals</span>


<span class="k">def</span> <span class="nf">orbit_averaged_single</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">r_vals</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Auxiliary function, see `precession.orbit_averaged`.</span>
<span class="sd"> </span>
<span class="sd">    **Call:**</span>

<span class="sd">        savename=precession.orbit_averaged_single(J,xi,S,r_vals,q,S1,S2)</span>

<span class="sd">    **Parameters:**</span>

<span class="sd">    - `J`: magnitude of the total angular momentum.</span>
<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `S`: magnitude of the total spin.</span>
<span class="sd">    - `r_vals`: binary separation (array).</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `savename`: checkpoint filename.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="k">global</span> <span class="n">flags_q1</span> 
    <span class="k">if</span> <span class="n">q</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">flags_q1</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span><span class="o">==</span><span class="bp">False</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;[orbit_averaged] Warning q=1: Input/output for S is actually cos(varphi)&quot;</span>       
            <span class="n">flags_q1</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span><span class="o">=</span><span class="bp">True</span>
    
    <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s">&quot;mkdir -p &quot;</span><span class="o">+</span><span class="n">storedir</span><span class="p">)</span> 
    <span class="n">savename</span><span class="o">=</span> <span class="n">storedir</span><span class="o">+</span><span class="s">&quot;/orbav_&quot;</span><span class="o">+</span><span class="s">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="nb">max</span><span class="p">(</span><span class="n">r_vals</span><span class="p">),</span><span class="nb">min</span><span class="p">(</span><span class="n">r_vals</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">r_vals</span><span class="p">),</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">)])</span><span class="o">+</span><span class="s">&quot;.dat&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">savename</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">&quot;[orbit_averaged] Transferring binary. Output:&quot;</span><span class="p">,</span> <span class="n">savename</span>
        <span class="n">outfilesave</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">savename</span><span class="p">,</span><span class="s">&quot;w&quot;</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">Lhx_fvals</span><span class="p">,</span><span class="n">Lhy_fvals</span><span class="p">,</span><span class="n">Lhz_fvals</span><span class="p">,</span><span class="n">S1hx_fvals</span><span class="p">,</span><span class="n">S1hy_fvals</span><span class="p">,</span><span class="n">S1hz_fvals</span><span class="p">,</span><span class="n">S2hx_fvals</span><span class="p">,</span><span class="n">S2hy_fvals</span><span class="p">,</span><span class="n">S2hz_fvals</span> <span class="o">=</span> <span class="n">orbav_integrator</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">r_vals</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">r_f</span><span class="p">,</span><span class="n">Lhx</span><span class="p">,</span><span class="n">Lhy</span><span class="p">,</span><span class="n">Lhz</span><span class="p">,</span><span class="n">S1hx</span><span class="p">,</span><span class="n">S1hy</span><span class="p">,</span><span class="n">S1hz</span><span class="p">,</span><span class="n">S2hx</span><span class="p">,</span><span class="n">S2hy</span><span class="p">,</span><span class="n">S2hz</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">r_vals</span><span class="p">,</span><span class="n">Lhx_fvals</span><span class="p">,</span><span class="n">Lhy_fvals</span><span class="p">,</span><span class="n">Lhz_fvals</span><span class="p">,</span><span class="n">S1hx_fvals</span><span class="p">,</span><span class="n">S1hy_fvals</span><span class="p">,</span><span class="n">S1hz_fvals</span><span class="p">,</span><span class="n">S2hx_fvals</span><span class="p">,</span><span class="n">S2hy_fvals</span><span class="p">,</span><span class="n">S2hz_fvals</span><span class="p">):</span>        
            
            <span class="n">L_f</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r_f</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
            <span class="n">J_f</span><span class="o">=</span> <span class="p">((</span><span class="n">L_f</span><span class="o">*</span><span class="n">Lhx</span><span class="o">+</span><span class="n">S1</span><span class="o">*</span><span class="n">S1hx</span><span class="o">+</span><span class="n">S2</span><span class="o">*</span><span class="n">S2hx</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">L_f</span><span class="o">*</span><span class="n">Lhy</span><span class="o">+</span><span class="n">S1</span><span class="o">*</span><span class="n">S1hy</span><span class="o">+</span><span class="n">S2</span><span class="o">*</span><span class="n">S2hy</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">L_f</span><span class="o">*</span><span class="n">Lhz</span><span class="o">+</span><span class="n">S1</span><span class="o">*</span><span class="n">S1hz</span><span class="o">+</span><span class="n">S2</span><span class="o">*</span><span class="n">S2hz</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="p">)</span><span class="o">**</span><span class="mf">0.5</span> 
            <span class="n">xi_f</span><span class="o">=</span> <span class="p">((</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">S1</span><span class="o">*</span><span class="p">(</span><span class="n">Lhx</span><span class="o">*</span><span class="n">S1hx</span><span class="o">+</span><span class="n">Lhy</span><span class="o">*</span><span class="n">S1hy</span><span class="o">+</span><span class="n">Lhz</span><span class="o">*</span><span class="n">S1hz</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="o">**-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">S2</span><span class="o">*</span><span class="p">(</span><span class="n">Lhx</span><span class="o">*</span><span class="n">S2hx</span><span class="o">+</span><span class="n">Lhy</span><span class="o">*</span><span class="n">S2hy</span><span class="o">+</span><span class="n">Lhz</span><span class="o">*</span><span class="n">S2hz</span><span class="p">))</span><span class="o">*</span><span class="n">M</span><span class="o">**-</span><span class="mi">2</span>
            <span class="n">S_f</span><span class="o">=</span> <span class="p">((</span><span class="n">S1</span><span class="o">*</span><span class="n">S1hx</span><span class="o">+</span><span class="n">S2</span><span class="o">*</span><span class="n">S2hx</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">S1</span><span class="o">*</span><span class="n">S1hy</span><span class="o">+</span><span class="n">S2</span><span class="o">*</span><span class="n">S2hy</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">S1</span><span class="o">*</span><span class="n">S1hz</span><span class="o">+</span><span class="n">S2</span><span class="o">*</span><span class="n">S2hz</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="p">)</span><span class="o">**</span><span class="mf">0.5</span>
            
            <span class="k">if</span> <span class="n">q</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">A1</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">J_f</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">L_f</span><span class="o">-</span><span class="n">S_f</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">A2</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">L_f</span><span class="o">+</span><span class="n">S_f</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">J_f</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">A3</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">S_f</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">A4</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">S1</span><span class="o">+</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S_f</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> 
                <span class="n">cosvarphi</span> <span class="o">=</span> <span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">J_f</span><span class="o">*</span><span class="n">S_f</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">S1hz</span><span class="o">*</span><span class="n">S1</span><span class="o">-</span><span class="p">(</span><span class="n">S_f</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">S1</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">J_f</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L_f</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">S_f</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="n">A1</span><span class="o">*</span><span class="n">A2</span><span class="o">*</span><span class="n">A3</span><span class="o">*</span><span class="n">A4</span><span class="p">)</span>
                <span class="n">S_f</span><span class="o">=</span><span class="n">cosvarphi</span>
                
            <span class="n">outfilesave</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">r_f</span><span class="p">)</span><span class="o">+</span><span class="s">&quot; &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">J_f</span><span class="p">)</span><span class="o">+</span><span class="s">&quot; &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">xi_f</span><span class="p">)</span><span class="o">+</span><span class="s">&quot; &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">S_f</span><span class="p">)</span><span class="o">+</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
        <span class="n">outfilesave</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="c">#else:</span>
    <span class="c">#    print &quot;[evolve_J_infinity] Skipping. Output:&quot;, savename</span>
    
    <span class="k">return</span> <span class="n">savename</span>


<span class="k">def</span> <span class="nf">orbit_averaged</span><span class="p">(</span><span class="n">J_vals</span><span class="p">,</span><span class="n">xi_vals</span><span class="p">,</span><span class="n">S_vals</span><span class="p">,</span><span class="n">r_vals</span><span class="p">,</span><span class="n">q_vals</span><span class="p">,</span><span class="n">S1_vals</span><span class="p">,</span><span class="n">S2_vals</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Wrapper of `precession.orbav_integrator` to enable parallelization through</span>
<span class="sd">    the python parmap module; the number of available cores can be specified</span>
<span class="sd">    using the integer global variable `precession.CPUs` (all available cores</span>
<span class="sd">    will be used by default). Input/outputs are given in terms of J, xi and S.</span>
<span class="sd">    Evolve a sequence of binaries with the different q, S1,S2, xi and initial</span>
<span class="sd">    values of J and S; save outputs at the SAME separations r_vals. The initial</span>
<span class="sd">    configuration must be compatible with r_vals[0]. Output is a 2D array, where</span>
<span class="sd">    e.g. J_vals[0] is the first binary (1D array at all output separations) and</span>
<span class="sd">    J_vals[0][0] is the first binary at the first output separation (this is a</span>
<span class="sd">    scalar).</span>

<span class="sd">    Checkpointing is implemented: results are stored in `precession.storedir`.</span>
<span class="sd"> </span>
<span class="sd">    **Call:**</span>

<span class="sd">        Jf_vals,xif_vals,Sf_vals=precession.orbit_averaged(J_vals,xi_vals,S_vals,r_vals,q,S1,S2)</span>

<span class="sd">    **Parameters:**</span>

<span class="sd">    - `Ji_vals`: initial condition for J (array).</span>
<span class="sd">    - `xii_vals`: initial condition for xi (array).</span>
<span class="sd">    - `Si_vals`: initial condition for S (array).</span>
<span class="sd">    - `r_vals`: binary separation (array).</span>
<span class="sd">    - `q_vals`: binary mass ratio. Must be q&lt;=1 (array).</span>
<span class="sd">    - `S1_vals`: spin magnitude of the primary BH (array).</span>
<span class="sd">    - `S2_vals`: spin magnitude of the secondary BH (array).</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `Jf_vals`: solutions for J (2D array).</span>
<span class="sd">    - `xif_vals`: solutions for xi (2D array).</span>
<span class="sd">    - `Sf_vals`: solutions for S (2D array).</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="k">global</span> <span class="n">CPUs</span>
    
    <span class="n">single_flag</span><span class="o">=</span><span class="bp">False</span>
    <span class="k">try</span><span class="p">:</span> <span class="c">#Convert float to array if you&#39;re evolving just one binary</span>
        <span class="nb">len</span><span class="p">(</span><span class="n">q_vals</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">J_vals</span><span class="o">=</span><span class="p">[</span><span class="n">J_vals</span><span class="p">]</span>
        <span class="n">xi_vals</span><span class="o">=</span><span class="p">[</span><span class="n">xi_vals</span><span class="p">]</span>
        <span class="n">S_vals</span><span class="o">=</span><span class="p">[</span><span class="n">S_vals</span><span class="p">]</span>
        <span class="n">q_vals</span><span class="o">=</span><span class="p">[</span><span class="n">q_vals</span><span class="p">]</span>
        <span class="n">S1_vals</span><span class="o">=</span><span class="p">[</span><span class="n">S1_vals</span><span class="p">]</span>
        <span class="n">S2_vals</span><span class="o">=</span><span class="p">[</span><span class="n">S2_vals</span><span class="p">]</span>
        <span class="n">single_flag</span><span class="o">=</span><span class="bp">True</span>
    <span class="k">try</span><span class="p">:</span> <span class="c"># Set default</span>
        <span class="n">CPUs</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">CPUs</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">print</span> <span class="s">&quot;[orbit_averaged] Default parallel computation&quot;</span>
    
    <span class="c"># Parallelization</span>
    <span class="k">if</span> <span class="n">CPUs</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="c"># Run on all cpus on the current machine! (default option)</span>
        <span class="n">filelist</span><span class="o">=</span><span class="n">parmap</span><span class="o">.</span><span class="n">starmap</span><span class="p">(</span><span class="n">orbit_averaged_single</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">J_vals</span><span class="p">,</span><span class="n">xi_vals</span><span class="p">,</span><span class="n">S_vals</span><span class="p">,[</span><span class="n">r_vals</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q_vals</span><span class="p">))],</span><span class="n">q_vals</span><span class="p">,</span><span class="n">S1_vals</span><span class="p">,</span><span class="n">S2_vals</span><span class="p">),</span><span class="n">parallel</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> 
    <span class="k">elif</span> <span class="n">CPUs</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="c"># 1 cpus done by explicitely removing parallelization</span>
        <span class="n">filelist</span><span class="o">=</span><span class="n">parmap</span><span class="o">.</span><span class="n">starmap</span><span class="p">(</span><span class="n">orbit_averaged_single</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">J_vals</span><span class="p">,</span><span class="n">xi_vals</span><span class="p">,</span><span class="n">S_vals</span><span class="p">,[</span><span class="n">r_vals</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q_vals</span><span class="p">))],</span><span class="n">q_vals</span><span class="p">,</span><span class="n">S1_vals</span><span class="p">,</span><span class="n">S2_vals</span><span class="p">),</span><span class="n">parallel</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> 
    <span class="k">else</span><span class="p">:</span> <span class="c"># Run on a given number of CPUs        </span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">CPUs</span><span class="p">)</span>
        <span class="n">filelist</span><span class="o">=</span><span class="n">parmap</span><span class="o">.</span><span class="n">starmap</span><span class="p">(</span><span class="n">orbit_averaged_single</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">J_vals</span><span class="p">,</span><span class="n">xi_vals</span><span class="p">,</span><span class="n">S_vals</span><span class="p">,[</span><span class="n">r_vals</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q_vals</span><span class="p">))],</span><span class="n">q_vals</span><span class="p">,</span><span class="n">S1_vals</span><span class="p">,</span><span class="n">S2_vals</span><span class="p">),</span><span class="n">pool</span><span class="o">=</span><span class="n">p</span><span class="p">)</span> 

    <span class="n">J_fvals</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">S_fvals</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">xi_vals</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="nb">file</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">filelist</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">&quot;[orbit_averaged] Reading:&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="nb">file</span>
        <span class="n">dummy</span><span class="p">,</span><span class="n">J_f</span><span class="p">,</span><span class="n">xi_f</span><span class="p">,</span><span class="n">S_f</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="nb">file</span><span class="p">,</span><span class="n">unpack</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">J_fvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">J_f</span><span class="p">)</span>
        <span class="n">xi_vals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xi_f</span><span class="p">)</span>
        <span class="n">S_fvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">S_f</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">single_flag</span><span class="o">==</span><span class="bp">True</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">J_fvals</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xi_vals</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">S_fvals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">J_fvals</span><span class="p">,</span> <span class="n">xi_vals</span><span class="p">,</span> <span class="n">S_fvals</span>


<span class="k">def</span> <span class="nf">orbit_angles_single</span><span class="p">(</span><span class="n">theta1_i</span><span class="p">,</span><span class="n">theta2_i</span><span class="p">,</span><span class="n">deltaphi_i</span><span class="p">,</span><span class="n">r_vals</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Auxiliary function, see `precession.orbit_angles`.</span>
<span class="sd"> </span>
<span class="sd">    **Call:**</span>

<span class="sd">        savename=precession.orbit_angles_single(theta1_i,theta2_i,deltaphi_i,r_vals,q,S1,S2)</span>

<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `theta1_i`: initial condition for theta1.</span>
<span class="sd">    - `theta2_i`: initial condition for theta2</span>
<span class="sd">    - `deltaphi_i`: initial condition for deltaphi.</span>
<span class="sd">    - `r_vals`: binary separation (array).</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `savename`: checkpoint filename.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s">&quot;mkdir -p &quot;</span><span class="o">+</span><span class="n">storedir</span><span class="p">)</span> 
    <span class="n">savename</span><span class="o">=</span> <span class="n">storedir</span><span class="o">+</span><span class="s">&quot;/orbang_&quot;</span><span class="o">+</span><span class="s">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">(</span><span class="n">theta1_i</span><span class="p">,</span><span class="n">theta2_i</span><span class="p">,</span><span class="n">deltaphi_i</span><span class="p">,</span><span class="nb">max</span><span class="p">(</span><span class="n">r_vals</span><span class="p">),</span><span class="nb">min</span><span class="p">(</span><span class="n">r_vals</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">r_vals</span><span class="p">),</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">)])</span><span class="o">+</span><span class="s">&quot;.dat&quot;</span>
        
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">savename</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">&quot;[orbit_angles] Transferring binary. Output:&quot;</span><span class="p">,</span> <span class="n">savename</span>
        <span class="n">outfilesave</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">savename</span><span class="p">,</span><span class="s">&quot;w&quot;</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
       
        <span class="c"># Step 1. Get xi and J for each intial angle. Keep S now</span>
        <span class="n">xi_i</span><span class="p">,</span><span class="n">J_i</span><span class="p">,</span><span class="n">S_i</span><span class="o">=</span> <span class="n">from_the_angles</span><span class="p">(</span><span class="n">theta1_i</span><span class="p">,</span><span class="n">theta2_i</span><span class="p">,</span><span class="n">deltaphi_i</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r_vals</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> 
        <span class="c"># Note that S_i is actually cos(varphi_i) when q=1. </span>
        
        <span class="c"># Step 2. Evolve ODE system</span>
        <span class="n">Lhx_fvals</span><span class="p">,</span><span class="n">Lhy_fvals</span><span class="p">,</span><span class="n">Lhz_fvals</span><span class="p">,</span><span class="n">S1hx_fvals</span><span class="p">,</span><span class="n">S1hy_fvals</span><span class="p">,</span><span class="n">S1hz_fvals</span><span class="p">,</span><span class="n">S2hx_fvals</span><span class="p">,</span><span class="n">S2hy_fvals</span><span class="p">,</span><span class="n">S2hz_fvals</span> <span class="o">=</span> <span class="n">orbav_integrator</span><span class="p">(</span><span class="n">J_i</span><span class="p">,</span><span class="n">xi_i</span><span class="p">,</span><span class="n">S_i</span><span class="p">,</span><span class="n">r_vals</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">r_f</span><span class="p">,</span><span class="n">Lhx</span><span class="p">,</span><span class="n">Lhy</span><span class="p">,</span><span class="n">Lhz</span><span class="p">,</span><span class="n">S1hx</span><span class="p">,</span><span class="n">S1hy</span><span class="p">,</span><span class="n">S1hz</span><span class="p">,</span><span class="n">S2hx</span><span class="p">,</span><span class="n">S2hy</span><span class="p">,</span><span class="n">S2hz</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">r_vals</span><span class="p">,</span><span class="n">Lhx_fvals</span><span class="p">,</span><span class="n">Lhy_fvals</span><span class="p">,</span><span class="n">Lhz_fvals</span><span class="p">,</span><span class="n">S1hx_fvals</span><span class="p">,</span><span class="n">S1hy_fvals</span><span class="p">,</span><span class="n">S1hz_fvals</span><span class="p">,</span><span class="n">S2hx_fvals</span><span class="p">,</span><span class="n">S2hy_fvals</span><span class="p">,</span><span class="n">S2hz_fvals</span><span class="p">):</span>        
            
            <span class="n">L_f</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r_f</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
            <span class="n">S_f</span><span class="o">=</span> <span class="p">((</span><span class="n">S1</span><span class="o">*</span><span class="n">S1hx</span><span class="o">+</span><span class="n">S2</span><span class="o">*</span><span class="n">S2hx</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">S1</span><span class="o">*</span><span class="n">S1hy</span><span class="o">+</span><span class="n">S2</span><span class="o">*</span><span class="n">S2hy</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">S1</span><span class="o">*</span><span class="n">S1hz</span><span class="o">+</span><span class="n">S2</span><span class="o">*</span><span class="n">S2hz</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="p">)</span><span class="o">**</span><span class="mf">0.5</span>
            <span class="n">J_f</span><span class="o">=</span> <span class="p">((</span><span class="n">L_f</span><span class="o">*</span><span class="n">Lhx</span><span class="o">+</span><span class="n">S1</span><span class="o">*</span><span class="n">S1hx</span><span class="o">+</span><span class="n">S2</span><span class="o">*</span><span class="n">S2hx</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">L_f</span><span class="o">*</span><span class="n">Lhy</span><span class="o">+</span><span class="n">S1</span><span class="o">*</span><span class="n">S1hy</span><span class="o">+</span><span class="n">S2</span><span class="o">*</span><span class="n">S2hy</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">L_f</span><span class="o">*</span><span class="n">Lhz</span><span class="o">+</span><span class="n">S1</span><span class="o">*</span><span class="n">S1hz</span><span class="o">+</span><span class="n">S2</span><span class="o">*</span><span class="n">S2hz</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="p">)</span><span class="o">**</span><span class="mf">0.5</span> 
            <span class="n">xi_f</span><span class="o">=</span> <span class="p">((</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">S1</span><span class="o">*</span><span class="p">(</span><span class="n">Lhx</span><span class="o">*</span><span class="n">S1hx</span><span class="o">+</span><span class="n">Lhy</span><span class="o">*</span><span class="n">S1hy</span><span class="o">+</span><span class="n">Lhz</span><span class="o">*</span><span class="n">S1hz</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="o">**-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">S2</span><span class="o">*</span><span class="p">(</span><span class="n">Lhx</span><span class="o">*</span><span class="n">S2hx</span><span class="o">+</span><span class="n">Lhy</span><span class="o">*</span><span class="n">S2hy</span><span class="o">+</span><span class="n">Lhz</span><span class="o">*</span><span class="n">S2hz</span><span class="p">))</span><span class="o">*</span><span class="n">M</span><span class="o">**-</span><span class="mi">2</span>
            <span class="k">if</span> <span class="n">q</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">A1</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">J_f</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">L_f</span><span class="o">-</span><span class="n">S_f</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">A2</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">L_f</span><span class="o">+</span><span class="n">S_f</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">J_f</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">A3</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">S_f</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">A4</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">S1</span><span class="o">+</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S_f</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>  
                <span class="n">cosvarphi</span> <span class="o">=</span> <span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">J_f</span><span class="o">*</span><span class="n">S_f</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">S1hz</span><span class="o">*</span><span class="n">S1</span><span class="o">-</span><span class="p">(</span><span class="n">S_f</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">S1</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">J_f</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L_f</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">S_f</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="n">A1</span><span class="o">*</span><span class="n">A2</span><span class="o">*</span><span class="n">A3</span><span class="o">*</span><span class="n">A4</span><span class="p">)</span>
                <span class="n">S_f</span><span class="o">=</span><span class="n">cosvarphi</span>

            <span class="c"># Step 3. Back to theta1, theta2, deltaphi</span>
            <span class="n">theta1_f</span><span class="p">,</span><span class="n">theta2_f</span><span class="p">,</span><span class="n">deltaphi_f</span><span class="p">,</span><span class="n">dummy</span><span class="o">=</span> <span class="n">parametric_angles</span><span class="p">(</span><span class="n">S_f</span><span class="p">,</span><span class="n">J_f</span><span class="p">,</span><span class="n">xi_f</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r_f</span><span class="p">)</span>
            
            <span class="c"># Step 4. Track the precessional phase to set the sign of DeltaPhi. In symbols, the sign of DeltaPhi must be the sign of</span>
            <span class="c">#L dot [ ( S1 - (S1 dot L) dot L ) cross ( S2 - (S2 dot L) dot L ) ]</span>
            <span class="n">S1px</span><span class="o">=</span><span class="p">(</span><span class="n">S1hx</span><span class="o">-</span><span class="n">theta1_f</span><span class="o">*</span><span class="n">Lhx</span><span class="p">)</span>
            <span class="n">S1py</span><span class="o">=</span><span class="p">(</span><span class="n">S1hy</span><span class="o">-</span><span class="n">theta1_f</span><span class="o">*</span><span class="n">Lhy</span><span class="p">)</span>
            <span class="n">S1pz</span><span class="o">=</span><span class="p">(</span><span class="n">S1hz</span><span class="o">-</span><span class="n">theta1_f</span><span class="o">*</span><span class="n">Lhz</span><span class="p">)</span>
            <span class="n">S2px</span><span class="o">=</span><span class="p">(</span><span class="n">S2hx</span><span class="o">-</span><span class="n">theta2_f</span><span class="o">*</span><span class="n">Lhx</span><span class="p">)</span>
            <span class="n">S2py</span><span class="o">=</span><span class="p">(</span><span class="n">S2hy</span><span class="o">-</span><span class="n">theta2_f</span><span class="o">*</span><span class="n">Lhy</span><span class="p">)</span>
            <span class="n">S2pz</span><span class="o">=</span><span class="p">(</span><span class="n">S2hz</span><span class="o">-</span><span class="n">theta2_f</span><span class="o">*</span><span class="n">Lhz</span><span class="p">)</span>
            <span class="n">proj</span><span class="o">=</span><span class="n">Lhx</span><span class="o">*</span><span class="p">(</span><span class="n">S1py</span><span class="o">*</span><span class="n">S2pz</span><span class="o">-</span><span class="n">S1pz</span><span class="o">*</span><span class="n">S2py</span><span class="p">)</span> <span class="o">+</span> <span class="n">Lhy</span><span class="o">*</span><span class="p">(</span><span class="n">S1pz</span><span class="o">*</span><span class="n">S2px</span><span class="o">-</span><span class="n">S1px</span><span class="o">*</span><span class="n">S2pz</span><span class="p">)</span> <span class="o">+</span> <span class="n">Lhz</span><span class="o">*</span><span class="p">(</span><span class="n">S1px</span><span class="o">*</span><span class="n">S2py</span><span class="o">-</span><span class="n">S1py</span><span class="o">*</span><span class="n">S2px</span><span class="p">)</span>
            <span class="n">deltaphi_f</span><span class="o">*=</span><span class="n">math</span><span class="o">.</span><span class="n">copysign</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="n">proj</span><span class="p">)</span>

            <span class="c"># Step 4. Store data            </span>
            <span class="n">outfilesave</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">r_f</span><span class="p">)</span><span class="o">+</span><span class="s">&quot; &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">theta1_f</span><span class="p">)</span><span class="o">+</span><span class="s">&quot; &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">theta2_f</span><span class="p">)</span><span class="o">+</span><span class="s">&quot; &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">deltaphi_f</span><span class="p">)</span><span class="o">+</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
        <span class="n">outfilesave</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="c">#else:</span>
    <span class="c">#    print &quot;[evolve_angles] Skipping. Output:&quot;, savename</span>
    
    <span class="k">return</span> <span class="n">savename</span>


<span class="k">def</span> <span class="nf">orbit_angles</span><span class="p">(</span><span class="n">theta1_vals</span><span class="p">,</span><span class="n">theta2_vals</span><span class="p">,</span><span class="n">deltaphi_vals</span><span class="p">,</span><span class="n">r_vals</span><span class="p">,</span><span class="n">q_vals</span><span class="p">,</span><span class="n">S1_vals</span><span class="p">,</span><span class="n">S2_vals</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Wrapper of `precession.orbav_integrator` to enable parallelization through</span>
<span class="sd">    the python parmap module; the number of available cores can be specified</span>
<span class="sd">    using the integer global variable `precession.CPUs` (all available cores</span>
<span class="sd">    will be used by default). Input/outputs are given in terms of the angles</span>
<span class="sd">    theta1, theta2 and deltaphi. Evolve a sequence of binaries with the</span>
<span class="sd">    different q, S1, S2 and initial values for the angles; save outputs at SAME</span>
<span class="sd">    separations r_vals. Output is a 2D array, where e.g. theta1_vals[0] is the</span>
<span class="sd">    first binary (1D array at all output separations) and theta1_vals[0][0] is</span>
<span class="sd">    the first binary at the first output separation (this is a scalar).</span>

<span class="sd">    Checkpointing is implemented: results are stored in `precession.storedir`.</span>
<span class="sd"> </span>
<span class="sd">    **Call:**</span>

<span class="sd">        theta1f_vals,theta2f_vals,deltaphif_vals=precession.orbit_angles(theta1i_vals,theta2i_vals,deltaphii_vals,r_vals,q_vals,S1_vals,S2_vals)</span>
<span class="sd">         </span>
<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `theta1i_vals`: initial condition for theta1 (array).</span>
<span class="sd">    - `theta2i_vals`: initial condition for theta2 (array).</span>
<span class="sd">    - `deltaphii_vals`: initial condition for deltaphi (array).</span>
<span class="sd">    - `r_vals`: binary separation (array).</span>
<span class="sd">    - `q_vals`: binary mass ratio. Must be q&lt;=1 (array).</span>
<span class="sd">    - `S1_vals`: spin magnitude of the primary BH (array).</span>
<span class="sd">    - `S2_vals`: spin magnitude of the secondary BH (array).</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `theta1f_vals`: solutions for theta1 (2D array).</span>
<span class="sd">    - `theta2f_vals`: solutions for theta2 (2D array).</span>
<span class="sd">    - `deltaphif_vals`: solutions for deltaphi (2D array).</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">global</span> <span class="n">CPUs</span>
    <span class="n">flag</span><span class="o">=</span><span class="bp">False</span>

    <span class="k">try</span><span class="p">:</span> <span class="c">#Convert float to array, if you&#39;re evolving just one binary</span>
        <span class="nb">len</span><span class="p">(</span><span class="n">theta1_vals</span><span class="p">)</span>
        <span class="nb">len</span><span class="p">(</span><span class="n">theta1_vals</span><span class="p">)</span>
        <span class="nb">len</span><span class="p">(</span><span class="n">deltaphi_vals</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">flag</span><span class="o">=</span><span class="bp">True</span>
        <span class="n">theta1_vals</span><span class="o">=</span><span class="p">[</span><span class="n">theta1_vals</span><span class="p">]</span>
        <span class="n">theta2_vals</span><span class="o">=</span><span class="p">[</span><span class="n">theta2_vals</span><span class="p">]</span>
        <span class="n">deltaphi_vals</span><span class="o">=</span><span class="p">[</span><span class="n">deltaphi_vals</span><span class="p">]</span>
        <span class="n">q_vals</span><span class="o">=</span><span class="p">[</span><span class="n">q_vals</span><span class="p">]</span>
        <span class="n">S1_vals</span><span class="o">=</span><span class="p">[</span><span class="n">S1_vals</span><span class="p">]</span>
        <span class="n">S2_vals</span><span class="o">=</span><span class="p">[</span><span class="n">S2_vals</span><span class="p">]</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">CPUs</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">CPUs</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">print</span> <span class="s">&quot;[orbit_angles] Default parallel computation&quot;</span>

    <span class="n">loopflag</span><span class="o">=</span><span class="bp">True</span>
    <span class="k">while</span> <span class="n">loopflag</span><span class="p">:</span> <span class="c"># Restart is some of the cores crashed. This happend if you run too many things on too many different machines. Nevermind, trash the file and do it again.</span>
        <span class="n">loopflag</span><span class="o">=</span><span class="bp">False</span>

        <span class="c">#Parallelization... python is cool indeed</span>
        <span class="k">if</span> <span class="n">CPUs</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="c">#Run on all cpus on the current machine! (default option)</span>
            <span class="n">filelist</span><span class="o">=</span><span class="n">parmap</span><span class="o">.</span><span class="n">starmap</span><span class="p">(</span><span class="n">orbit_angles_single</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">theta1_vals</span><span class="p">,</span><span class="n">theta2_vals</span><span class="p">,</span><span class="n">deltaphi_vals</span><span class="p">,[</span><span class="n">r_vals</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q_vals</span><span class="p">))],</span><span class="n">q_vals</span><span class="p">,</span><span class="n">S1_vals</span><span class="p">,</span><span class="n">S2_vals</span><span class="p">),</span><span class="n">parallel</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> 
        <span class="k">elif</span> <span class="n">CPUs</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="c">#1 cpus done by explicitely removing parallelization</span>
            <span class="n">filelist</span><span class="o">=</span><span class="n">parmap</span><span class="o">.</span><span class="n">starmap</span><span class="p">(</span><span class="n">orbit_angles_single</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">theta1_vals</span><span class="p">,</span><span class="n">theta2_vals</span><span class="p">,</span><span class="n">deltaphi_vals</span><span class="p">,[</span><span class="n">r_vals</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q_vals</span><span class="p">))],</span><span class="n">q_vals</span><span class="p">,</span><span class="n">S1_vals</span><span class="p">,</span><span class="n">S2_vals</span><span class="p">),</span><span class="n">parallel</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> 
        <span class="k">else</span><span class="p">:</span> <span class="c"># Run on a given number of CPUs        </span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">CPUs</span><span class="p">)</span>
            <span class="n">filelist</span><span class="o">=</span><span class="n">parmap</span><span class="o">.</span><span class="n">starmap</span><span class="p">(</span><span class="n">orbit_angles_single</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">theta1_vals</span><span class="p">,</span><span class="n">theta2_vals</span><span class="p">,</span><span class="n">deltaphi_vals</span><span class="p">,[</span><span class="n">r_vals</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q_vals</span><span class="p">))],</span><span class="n">q_vals</span><span class="p">,</span><span class="n">S1_vals</span><span class="p">,</span><span class="n">S2_vals</span><span class="p">),</span><span class="n">pool</span><span class="o">=</span><span class="n">p</span><span class="p">)</span> 

        <span class="n">theta1_fvals</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">theta2_fvals</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">deltaphi_fvals</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="nb">file</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">filelist</span><span class="p">):</span>
            <span class="k">print</span> <span class="s">&quot;[orbit_angles] Reading:&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="nb">file</span>
            <span class="n">numlines</span><span class="o">=</span><span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">open</span><span class="p">(</span><span class="nb">file</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">numlines</span><span class="o">!=</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">numlines</span><span class="o">!=</span><span class="nb">len</span><span class="p">(</span><span class="n">r_vals</span><span class="p">):</span> <span class="c"># Restar if core(s) crashed</span>
                <span class="k">print</span> <span class="s">&quot;[orbit_angles] Error on file&quot;</span><span class="p">,</span> <span class="nb">file</span><span class="p">,</span><span class="s">&quot;. Jobs are being restarting!!!&quot;</span>
                <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s">&quot;rm &quot;</span><span class="o">+</span><span class="nb">file</span><span class="p">)</span> 
                <span class="n">loopflag</span><span class="o">=</span><span class="bp">True</span>
 
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dummy</span><span class="p">,</span><span class="n">theta1_f</span><span class="p">,</span><span class="n">theta2_f</span><span class="p">,</span><span class="n">deltaphi_f</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="nb">file</span><span class="p">,</span><span class="n">unpack</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                <span class="n">theta1_fvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">theta1_f</span><span class="p">)</span>
                <span class="n">theta2_fvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">theta2_f</span><span class="p">)</span>
                <span class="n">deltaphi_fvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">deltaphi_f</span><span class="p">)</span>        
    <span class="k">if</span> <span class="n">flag</span><span class="o">==</span><span class="bp">True</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">theta1_fvals</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">theta2_fvals</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">deltaphi_fvals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">theta1_fvals</span><span class="p">,</span> <span class="n">theta2_fvals</span><span class="p">,</span> <span class="n">deltaphi_fvals</span>


<span class="k">def</span> <span class="nf">orbit_vectors_single</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">r_vals</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Auxiliary function, see `precession.orbit_vector`.</span>
<span class="sd"> </span>
<span class="sd">    **Call:**</span>

<span class="sd">        savename=precession.orbit_vectors_single(J,xi,S,r_vals,q,S1,S2)</span>

<span class="sd">    **Parameters:**</span>

<span class="sd">    - `J`: magnitude of the total angular momentum.</span>
<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `S`: magnitude of the total spin.</span>
<span class="sd">    - `r_vals`: binary separation (array).</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `savename`: checkpoint filename.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s">&quot;mkdir -p &quot;</span><span class="o">+</span><span class="n">storedir</span><span class="p">)</span> 
    <span class="n">savename</span><span class="o">=</span> <span class="n">storedir</span><span class="o">+</span><span class="s">&quot;/orbvec_&quot;</span><span class="o">+</span><span class="s">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="nb">max</span><span class="p">(</span><span class="n">r_vals</span><span class="p">),</span><span class="nb">min</span><span class="p">(</span><span class="n">r_vals</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">r_vals</span><span class="p">),</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">)])</span><span class="o">+</span><span class="s">&quot;.dat&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">savename</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">&quot;[orbit_vectors] Transferring binary. Output:&quot;</span><span class="p">,</span> <span class="n">savename</span>
        <span class="n">outfilesave</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">savename</span><span class="p">,</span><span class="s">&quot;w&quot;</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
       
        <span class="n">Lhx_fvals</span><span class="p">,</span><span class="n">Lhy_fvals</span><span class="p">,</span><span class="n">Lhz_fvals</span><span class="p">,</span><span class="n">S1hx_fvals</span><span class="p">,</span><span class="n">S1hy_fvals</span><span class="p">,</span><span class="n">S1hz_fvals</span><span class="p">,</span><span class="n">S2hx_fvals</span><span class="p">,</span><span class="n">S2hy_fvals</span><span class="p">,</span><span class="n">S2hz_fvals</span> <span class="o">=</span> <span class="n">orbav_integrator</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">r_vals</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">r_f</span><span class="p">,</span><span class="n">Lhx</span><span class="p">,</span><span class="n">Lhy</span><span class="p">,</span><span class="n">Lhz</span><span class="p">,</span><span class="n">S1hx</span><span class="p">,</span><span class="n">S1hy</span><span class="p">,</span><span class="n">S1hz</span><span class="p">,</span><span class="n">S2hx</span><span class="p">,</span><span class="n">S2hy</span><span class="p">,</span><span class="n">S2hz</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">r_vals</span><span class="p">,</span><span class="n">Lhx_fvals</span><span class="p">,</span><span class="n">Lhy_fvals</span><span class="p">,</span><span class="n">Lhz_fvals</span><span class="p">,</span><span class="n">S1hx_fvals</span><span class="p">,</span><span class="n">S1hy_fvals</span><span class="p">,</span><span class="n">S1hz_fvals</span><span class="p">,</span><span class="n">S2hx_fvals</span><span class="p">,</span><span class="n">S2hy_fvals</span><span class="p">,</span><span class="n">S2hz_fvals</span><span class="p">):</span>                   
            <span class="n">L_f</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r_f</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
            <span class="n">outfilesave</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">r_f</span><span class="p">)</span><span class="o">+</span><span class="s">&quot; &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">Lhx</span><span class="o">*</span><span class="n">L_f</span><span class="p">)</span><span class="o">+</span><span class="s">&quot; &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">Lhy</span><span class="o">*</span><span class="n">L_f</span><span class="p">)</span><span class="o">+</span><span class="s">&quot; &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">Lhz</span><span class="o">*</span><span class="n">L_f</span><span class="p">)</span><span class="o">+</span><span class="s">&quot; &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">S1hx</span><span class="o">*</span><span class="n">S1</span><span class="p">)</span><span class="o">+</span><span class="s">&quot; &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">S1hy</span><span class="o">*</span><span class="n">S1</span><span class="p">)</span><span class="o">+</span><span class="s">&quot; &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">S1hz</span><span class="o">*</span><span class="n">S1</span><span class="p">)</span><span class="o">+</span><span class="s">&quot; &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">S2hx</span><span class="o">*</span><span class="n">S2</span><span class="p">)</span><span class="o">+</span><span class="s">&quot; &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">S2hy</span><span class="o">*</span><span class="n">S2</span><span class="p">)</span><span class="o">+</span><span class="s">&quot; &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">S2hz</span><span class="o">*</span><span class="n">S2</span><span class="p">)</span><span class="o">+</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
        <span class="n">outfilesave</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="c">#else:</span>
    <span class="c">#    print &quot;[evolve_J_infinity] Skipping. Output:&quot;, savename</span>
    
    <span class="k">return</span> <span class="n">savename</span>


<span class="k">def</span> <span class="nf">orbit_vectors</span><span class="p">(</span><span class="n">J_vals</span><span class="p">,</span><span class="n">xi_vals</span><span class="p">,</span><span class="n">S_vals</span><span class="p">,</span><span class="n">r_vals</span><span class="p">,</span><span class="n">q_vals</span><span class="p">,</span><span class="n">S1_vals</span><span class="p">,</span><span class="n">S2_vals</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Wrapper of `precession.orbav_integrator` to enable parallelization through</span>
<span class="sd">    the python parmap module; the number of available cores can be specified</span>
<span class="sd">    using the integer global variable `precession.CPUs` (all available cores</span>
<span class="sd">    will be used by default). Input are given in terms of J, xi and S; outputs</span>
<span class="sd">    are projected on a reference frame such that Jx=Jy=Ly=0 at the initial</span>
<span class="sd">    separation (cf. `precession.Jframe_projection`). Vectors, not unit vectros!,</span>
<span class="sd">    are returned. Evolve a sequence of binaries with the different q, S1, S2, xi</span>
<span class="sd">    and initial values of J and S; save outputs at SAME separations r_vals. The</span>
<span class="sd">    initial configuration must be compatible with r_vals[0]. Output is a 2D</span>
<span class="sd">    array, where e.g. J_vals[0] is the first binary (1D array at all output</span>
<span class="sd">    separations) and J_vals[0][0] is the first binary at the first output</span>
<span class="sd">    separation (this is a scalar).</span>

<span class="sd">    Checkpointing is implemented: results are stored in `precession.storedir`.</span>
<span class="sd"> </span>
<span class="sd">    **Call:**</span>
<span class="sd">        Lx_fvals,Ly_fvals,Lz_fvals,S1x_fvals,S1y_fvals,S1z_fvals,S2x_fvals,S2y_fvals,S2z_fvals=precession.orbit_vectors(J_vals,xi_vals,S_vals,r_vals,S1_vals,S2_vals)</span>

<span class="sd">    **Parameters:**</span>

<span class="sd">    - `Ji_vals`: initial condition for J (array).</span>
<span class="sd">    - `xii_vals`: initial condition for xi (array).</span>
<span class="sd">    - `Si_vals`: initial condition for S (array).</span>
<span class="sd">    - `r_vals`: binary separation (array).</span>
<span class="sd">    - `q_vals`: binary mass ratio. Must be q&lt;=1 (array).</span>
<span class="sd">    - `S1_vals`: spin magnitude of the primary BH (array).</span>
<span class="sd">    - `S2_vals`: spin magnitude of the secondary BH (array).</span>

<span class="sd">    **Returns:**</span>
<span class="sd">    </span>
<span class="sd">    - `Lx_fvals`: x component of the vector L.</span>
<span class="sd">    - `Ly_fvals`: y component of the vector L.</span>
<span class="sd">    - `Lz_fvals`: z component of the vector L.</span>
<span class="sd">    - `S1x_fvals`: x component of the vector S1.</span>
<span class="sd">    - `S1y_fvals`: y component of the vector S1.</span>
<span class="sd">    - `S1z_fvals`: z component of the vector S1.</span>
<span class="sd">    - `S2x_fvals`: x component of the vector S2.</span>
<span class="sd">    - `S2y_fvals`: y component of the vector S2.</span>
<span class="sd">    - `S2z_fvals`: z component of the vector S2.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="k">global</span> <span class="n">CPUs</span>
    
    <span class="n">single_flag</span><span class="o">=</span><span class="bp">False</span>
    <span class="k">try</span><span class="p">:</span> <span class="c">#Convert float to array if you&#39;re evolving just one binary</span>
        <span class="nb">len</span><span class="p">(</span><span class="n">q_vals</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">J_vals</span><span class="o">=</span><span class="p">[</span><span class="n">J_vals</span><span class="p">]</span>
        <span class="n">xi_vals</span><span class="o">=</span><span class="p">[</span><span class="n">xi_vals</span><span class="p">]</span>
        <span class="n">S_vals</span><span class="o">=</span><span class="p">[</span><span class="n">S_vals</span><span class="p">]</span>
        <span class="n">q_vals</span><span class="o">=</span><span class="p">[</span><span class="n">q_vals</span><span class="p">]</span>
        <span class="n">S1_vals</span><span class="o">=</span><span class="p">[</span><span class="n">S1_vals</span><span class="p">]</span>
        <span class="n">S2_vals</span><span class="o">=</span><span class="p">[</span><span class="n">S2_vals</span><span class="p">]</span>
        <span class="n">single_flag</span><span class="o">=</span><span class="bp">True</span>
    <span class="k">try</span><span class="p">:</span> <span class="c"># Set default</span>
        <span class="n">CPUs</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">CPUs</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">print</span> <span class="s">&quot;[orbit_vectors] Default parallel computation&quot;</span>
    
    <span class="c"># Parallelization</span>
    <span class="k">if</span> <span class="n">CPUs</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="c"># Run on all cpus on the current machine! (default option)</span>
        <span class="n">filelist</span><span class="o">=</span><span class="n">parmap</span><span class="o">.</span><span class="n">starmap</span><span class="p">(</span><span class="n">orbit_vectors_single</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">J_vals</span><span class="p">,</span><span class="n">xi_vals</span><span class="p">,</span><span class="n">S_vals</span><span class="p">,[</span><span class="n">r_vals</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q_vals</span><span class="p">))],</span><span class="n">q_vals</span><span class="p">,</span><span class="n">S1_vals</span><span class="p">,</span><span class="n">S2_vals</span><span class="p">),</span><span class="n">parallel</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> 
    <span class="k">elif</span> <span class="n">CPUs</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="c"># 1 cpus done by explicitely removing parallelization</span>
        <span class="n">filelist</span><span class="o">=</span><span class="n">parmap</span><span class="o">.</span><span class="n">starmap</span><span class="p">(</span><span class="n">orbit_vectors_single</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">J_vals</span><span class="p">,</span><span class="n">xi_vals</span><span class="p">,</span><span class="n">S_vals</span><span class="p">,[</span><span class="n">r_vals</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q_vals</span><span class="p">))],</span><span class="n">q_vals</span><span class="p">,</span><span class="n">S1_vals</span><span class="p">,</span><span class="n">S2_vals</span><span class="p">),</span><span class="n">parallel</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> 
    <span class="k">else</span><span class="p">:</span> <span class="c"># Run on a given number of CPUs        </span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">CPUs</span><span class="p">)</span>
        <span class="n">filelist</span><span class="o">=</span><span class="n">parmap</span><span class="o">.</span><span class="n">starmap</span><span class="p">(</span><span class="n">orbit_vectors_single</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">J_vals</span><span class="p">,</span><span class="n">xi_vals</span><span class="p">,</span><span class="n">S_vals</span><span class="p">,[</span><span class="n">r_vals</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q_vals</span><span class="p">))],</span><span class="n">q_vals</span><span class="p">,</span><span class="n">S1_vals</span><span class="p">,</span><span class="n">S2_vals</span><span class="p">),</span><span class="n">pool</span><span class="o">=</span><span class="n">p</span><span class="p">)</span> 

    <span class="n">Lx_fvals</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">Ly_fvals</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">Lz_fvals</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">S1x_fvals</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">S1y_fvals</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">S1z_fvals</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">S2x_fvals</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">S2y_fvals</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">S2z_fvals</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="nb">file</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">filelist</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">&quot;[orbit_vectors] Reading:&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="nb">file</span>
        <span class="n">dummy</span><span class="p">,</span><span class="n">Lx</span><span class="p">,</span><span class="n">Ly</span><span class="p">,</span><span class="n">Lz</span><span class="p">,</span><span class="n">S1x</span><span class="p">,</span><span class="n">S1y</span><span class="p">,</span><span class="n">S1z</span><span class="p">,</span><span class="n">S2x</span><span class="p">,</span><span class="n">S2y</span><span class="p">,</span><span class="n">S2z</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="nb">file</span><span class="p">,</span><span class="n">unpack</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">Lx_fvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Lx</span><span class="p">)</span>
        <span class="n">Ly_fvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Ly</span><span class="p">)</span>
        <span class="n">Lz_fvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Lz</span><span class="p">)</span>
        <span class="n">S1x_fvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">S1x</span><span class="p">)</span>
        <span class="n">S1y_fvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">S1y</span><span class="p">)</span>
        <span class="n">S1z_fvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">S1z</span><span class="p">)</span>
        <span class="n">S2x_fvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">S2x</span><span class="p">)</span>
        <span class="n">S2y_fvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">S2y</span><span class="p">)</span>
        <span class="n">S2z_fvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">S2z</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">single_flag</span><span class="o">==</span><span class="bp">True</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Lx_fvals</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Ly_fvals</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Lz_fvals</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">S1x_fvals</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">S1y_fvals</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">S1z_fvals</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">S2x_fvals</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">S2y_fvals</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">S2z_fvals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>        
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Lx_fvals</span><span class="p">,</span> <span class="n">Ly_fvals</span><span class="p">,</span> <span class="n">Lz_fvals</span><span class="p">,</span> <span class="n">S1x_fvals</span><span class="p">,</span> <span class="n">S1y_fvals</span><span class="p">,</span> <span class="n">S1z_fvals</span><span class="p">,</span> <span class="n">S2x_fvals</span><span class="p">,</span> <span class="n">S2y_fvals</span><span class="p">,</span> <span class="n">S2z_fvals</span>


<span class="k">def</span> <span class="nf">hybrid_single</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">kappa_inf</span><span class="p">,</span><span class="n">r_vals</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r_t</span><span class="p">):</span>
    
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Auxiliary function, see `hybrid`.</span>
<span class="sd"> </span>
<span class="sd">    **Call:**</span>

<span class="sd">        savename=precession.hybrid_single(xi,kappa_inf,r_vals,q,S1,S2,r_t)</span>

<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `kappa_inf`: asymtotic value of kappa at large separations.</span>
<span class="sd">    - `r_vals`: binary separation (array).</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `r_t`: transition radius between orbit- and precession-averaged approach.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `savename`: checkpoint filename.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">global</span> <span class="n">flags_q1</span>
    <span class="k">if</span> <span class="n">q</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">flags_q1</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span><span class="o">==</span><span class="bp">False</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;[hybrid] Warning q=1: required intial condition is S, not kappa_inf.&quot;</span>
            <span class="n">flags_q1</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span><span class="o">=</span><span class="bp">True</span> <span class="c"># Suppress future warnings</span>

    <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s">&quot;mkdir -p &quot;</span><span class="o">+</span><span class="n">storedir</span><span class="p">)</span> 
    <span class="n">savename</span><span class="o">=</span> <span class="n">storedir</span><span class="o">+</span><span class="s">&quot;/hybrid_&quot;</span><span class="o">+</span><span class="s">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">kappa_inf</span><span class="p">,</span><span class="nb">max</span><span class="p">(</span><span class="n">r_vals</span><span class="p">),</span><span class="nb">min</span><span class="p">(</span><span class="n">r_vals</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">r_vals</span><span class="p">),</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r_t</span><span class="p">)])</span><span class="o">+</span><span class="s">&quot;.dat&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">savename</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">&quot;[hybrid] Transferring binary. Output:&quot;</span><span class="p">,</span> <span class="n">savename</span>
        <span class="n">outfilesave</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">savename</span><span class="p">,</span><span class="s">&quot;w&quot;</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>

        <span class="c"># Split the output separations: precession-average before r_t and orbit-average after it         </span>
        <span class="n">r_vals_pa</span><span class="o">=</span><span class="p">[</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">r_vals</span> <span class="k">if</span> <span class="n">r</span><span class="o">&gt;</span><span class="n">r_t</span><span class="p">]</span>
        <span class="n">r_vals_oa</span><span class="o">=</span><span class="p">[</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">r_vals</span> <span class="k">if</span> <span class="n">r</span><span class="o">&lt;=</span><span class="n">r_t</span><span class="p">]</span> <span class="c"># Keep r_t (if present) in the orbit-average part</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">[</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">r_vals_oa</span> <span class="k">if</span> <span class="n">r</span><span class="o">!=</span><span class="n">r_t</span><span class="p">]:</span> <span class="c"># If there&#39;s nothing but r_t in the orbit-averaged part</span>
            <span class="k">assert</span> <span class="bp">False</span><span class="p">,</span> <span class="s">&quot;[hybrid] No output required below r_t. You don&#39;t need a hybrid integration, use evolve_J_infinity instead&quot;</span>

        <span class="c"># Add the threshold at the end of the precession-average part and at the beginning of the orbit-average part</span>
        <span class="n">r_vals_pa</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r_t</span><span class="p">)</span>
        <span class="n">r_vals_oa</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">r_t</span><span class="p">)</span>  

        <span class="c"># Evolve from r=infinity to r=r_t using precession-averaged integration</span>
        <span class="n">J_vals_pa</span><span class="o">=</span><span class="n">Jofr_infinity</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">kappa_inf</span><span class="p">,</span><span class="n">r_vals_pa</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">)</span>

        <span class="c"># Store the angles theta1, theta2 and deltaphi (need S resampling at each output separation)</span>
        <span class="c"># Don&#39;t use the latest values in the arrays, because you added one value at the end earlier on</span>
        <span class="k">for</span> <span class="n">J_f</span><span class="p">,</span><span class="n">r_f</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">J_vals_pa</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">r_vals_pa</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>           
          
            <span class="n">S_f</span><span class="o">=</span><span class="n">samplingS</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">J_f</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r_f</span><span class="p">)</span>
            <span class="n">theta1_f</span><span class="p">,</span><span class="n">theta2_f</span><span class="p">,</span><span class="n">deltaphi_f</span><span class="p">,</span><span class="n">dummy</span> <span class="o">=</span> <span class="n">parametric_angles</span><span class="p">(</span><span class="n">S_f</span><span class="p">,</span><span class="n">J_f</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r_f</span><span class="p">)</span>
            <span class="n">deltaphi_f</span><span class="o">*=</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">([</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">])</span>
            <span class="n">outfilesave</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">r_f</span><span class="p">)</span><span class="o">+</span><span class="s">&quot; &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">theta1_f</span><span class="p">)</span><span class="o">+</span><span class="s">&quot; &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">theta2_f</span><span class="p">)</span><span class="o">+</span><span class="s">&quot; &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">deltaphi_f</span><span class="p">)</span><span class="o">+</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>        

        <span class="c"># Last S resampling at r=r_t</span>
        <span class="n">S_t</span><span class="o">=</span><span class="n">samplingS</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">J_vals_pa</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r_t</span><span class="p">)</span>
        
        <span class="c"># Evolve from r_t to min(r_vals) using orbit-average integration</span>
        <span class="n">Lhx_vals_oa</span><span class="p">,</span><span class="n">Lhy_vals_oa</span><span class="p">,</span><span class="n">Lhz_vals_oa</span><span class="p">,</span><span class="n">S1hx_vals_oa</span><span class="p">,</span><span class="n">S1hy_vals_oa</span><span class="p">,</span><span class="n">S1hz_vals_oa</span><span class="p">,</span><span class="n">S2hx_vals_oa</span><span class="p">,</span><span class="n">S2hy_vals_oa</span><span class="p">,</span><span class="n">S2hz_vals_oa</span> <span class="o">=</span> <span class="n">orbav_integrator</span><span class="p">(</span><span class="n">J_vals_pa</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">xi</span><span class="p">,</span><span class="n">S_t</span><span class="p">,</span><span class="n">r_vals_oa</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">)</span>

        <span class="c"># Store the angles theta1, theta2 and deltaphi (S resampling not needed)</span>
        <span class="c"># Don&#39;t use the first values in the arrays, because you added one value on top earlier on</span>
        <span class="k">for</span> <span class="n">r_f</span><span class="p">,</span><span class="n">Lhx</span><span class="p">,</span><span class="n">Lhy</span><span class="p">,</span><span class="n">Lhz</span><span class="p">,</span><span class="n">S1hx</span><span class="p">,</span><span class="n">S1hy</span><span class="p">,</span><span class="n">S1hz</span><span class="p">,</span><span class="n">S2hx</span><span class="p">,</span><span class="n">S2hy</span><span class="p">,</span><span class="n">S2hz</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">r_vals_oa</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span><span class="n">Lhx_vals_oa</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span><span class="n">Lhy_vals_oa</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span><span class="n">Lhz_vals_oa</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span><span class="n">S1hx_vals_oa</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span><span class="n">S1hy_vals_oa</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span><span class="n">S1hz_vals_oa</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span><span class="n">S2hx_vals_oa</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span><span class="n">S2hy_vals_oa</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span><span class="n">S2hz_vals_oa</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
            <span class="n">L_f</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r_f</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
            <span class="n">S_f</span><span class="o">=</span><span class="p">((</span><span class="n">S1</span><span class="o">*</span><span class="n">S1hx</span><span class="o">+</span><span class="n">S2</span><span class="o">*</span><span class="n">S2hx</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">S1</span><span class="o">*</span><span class="n">S1hy</span><span class="o">+</span><span class="n">S2</span><span class="o">*</span><span class="n">S2hy</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">S1</span><span class="o">*</span><span class="n">S1hz</span><span class="o">+</span><span class="n">S2</span><span class="o">*</span><span class="n">S2hz</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="p">)</span><span class="o">**</span><span class="mf">0.5</span>
            <span class="n">J_f</span><span class="o">=</span><span class="p">((</span><span class="n">L_f</span><span class="o">*</span><span class="n">Lhx</span><span class="o">+</span><span class="n">S1</span><span class="o">*</span><span class="n">S1hx</span><span class="o">+</span><span class="n">S2</span><span class="o">*</span><span class="n">S2hx</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">L_f</span><span class="o">*</span><span class="n">Lhy</span><span class="o">+</span><span class="n">S1</span><span class="o">*</span><span class="n">S1hy</span><span class="o">+</span><span class="n">S2</span><span class="o">*</span><span class="n">S2hy</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">L_f</span><span class="o">*</span><span class="n">Lhz</span><span class="o">+</span><span class="n">S1</span><span class="o">*</span><span class="n">S1hz</span><span class="o">+</span><span class="n">S2</span><span class="o">*</span><span class="n">S2hz</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="p">)</span><span class="o">**</span><span class="mf">0.5</span>
            <span class="n">xi_f</span><span class="o">=</span><span class="p">((</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">S1</span><span class="o">*</span><span class="p">(</span><span class="n">Lhx</span><span class="o">*</span><span class="n">S1hx</span><span class="o">+</span><span class="n">Lhy</span><span class="o">*</span><span class="n">S1hy</span><span class="o">+</span><span class="n">Lhz</span><span class="o">*</span><span class="n">S1hz</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="o">**-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">S2</span><span class="o">*</span><span class="p">(</span><span class="n">Lhx</span><span class="o">*</span><span class="n">S2hx</span><span class="o">+</span><span class="n">Lhy</span><span class="o">*</span><span class="n">S2hy</span><span class="o">+</span><span class="n">Lhz</span><span class="o">*</span><span class="n">S2hz</span><span class="p">))</span><span class="o">*</span><span class="n">M</span><span class="o">**-</span><span class="mi">2</span>
            <span class="k">if</span> <span class="n">q</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="c"># You need to compute varphi, not S</span>
                <span class="n">A1</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">J_f</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">L_f</span><span class="o">-</span><span class="n">S_f</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">A2</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">L_f</span><span class="o">+</span><span class="n">S_f</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">J_f</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">A3</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">S_f</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">A4</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">S1</span><span class="o">+</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S_f</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>  
                <span class="n">cosvarphi</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">J_f</span><span class="o">*</span><span class="n">S_f</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">S1hz</span><span class="o">*</span><span class="n">S1</span><span class="o">-</span><span class="p">(</span><span class="n">S_f</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">S1</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">J_f</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L_f</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">S_f</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="n">A1</span><span class="o">*</span><span class="n">A2</span><span class="o">*</span><span class="n">A3</span><span class="o">*</span><span class="n">A4</span><span class="p">)</span>
                <span class="n">S_f</span><span class="o">=</span><span class="n">cosvarphi</span> 
            
            <span class="n">theta1_f</span><span class="p">,</span><span class="n">theta2_f</span><span class="p">,</span><span class="n">deltaphi_f</span><span class="p">,</span><span class="n">dummy</span><span class="o">=</span> <span class="n">parametric_angles</span><span class="p">(</span><span class="n">S_f</span><span class="p">,</span><span class="n">J_f</span><span class="p">,</span><span class="n">xi_f</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r_f</span><span class="p">)</span>
            <span class="c"># Track the precessional phase to set the sign of DeltaPhi. In symbols, the sign of DeltaPhi must be the sign of</span>
            <span class="c">#L dot [ ( S1 - (S1 dot L) dot L ) cross ( S2 - (S2 dot L) dot L ) ]</span>
            <span class="n">S1px</span><span class="o">=</span><span class="p">(</span><span class="n">S1hx</span><span class="o">-</span><span class="n">theta1_f</span><span class="o">*</span><span class="n">Lhx</span><span class="p">)</span>
            <span class="n">S1py</span><span class="o">=</span><span class="p">(</span><span class="n">S1hy</span><span class="o">-</span><span class="n">theta1_f</span><span class="o">*</span><span class="n">Lhy</span><span class="p">)</span>
            <span class="n">S1pz</span><span class="o">=</span><span class="p">(</span><span class="n">S1hz</span><span class="o">-</span><span class="n">theta1_f</span><span class="o">*</span><span class="n">Lhz</span><span class="p">)</span>
            <span class="n">S2px</span><span class="o">=</span><span class="p">(</span><span class="n">S2hx</span><span class="o">-</span><span class="n">theta2_f</span><span class="o">*</span><span class="n">Lhx</span><span class="p">)</span>
            <span class="n">S2py</span><span class="o">=</span><span class="p">(</span><span class="n">S2hy</span><span class="o">-</span><span class="n">theta2_f</span><span class="o">*</span><span class="n">Lhy</span><span class="p">)</span>
            <span class="n">S2pz</span><span class="o">=</span><span class="p">(</span><span class="n">S2hz</span><span class="o">-</span><span class="n">theta2_f</span><span class="o">*</span><span class="n">Lhz</span><span class="p">)</span>
            <span class="n">proj</span><span class="o">=</span><span class="n">Lhx</span><span class="o">*</span><span class="p">(</span><span class="n">S1py</span><span class="o">*</span><span class="n">S2pz</span><span class="o">-</span><span class="n">S1pz</span><span class="o">*</span><span class="n">S2py</span><span class="p">)</span> <span class="o">+</span> <span class="n">Lhy</span><span class="o">*</span><span class="p">(</span><span class="n">S1pz</span><span class="o">*</span><span class="n">S2px</span><span class="o">-</span><span class="n">S1px</span><span class="o">*</span><span class="n">S2pz</span><span class="p">)</span> <span class="o">+</span> <span class="n">Lhz</span><span class="o">*</span><span class="p">(</span><span class="n">S1px</span><span class="o">*</span><span class="n">S2py</span><span class="o">-</span><span class="n">S1py</span><span class="o">*</span><span class="n">S2px</span><span class="p">)</span>
            <span class="n">deltaphi_f</span><span class="o">*=</span><span class="n">math</span><span class="o">.</span><span class="n">copysign</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="n">proj</span><span class="p">)</span>
            
            <span class="n">outfilesave</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">r_f</span><span class="p">)</span><span class="o">+</span><span class="s">&quot; &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">theta1_f</span><span class="p">)</span><span class="o">+</span><span class="s">&quot; &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">theta2_f</span><span class="p">)</span><span class="o">+</span><span class="s">&quot; &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">deltaphi_f</span><span class="p">)</span><span class="o">+</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
        <span class="n">outfilesave</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        
    <span class="k">return</span> <span class="n">savename</span>


<span class="k">def</span> <span class="nf">hybrid</span><span class="p">(</span><span class="n">xi_vals</span><span class="p">,</span><span class="n">kappainf_vals</span><span class="p">,</span><span class="n">r_vals</span><span class="p">,</span><span class="n">q_vals</span><span class="p">,</span><span class="n">S1_vals</span><span class="p">,</span><span class="n">S2_vals</span><span class="p">,</span><span class="n">r_t</span><span class="p">):</span>
 
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Hybrid inspiral. Evolve a binary FROM INIFINITELY large separations (as</span>
<span class="sd">    specified by kappa_inf and xi) till the threshold r_t using the</span>
<span class="sd">    precession-averaged approach, and then from r_t to the end of the inspiral</span>
<span class="sd">    using an orbit-averaged integration to track the precessional phase.</span>

<span class="sd">    Parallelization is implemented through the python parmap module; the number</span>
<span class="sd">    of available cores can be specified using the integer global variable</span>
<span class="sd">    `precession.CPUs` (all available cores will be used by default). Evolve a</span>
<span class="sd">    sequence of binaries with the different q, S1,S2, xi and kappa_inf. Save</span>
<span class="sd">    outputs at SAME separations r_vals; r_t must also be the same for all</span>
<span class="sd">    binaries</span>

<span class="sd">    The initial condition is NOT returned by this function. Outputs are given in</span>
<span class="sd">    terms of the angles theta1, theta2 and deltaphi as 2D arrays, where e.g</span>
<span class="sd">    theta1_fvals[0] is the first binary (1D array at all output separations) and</span>
<span class="sd">    theta1_fvals[0][0] is the first binary at the first output separation (this</span>
<span class="sd">    is a scalar).</span>

<span class="sd">    **Call:**</span>
<span class="sd">        theta1f_vals,theta2f_vals,deltaphif_vals=precession.hybrid(xi_vals,kappainf_vals,r_vals,q_vals,S1_vals,S2_vals,r_t)</span>

<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `xi_vals`: projection of the effective spin along the orbital angular momentum (array).</span>
<span class="sd">    - `kappainf_vals`: asymtotic value of kappa at large separations (array).</span>
<span class="sd">    - `r_vals`: binary separation (array).</span>
<span class="sd">    - `q_vals`: binary mass ratio. Must be q&lt;=1 (array).</span>
<span class="sd">    - `S1_vals`: spin magnitude of the primary BH (array).</span>
<span class="sd">    - `S2_vals`: spin magnitude of the secondary BH (array).</span>
<span class="sd">    - `r_t`: transition radius between orbit- and precession-averaged approach.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `theta1f_vals`: solutions for theta1 (2D array).</span>
<span class="sd">    - `theta2f_vals`: solutions for theta2 (2D array).</span>
<span class="sd">    - `deltaphif_vals`: solutions for deltaphi (2D array).</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">global</span> <span class="n">CPUs</span>

    <span class="n">single_flag</span><span class="o">=</span><span class="bp">False</span>

    <span class="k">try</span><span class="p">:</span> <span class="c">#Convert float to array if you&#39;re evolving just one binary </span>
        <span class="nb">len</span><span class="p">(</span><span class="n">q_vals</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">single_flag</span><span class="o">=</span><span class="bp">True</span>
        <span class="n">xi_vals</span><span class="o">=</span><span class="p">[</span><span class="n">xi_vals</span><span class="p">]</span>
        <span class="n">kappainf_vals</span><span class="o">=</span><span class="p">[</span><span class="n">kappainf_vals</span><span class="p">]</span>
        <span class="n">q_vals</span><span class="o">=</span><span class="p">[</span><span class="n">q_vals</span><span class="p">]</span>
        <span class="n">S1_vals</span><span class="o">=</span><span class="p">[</span><span class="n">S1_vals</span><span class="p">]</span>
        <span class="n">S2_vals</span><span class="o">=</span><span class="p">[</span><span class="n">S2_vals</span><span class="p">]</span>
    <span class="k">try</span><span class="p">:</span> <span class="c"># Set defaults</span>
        <span class="n">CPUs</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">CPUs</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">print</span> <span class="s">&quot;[hybrid] Default parallel computation&quot;</span>

    <span class="n">loopflag</span><span class="o">=</span><span class="bp">True</span>
    <span class="k">while</span> <span class="n">loopflag</span><span class="p">:</span> <span class="c"># Restart is some of the cores crashed. This happend if you run too many things on too many different machines. Nevermind, trash the file and do it again. </span>
        <span class="n">loopflag</span><span class="o">=</span><span class="bp">False</span> 

        <span class="c">#Parallelization</span>
        <span class="k">if</span> <span class="n">CPUs</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="c">#Run on all cpus on the current machine! (default option) </span>
            <span class="n">filelist</span><span class="o">=</span><span class="n">parmap</span><span class="o">.</span><span class="n">starmap</span><span class="p">(</span><span class="n">hybrid_single</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xi_vals</span><span class="p">,</span><span class="n">kappainf_vals</span><span class="p">,[</span><span class="n">r_vals</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q_vals</span><span class="p">))],</span><span class="n">q_vals</span><span class="p">,</span><span class="n">S1_vals</span><span class="p">,</span><span class="n">S2_vals</span><span class="p">,[</span><span class="n">r_t</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q_vals</span><span class="p">))]),</span><span class="n">parallel</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">CPUs</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="c">#1 cpus done by explicitely removing parallelization </span>
            <span class="n">filelist</span><span class="o">=</span><span class="n">parmap</span><span class="o">.</span><span class="n">starmap</span><span class="p">(</span><span class="n">hybrid_single</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xi_vals</span><span class="p">,</span><span class="n">kappainf_vals</span><span class="p">,[</span><span class="n">r_vals</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q_vals</span><span class="p">))],</span><span class="n">q_vals</span><span class="p">,</span><span class="n">S1_vals</span><span class="p">,</span><span class="n">S2_vals</span><span class="p">,[</span><span class="n">r_t</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q_vals</span><span class="p">))]),</span><span class="n">parallel</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="c"># Run on a given number of CPUs</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">CPUs</span><span class="p">)</span>
            <span class="n">filelist</span><span class="o">=</span><span class="n">parmap</span><span class="o">.</span><span class="n">starmap</span><span class="p">(</span><span class="n">hybrid_single</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xi_vals</span><span class="p">,</span><span class="n">kappainf_vals</span><span class="p">,[</span><span class="n">r_vals</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q_vals</span><span class="p">))],</span><span class="n">q_vals</span><span class="p">,</span><span class="n">S1_vals</span><span class="p">,</span><span class="n">S2_vals</span><span class="p">,[</span><span class="n">r_t</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q_vals</span><span class="p">))]),</span><span class="n">pool</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>

        <span class="n">theta1_fvals</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">theta2_fvals</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">deltaphi_fvals</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="nb">file</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">filelist</span><span class="p">):</span>
            <span class="k">print</span> <span class="s">&quot;[hybrid] Reading:&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="nb">file</span>
            <span class="n">numlines</span><span class="o">=</span><span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">open</span><span class="p">(</span><span class="nb">file</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">numlines</span><span class="o">!=</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">numlines</span><span class="o">!=</span><span class="nb">len</span><span class="p">(</span><span class="n">r_vals</span><span class="p">):</span> <span class="c"># Restart if core(s) crashed </span>
                <span class="k">print</span> <span class="s">&quot;[hybrid] Error on file&quot;</span><span class="p">,</span> <span class="nb">file</span><span class="p">,</span><span class="s">&quot;. Jobs are being restarted!&quot;</span>
                <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s">&quot;rm &quot;</span><span class="o">+</span><span class="nb">file</span><span class="p">)</span>
                <span class="n">loopflag</span><span class="o">=</span><span class="bp">True</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">dummy</span><span class="p">,</span><span class="n">theta1_f</span><span class="p">,</span><span class="n">theta2_f</span><span class="p">,</span><span class="n">deltaphi_f</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="nb">file</span><span class="p">,</span><span class="n">unpack</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                <span class="n">theta1_fvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">theta1_f</span><span class="p">)</span>
                <span class="n">theta2_fvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">theta2_f</span><span class="p">)</span>
                <span class="n">deltaphi_fvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">deltaphi_f</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">single_flag</span><span class="o">==</span><span class="bp">True</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">theta1_fvals</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">theta2_fvals</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">deltaphi_fvals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">theta1_fvals</span><span class="p">,</span> <span class="n">theta2_fvals</span><span class="p">,</span> <span class="n">deltaphi_fvals</span>



<span class="c">#################################</span>
<span class="c">########## BH REMNANT ###########</span>
<span class="c">#################################</span>


<span class="k">def</span> <span class="nf">finalmass</span><span class="p">(</span><span class="n">theta1</span><span class="p">,</span><span class="n">theta2</span><span class="p">,</span><span class="n">deltaPhi</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Estimate the final mass of the BH renmant following a BH merger. We</span>
<span class="sd">    implement the fitting formula to numerical relativity simulations by</span>
<span class="sd">    Barausse Morozova Rezzolla 2012.  See also Gerosa and Sesana 2015. This</span>
<span class="sd">    formula has to be applied *close to merger*, where numerical relativity</span>
<span class="sd">    simulations are available. You should do a PN evolution to transfer binaries</span>
<span class="sd">    at r~10M.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        Mfin=precession.finalmass(theta1,theta2,deltaPhi,q,S1,S2)</span>

<span class="sd">    **Parameters:**</span>

<span class="sd">    - `theta1`: angle between the spin of the primary and the orbital angular momentum.</span>
<span class="sd">    - `theta2`: angle between the spin of the secondary and the orbital angular momentum.</span>
<span class="sd">    - `deltaphi`: angle between the projection of the two spins on the orbital plane.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>

<span class="sd">    **Returns:**</span>
<span class="sd">    </span>
<span class="sd">    - `Mfin`: mass of the BH remnant, in units of the (pre-merger) binary total mass</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">chi1</span><span class="o">=</span><span class="n">S1</span><span class="o">/</span><span class="p">(</span><span class="n">M</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span>   <span class="c"># Dimensionless spin</span>
    <span class="n">chi2</span><span class="o">=</span><span class="n">S2</span><span class="o">/</span><span class="p">(</span><span class="n">q</span><span class="o">*</span><span class="n">M</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span> <span class="c"># Dimensionless spin</span>
    <span class="n">eta</span><span class="o">=</span><span class="n">q</span><span class="o">*</span><span class="nb">pow</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">,</span><span class="o">-</span><span class="mf">2.</span><span class="p">)</span>     <span class="c"># Symmetric mass ratio</span>
    
    <span class="c"># Spins here are defined in a frame with L along z and S1 in xz</span>
    <span class="n">hatL</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">hatS1</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta1</span><span class="p">),</span><span class="mi">0</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta1</span><span class="p">)])</span>
    <span class="n">hatS2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta2</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">deltaPhi</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta2</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">deltaPhi</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta2</span><span class="p">)])</span>
    <span class="c">#Useful spin combinations. </span>
    <span class="n">Delta</span><span class="o">=</span> <span class="p">(</span><span class="n">q</span><span class="o">*</span><span class="n">chi2</span><span class="o">*</span><span class="n">hatS2</span><span class="o">-</span><span class="n">chi1</span><span class="o">*</span><span class="n">hatS1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span>
    <span class="n">Delta_par</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Delta</span><span class="p">,</span><span class="n">hatL</span><span class="p">)</span>
    <span class="n">Delta_perp</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">Delta</span><span class="p">,</span><span class="n">hatL</span><span class="p">))</span>
    <span class="n">chit</span><span class="o">=</span> <span class="p">(</span><span class="n">q</span><span class="o">*</span><span class="n">q</span><span class="o">*</span><span class="n">chi2</span><span class="o">*</span><span class="n">hatS2</span><span class="o">+</span><span class="n">chi1</span><span class="o">*</span><span class="n">hatS1</span><span class="p">)</span><span class="o">/</span><span class="nb">pow</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">,</span><span class="mf">2.</span><span class="p">)</span>
    <span class="n">chit_par</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">chit</span><span class="p">,</span><span class="n">hatL</span><span class="p">)</span>
    <span class="n">chit_perp</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">chit</span><span class="p">,</span><span class="n">hatL</span><span class="p">))</span>
    
    <span class="c">#Final mass. Barausse Morozova Rezzolla 2012</span>
    <span class="n">p0</span><span class="o">=</span><span class="mf">0.04827</span>
    <span class="n">p1</span><span class="o">=</span><span class="mf">0.01707</span>
    <span class="n">Z1</span><span class="o">=</span><span class="mf">1.</span><span class="o">+</span> <span class="nb">pow</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="nb">pow</span><span class="p">(</span><span class="n">chit_par</span><span class="p">,</span><span class="mf">2.</span><span class="p">),</span><span class="mf">1.</span><span class="o">/</span><span class="mf">3.</span><span class="p">)</span><span class="o">*</span> <span class="p">(</span><span class="nb">pow</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">chit_par</span><span class="p">,</span><span class="mf">1.</span><span class="o">/</span><span class="mf">3.</span><span class="p">)</span><span class="o">+</span><span class="nb">pow</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">chit_par</span><span class="p">,</span><span class="mf">1.</span><span class="o">/</span><span class="mf">3.</span><span class="p">))</span>
    <span class="n">Z2</span><span class="o">=</span><span class="nb">pow</span><span class="p">(</span><span class="mf">3.</span><span class="o">*</span><span class="nb">pow</span><span class="p">(</span><span class="n">chit_par</span><span class="p">,</span><span class="mf">2.</span><span class="p">)</span><span class="o">+</span><span class="nb">pow</span><span class="p">(</span><span class="n">Z1</span><span class="p">,</span><span class="mf">2.</span><span class="p">),</span><span class="mf">1.</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span>
    <span class="n">risco</span><span class="o">=</span><span class="mf">3.</span><span class="o">+</span><span class="n">Z2</span><span class="o">-</span><span class="n">math</span><span class="o">.</span><span class="n">copysign</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span><span class="n">chit_par</span><span class="p">)</span><span class="o">*</span><span class="nb">pow</span><span class="p">((</span><span class="mf">3.</span><span class="o">-</span><span class="n">Z1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mf">3.</span><span class="o">+</span><span class="n">Z1</span><span class="o">+</span><span class="mf">2.</span><span class="o">*</span><span class="n">Z2</span><span class="p">),</span><span class="mf">1.</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span>
    <span class="n">Eisco</span><span class="o">=</span><span class="nb">pow</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="mf">2.</span><span class="o">/</span><span class="p">(</span><span class="mf">3.</span><span class="o">*</span><span class="n">risco</span><span class="p">),</span><span class="mf">1.</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
    <span class="c">#Radiated energy, in unit of the initial total mass of the binary</span>
    <span class="n">Erad</span><span class="o">=</span> <span class="n">eta</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">Eisco</span><span class="p">)</span><span class="o">+</span><span class="mf">4.</span><span class="o">*</span><span class="nb">pow</span><span class="p">(</span><span class="n">eta</span><span class="p">,</span><span class="mf">2.</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mf">4.</span><span class="o">*</span><span class="n">p0</span><span class="o">+</span><span class="mf">16.</span><span class="o">*</span><span class="n">p1</span><span class="o">*</span><span class="n">chit_par</span><span class="o">*</span><span class="p">(</span><span class="n">chit_par</span><span class="o">+</span><span class="mf">1.</span><span class="p">)</span><span class="o">+</span><span class="n">Eisco</span><span class="o">-</span><span class="mf">1.</span><span class="p">)</span>
    <span class="n">Mfin</span><span class="o">=</span><span class="n">M</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span> <span class="n">Erad</span><span class="p">)</span> <span class="c"># Final mass</span>
        
    <span class="k">return</span> <span class="n">Mfin</span>
    

<span class="k">def</span> <span class="nf">finalspin</span><span class="p">(</span><span class="n">theta1</span><span class="p">,</span><span class="n">theta2</span><span class="p">,</span><span class="n">deltaPhi</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Estimate the final mass of the BH renmant following a BH merger. We</span>
<span class="sd">    implement the fitting formula to numerical relativity simulations by</span>
<span class="sd">    Barausse Rezzolla 2009.  See also Gerosa and Sesana 2015. We return the</span>
<span class="sd">    dimensionless spin, which is the spin in units of the (pre-merger) binary</span>
<span class="sd">    total mass, not the spin in units of the actual BH remnant. This can be</span>
<span class="sd">    obtained combing this function with `precession.finalmass`. Maximally</span>
<span class="sd">    spinning BHs are returned if/whenever the fitting formula returns</span>
<span class="sd">    dimensionless spins greater than 1. This formula has to be applied *close to</span>
<span class="sd">    merger*, where numerical relativity simulations are available. You should do</span>
<span class="sd">    a PN evolution to transfer binaries at r~10M.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        chifin=precession.finalspin(theta1,theta2,deltaPhi,q,S1,S2)</span>

<span class="sd">    **Parameters:**</span>

<span class="sd">    - `theta1`: angle between the spin of the primary and the orbital angular momentum.</span>
<span class="sd">    - `theta2`: angle between the spin of the secondary and the orbital angular momentum.</span>
<span class="sd">    - `deltaphi`: angle between the projection of the two spins on the orbital plane.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>

<span class="sd">    **Returns:**</span>
<span class="sd">    </span>
<span class="sd">    - `chifin`: dimensionless spin of the BH remnant</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="n">chi1</span><span class="o">=</span><span class="n">S1</span><span class="o">/</span><span class="p">(</span><span class="n">M</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span>   <span class="c"># Dimensionless spin</span>
    <span class="n">chi2</span><span class="o">=</span><span class="n">S2</span><span class="o">/</span><span class="p">(</span><span class="n">q</span><span class="o">*</span><span class="n">M</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span> <span class="c"># Dimensionless spin</span>
    <span class="n">eta</span><span class="o">=</span><span class="n">q</span><span class="o">*</span><span class="nb">pow</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">,</span><span class="o">-</span><span class="mf">2.</span><span class="p">)</span>     <span class="c"># Symmetric mass ratio</span>
    
    <span class="c"># Spins here are defined in a frame with L along z and S1 in xz</span>
    <span class="n">hatL</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">hatS1</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta1</span><span class="p">),</span><span class="mi">0</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta1</span><span class="p">)])</span>
    <span class="n">hatS2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta2</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">deltaPhi</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta2</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">deltaPhi</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta2</span><span class="p">)])</span>
    <span class="c">#Useful spin combinations. </span>
    <span class="n">Delta</span><span class="o">=</span> <span class="p">(</span><span class="n">q</span><span class="o">*</span><span class="n">chi2</span><span class="o">*</span><span class="n">hatS2</span><span class="o">-</span><span class="n">chi1</span><span class="o">*</span><span class="n">hatS1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span>
    <span class="n">Delta_par</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Delta</span><span class="p">,</span><span class="n">hatL</span><span class="p">)</span>
    <span class="n">Delta_perp</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">Delta</span><span class="p">,</span><span class="n">hatL</span><span class="p">))</span>
    <span class="n">chit</span><span class="o">=</span> <span class="p">(</span><span class="n">q</span><span class="o">*</span><span class="n">q</span><span class="o">*</span><span class="n">chi2</span><span class="o">*</span><span class="n">hatS2</span><span class="o">+</span><span class="n">chi1</span><span class="o">*</span><span class="n">hatS1</span><span class="p">)</span><span class="o">/</span><span class="nb">pow</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">,</span><span class="mf">2.</span><span class="p">)</span>
    <span class="n">chit_par</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">chit</span><span class="p">,</span><span class="n">hatL</span><span class="p">)</span>
    <span class="n">chit_perp</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">chit</span><span class="p">,</span><span class="n">hatL</span><span class="p">))</span>
    
    <span class="c">#Final spin. Barausse Rezzolla 2009</span>
    <span class="n">t0</span><span class="o">=-</span><span class="mf">2.8904</span>
    <span class="n">t2</span><span class="o">=-</span><span class="mf">3.51712</span>
    <span class="n">t3</span><span class="o">=</span><span class="mf">2.5763</span>
    <span class="n">s4</span><span class="o">=-</span><span class="mf">0.1229</span>
    <span class="n">s5</span><span class="o">=</span><span class="mf">0.4537</span>
    <span class="n">smalll</span> <span class="o">=</span> <span class="mf">2.</span><span class="o">*</span><span class="nb">pow</span><span class="p">(</span><span class="mf">3.</span><span class="p">,</span><span class="mf">1.</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span> <span class="o">+</span> <span class="n">t2</span><span class="o">*</span><span class="n">eta</span><span class="o">+</span><span class="n">t3</span><span class="o">*</span><span class="nb">pow</span><span class="p">(</span><span class="n">eta</span><span class="p">,</span><span class="mf">2.</span><span class="p">)</span> <span class="o">+</span> <span class="n">s4</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">chit</span><span class="p">,</span><span class="n">chit</span><span class="p">)</span><span class="o">*</span><span class="nb">pow</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">,</span><span class="mf">4.</span><span class="p">)</span><span class="o">*</span><span class="nb">pow</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">q</span><span class="o">*</span><span class="n">q</span><span class="p">,</span><span class="o">-</span><span class="mf">2.</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">s5</span><span class="o">*</span><span class="n">eta</span><span class="o">+</span><span class="n">t0</span><span class="o">+</span><span class="mf">2.</span><span class="p">)</span><span class="o">*</span><span class="n">chit_par</span><span class="o">*</span><span class="nb">pow</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="nb">pow</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="o">*</span><span class="n">q</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">chifin</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span> <span class="n">chit</span><span class="o">+</span><span class="n">hatL</span><span class="o">*</span><span class="n">smalll</span><span class="o">*</span><span class="n">q</span><span class="o">/</span><span class="nb">pow</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">,</span><span class="mf">2.</span><span class="p">)</span> <span class="p">)</span>
    <span class="k">if</span> <span class="n">chifin</span><span class="o">&gt;</span><span class="mf">1.</span><span class="p">:</span> <span class="c">#Check on the final spin, as suggested by Emanuele</span>
        <span class="k">print</span> <span class="s">&quot;[finalspin] Warning: got chi&gt;1, force chi=1&quot;</span>
        <span class="n">chifin</span><span class="o">==</span><span class="mf">1.</span>
        
    <span class="k">return</span> <span class="n">chifin</span>
    
    
<span class="k">def</span> <span class="nf">finalkick</span><span class="p">(</span><span class="n">theta1</span><span class="p">,</span><span class="n">theta2</span><span class="p">,</span><span class="n">deltaPhi</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">maxkick</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">kms</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Estimate the final kick of the BH remnant following a BH merger. We</span>
<span class="sd">    implement the fitting formula to numerical relativity simulations developed</span>
<span class="sd">    by the Rochester group. The larger contribution comes from the component of</span>
<span class="sd">    the kick parallel to L. Flags let you switch on and off the various</span>
<span class="sd">    contributions (all on by default): superkicks (Gonzalez et al. 2007a;</span>
<span class="sd">    Campanelli et al. 2007), hang-up kicks (Lousto &amp; Zlochower 2011),</span>
<span class="sd">    cross-kicks (Lousto &amp; Zlochower 2013). The orbital-plane kick components are</span>
<span class="sd">    implemented as described in Kesden et al. 2010a. See also Gerosa and Sesana</span>
<span class="sd">    2015.</span>

<span class="sd">    The final kick depends on the orbital phase at merger Theta. By default,</span>
<span class="sd">    this is assumed to be randonly distributed in [0,2pi]. The maximum kick is</span>
<span class="sd">    realized for Theta=0 and can be computed with the optional argument</span>
<span class="sd">    maxkick=True. This formula has to be applied *close to merger*, where</span>
<span class="sd">    numerical relativity simulations are available. You should do a PN evolution</span>
<span class="sd">    to transfer binaries at r~10M.</span>
<span class="sd">   </span>
<span class="sd">    The final kick is returned in geometrical units (i.e. vkick/c) by default,</span>
<span class="sd">    and converted to km/s if kms=True.</span>
<span class="sd">    </span>
<span class="sd">    **Call:**</span>

<span class="sd">        vkick=precession.finalkick(theta1,theta2,deltaPhi,q,S1,S2,maxkick=False,kms=False)</span>

<span class="sd">    **Parameters:**</span>

<span class="sd">    - `theta1`: angle between the spin of the primary and the orbital angular momentum.</span>
<span class="sd">    - `theta2`: angle between the spin of the secondary and the orbital angular momentum.</span>
<span class="sd">    - `deltaphi`: angle between the projection of the two spins on the orbital plane.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `maxkick`: if `True` maximizes over the orbital phase at merger.</span>
<span class="sd">    - `kms`: if `True` convert result to km/s.</span>

<span class="sd">    **Returns:**</span>
<span class="sd">    </span>
<span class="sd">    - `vkick`: dimensionless kick of the BH remnant</span>
<span class="sd">    &#39;&#39;&#39;</span>

    
    <span class="n">chi1</span><span class="o">=</span><span class="n">S1</span><span class="o">/</span><span class="p">(</span><span class="n">M</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span>   <span class="c"># Dimensionless spin</span>
    <span class="n">chi2</span><span class="o">=</span><span class="n">S2</span><span class="o">/</span><span class="p">(</span><span class="n">q</span><span class="o">*</span><span class="n">M</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span> <span class="c"># Dimensionless spin</span>
    <span class="n">eta</span><span class="o">=</span><span class="n">q</span><span class="o">*</span><span class="nb">pow</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">,</span><span class="o">-</span><span class="mf">2.</span><span class="p">)</span>     <span class="c"># Symmetric mass ratio</span>
    
    <span class="c"># Spins here are defined in a frame with L along z and S1 in xz</span>
    <span class="n">hatL</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">hatS1</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta1</span><span class="p">),</span><span class="mi">0</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta1</span><span class="p">)])</span>
    <span class="n">hatS2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta2</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">deltaPhi</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta2</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">deltaPhi</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta2</span><span class="p">)])</span>
    <span class="c">#Useful spin combinations. </span>
    <span class="n">Delta</span><span class="o">=</span> <span class="p">(</span><span class="n">q</span><span class="o">*</span><span class="n">chi2</span><span class="o">*</span><span class="n">hatS2</span><span class="o">-</span><span class="n">chi1</span><span class="o">*</span><span class="n">hatS1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span>
    <span class="n">Delta_par</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Delta</span><span class="p">,</span><span class="n">hatL</span><span class="p">)</span>
    <span class="n">Delta_perp</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">Delta</span><span class="p">,</span><span class="n">hatL</span><span class="p">))</span>
    <span class="n">chit</span><span class="o">=</span> <span class="p">(</span><span class="n">q</span><span class="o">*</span><span class="n">q</span><span class="o">*</span><span class="n">chi2</span><span class="o">*</span><span class="n">hatS2</span><span class="o">+</span><span class="n">chi1</span><span class="o">*</span><span class="n">hatS1</span><span class="p">)</span><span class="o">/</span><span class="nb">pow</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">,</span><span class="mf">2.</span><span class="p">)</span>
    <span class="n">chit_par</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">chit</span><span class="p">,</span><span class="n">hatL</span><span class="p">)</span>
    <span class="n">chit_perp</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">chit</span><span class="p">,</span><span class="n">hatL</span><span class="p">))</span>
    
    <span class="c">#Kick. Coefficients are quoted in km/s</span>
    
    <span class="c"># vm and vperp are like in Kesden at 2010a, vpar is modified from Lousto Zlochower 2013</span>
    <span class="n">zeta</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mf">145.</span><span class="p">)</span>
    <span class="n">A</span><span class="o">=</span><span class="mf">1.2e4</span>
    <span class="n">B</span><span class="o">=-</span><span class="mf">0.93</span>
    <span class="n">H</span><span class="o">=</span><span class="mf">6.9e3</span>

    <span class="c"># Switch on/off the various (super)kick contribution. Default are all on    </span>
    <span class="n">superkick</span><span class="o">=</span><span class="bp">True</span>
    <span class="n">hangupkick</span><span class="o">=</span><span class="bp">True</span>
    <span class="n">crosskick</span><span class="o">=</span><span class="bp">True</span>
    
    <span class="k">if</span> <span class="n">superkick</span><span class="o">==</span><span class="bp">True</span><span class="p">:</span>
        <span class="n">V11</span><span class="o">=</span><span class="mf">3677.76</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">V11</span><span class="o">=</span><span class="mf">0.</span>
    <span class="k">if</span> <span class="n">hangupkick</span><span class="o">==</span><span class="bp">True</span><span class="p">:</span>    
        <span class="n">VA</span><span class="o">=</span><span class="mf">2481.21</span>
        <span class="n">VB</span><span class="o">=</span><span class="mf">1792.45</span>
        <span class="n">VC</span><span class="o">=</span><span class="mf">1506.52</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">VA</span><span class="o">=</span><span class="mf">0.</span>
        <span class="n">VB</span><span class="o">=</span><span class="mf">0.</span>
        <span class="n">VC</span><span class="o">=</span><span class="mf">0.</span>
    <span class="k">if</span> <span class="n">crosskick</span><span class="o">==</span><span class="bp">True</span><span class="p">:</span>
        <span class="n">C2</span><span class="o">=</span><span class="mf">1140.</span>
        <span class="n">C3</span><span class="o">=</span><span class="mf">2481.</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">C2</span><span class="o">=</span><span class="mf">0.</span>
        <span class="n">C3</span><span class="o">=</span><span class="mf">0.</span>
        
    <span class="k">if</span> <span class="n">maxkick</span><span class="o">==</span><span class="bp">True</span><span class="p">:</span>
        <span class="n">bigTheta</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">bigTheta</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">2.</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
    
    <span class="n">vm</span><span class="o">=</span><span class="n">A</span><span class="o">*</span><span class="n">eta</span><span class="o">*</span><span class="n">eta</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">B</span><span class="o">*</span><span class="n">eta</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">q</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span>
    <span class="n">vperp</span><span class="o">=</span><span class="n">H</span><span class="o">*</span><span class="n">eta</span><span class="o">*</span><span class="n">eta</span><span class="o">*</span><span class="n">Delta_par</span>
    <span class="n">vpar</span><span class="o">=</span><span class="mf">16.</span><span class="o">*</span><span class="n">eta</span><span class="o">*</span><span class="n">eta</span><span class="o">*</span> <span class="p">(</span><span class="n">Delta_perp</span><span class="o">*</span><span class="p">(</span><span class="n">V11</span><span class="o">+</span><span class="mf">2.</span><span class="o">*</span><span class="n">VA</span><span class="o">*</span><span class="n">chit_par</span><span class="o">+</span><span class="mf">4.</span><span class="o">*</span><span class="n">VB</span><span class="o">*</span><span class="nb">pow</span><span class="p">(</span><span class="n">chit_par</span><span class="p">,</span><span class="mf">2.</span><span class="p">)</span><span class="o">+</span><span class="mf">8.</span><span class="o">*</span><span class="n">VC</span><span class="o">*</span><span class="nb">pow</span><span class="p">(</span><span class="n">chit_par</span><span class="p">,</span><span class="mf">3.</span><span class="p">))</span> <span class="o">+</span> <span class="n">chit_perp</span><span class="o">*</span><span class="n">Delta_par</span><span class="o">*</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">C2</span><span class="o">+</span><span class="mf">4.</span><span class="o">*</span><span class="n">C3</span><span class="o">*</span><span class="n">chit_par</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">bigTheta</span><span class="p">)</span>         
    <span class="n">vkick</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">([</span><span class="n">vm</span><span class="o">+</span><span class="n">vperp</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">zeta</span><span class="p">),</span><span class="n">vperp</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">zeta</span><span class="p">),</span><span class="n">vpar</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">vkick</span><span class="o">&gt;</span><span class="mi">5000</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&quot;[finalkick] Warning; I got v_kick&gt;5000km/s. This shouldn&#39;t be possibile&quot;</span>
    
    <span class="k">if</span> <span class="n">kms</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">vkick</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c"># speed of light in km/s</span>
        <span class="k">return</span> <span class="n">vkick</span><span class="o">/</span><span class="mf">299792.458</span>



<span class="c">#################################</span>
<span class="c">########## UTILITIES ############</span>
<span class="c">#################################</span>


<span class="k">def</span> <span class="nf">ftor</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">M_msun</span><span class="p">):</span>
    
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Conversion between binary separation r (in mass unit) and emitted GW</span>
<span class="sd">    frequency f (in Hertz). We use the Newtonian expression: f^2 = G M / (pi^2</span>
<span class="sd">    r^3) in cgs units. Mass units: r--&gt; GMr/c^2</span>

<span class="sd">    **Call:**</span>

<span class="sd">        r=precession.ftor(f,M_msun)</span>

<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `f`: emitted GW frequency in Hertz.</span>
<span class="sd">    - `M_msun`: binary total mass in solar masses.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `r`: binary separation.</span>
<span class="sd">    &#39;&#39;&#39;</span>

 
    
    <span class="n">M_cgs</span><span class="o">=</span><span class="n">M_msun</span><span class="o">*</span><span class="p">(</span><span class="mf">2e33</span><span class="p">)</span>
    <span class="n">c_cgs</span><span class="o">=</span><span class="mf">2.99e10</span>
    <span class="n">G_cgs</span><span class="o">=</span><span class="mf">6.67e-8</span>
    <span class="n">r</span><span class="o">=</span><span class="nb">pow</span><span class="p">(</span><span class="nb">pow</span><span class="p">(</span><span class="n">c_cgs</span><span class="p">,</span><span class="mf">3.</span><span class="p">),</span><span class="mf">2.</span><span class="o">/</span><span class="mf">3.</span><span class="p">)</span><span class="o">*</span><span class="nb">pow</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">f</span><span class="o">*</span><span class="n">G_cgs</span><span class="o">*</span><span class="n">M_cgs</span><span class="p">,</span><span class="o">-</span><span class="mf">2.</span><span class="o">/</span><span class="mf">3.</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">r</span>


<span class="k">def</span> <span class="nf">rtof</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">M_msun</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Conversion between emitted GW frequency f (in Hertz) and binary separation r</span>
<span class="sd">    (in mass unit). We use the Newtonian expression: f^2 = G M / (pi^2 r^3) in</span>
<span class="sd">    cgs units. Mass units: r--&gt; GMr/c^2</span>
<span class="sd"> </span>
<span class="sd">    **Call:**</span>

<span class="sd">        f=precession.rtof(r,M_msun)</span>

<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `r`: binary separation.</span>
<span class="sd">    - `M_msun`: binary total mass in solar masses.</span>

<span class="sd">    **Returns:**</span>
<span class="sd">    </span>
<span class="sd">    - `f`: emitted GW frequency in Hertz.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">M_cgs</span><span class="o">=</span><span class="n">M_msun</span><span class="o">*</span><span class="p">(</span><span class="mf">2e33</span><span class="p">)</span>
    <span class="n">c_cgs</span><span class="o">=</span><span class="mf">2.99e10</span>
    <span class="n">G_cgs</span><span class="o">=</span><span class="mf">6.67e-8</span>
    <span class="n">f</span><span class="o">=</span><span class="nb">pow</span><span class="p">(</span><span class="n">c_cgs</span><span class="p">,</span><span class="mf">3.</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">G_cgs</span><span class="o">*</span><span class="n">M_cgs</span><span class="o">*</span><span class="nb">pow</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="mf">3.</span><span class="o">/</span><span class="mf">2.</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">f</span>
    
    
<span class="k">def</span> <span class="nf">cutoff</span><span class="p">(</span><span class="n">detector</span><span class="p">,</span><span class="n">M_msun</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Return the GW frequency and binary separation (in total-mass units) when</span>
<span class="sd">    binary enter the sensitivity window of a typical ground-based LIGO-like</span>
<span class="sd">    detector or a LISA-like space mission.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        r,f=precession.cutoff(detector,M_msun)</span>
<span class="sd">    </span>
<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `detector`: specify either *space* or *ground*.</span>
<span class="sd">    - `M_msun`: binary total mass in solar masses.</span>

<span class="sd">    **Returns:**</span>
<span class="sd">    </span>
<span class="sd">    - `r`: binary separation.</span>
<span class="sd">    - `f`: emitted GW frequency in Hertz.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="n">detector</span><span class="o">==</span><span class="s">&quot;ground&quot;</span><span class="p">:</span>
        <span class="n">fcut</span><span class="o">=</span><span class="mi">10</span> <span class="c"># Hz</span>
    <span class="k">elif</span> <span class="n">detector</span><span class="o">==</span><span class="s">&quot;space&quot;</span><span class="p">:</span>
        <span class="n">fcut</span><span class="o">=</span> <span class="mf">1e-5</span> <span class="c"># Hz</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="bp">False</span><span class="p">,</span> <span class="s">&quot;[cutoff] Please select &#39;space&#39; or &#39;ground&#39;. Otherwise run ftor with the chosen frequency&quot;</span>
    <span class="n">rcut</span><span class="o">=</span><span class="n">ftor</span><span class="p">(</span><span class="n">fcut</span><span class="p">,</span><span class="n">M_msun</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">rcut</span><span class="p">,</span> <span class="n">fcut</span>
    
</pre></div>

  </div>

  </header>

  <section id="section-items">
    <h2 class="section-title" id="header-variables">Module variables</h2>
      <div class="item">
      <p id="precession.M" class="name">var <span class="ident">M</span></p>
      
  
    <div class="desc"><p>The total mass is just a free scale, and we set it to 1. Please, don't change
this, because I never checked that the various M factors are all right.</p></div>
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="precession.flags_q1" class="name">var <span class="ident">flags_q1</span></p>
      
  
    <div class="desc"><p>Global flags to reduce warnings in the equal-mass limit q=1.</p></div>
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="precession.storedir" class="name">var <span class="ident">storedir</span></p>
      
  
    <div class="desc"><p>Directory path to store checkpoints. Deafult is <code>./precession_checkpoints</code>.</p></div>
  <div class="source_cont">
</div>

      </div>

    <h2 class="section-title" id="header-functions">Functions</h2>
      
  <div class="item">
    <div class="name def" id="precession.J_allowed">
    <p>def <span class="ident">J_allowed</span>(</p><p>xi, q, S1, S2, r)</p>
    </div>
    

    
  
    <div class="desc"><p>Find allowed values of J for fixed xi, i.e the spin-orbit resonances. See
<a href="#precession.resonant_finder"><code>resonant_finder</code></a>.</p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>J_low,J_up=precession.J_allowed(xi,q,S1,S2,r)
</pre></div>


<p><strong>Parameters:</strong></p>
<ul>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>r</code>: binary separation.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>J_low</code>: minimum allowed value of J, given the input parameters.</li>
<li><code>J_up</code>: maximum allowed value of J, given the input parameters.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.J_allowed', this);">Show source &equiv;</a></p>
  <div id="source-precession.J_allowed" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">J_allowed</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Find allowed values of J for fixed xi, i.e the spin-orbit resonances. See</span>
<span class="sd">    `precession.resonant_finder`.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        J_low,J_up=precession.J_allowed(xi,q,S1,S2,r)</span>
<span class="sd">    </span>
<span class="sd">    **Parameters:**</span>

<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `r`: binary separation.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `J_low`: minimum allowed value of J, given the input parameters.</span>
<span class="sd">    - `J_up`: maximum allowed value of J, given the input parameters.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="n">J_dp0</span><span class="p">,</span> <span class="n">dummy</span><span class="p">,</span> <span class="n">dummy</span><span class="p">,</span> <span class="n">dummy</span><span class="p">,</span> <span class="n">J_dp180</span><span class="p">,</span> <span class="n">dummy</span><span class="p">,</span> <span class="n">dummy</span><span class="p">,</span> <span class="n">dummy</span> <span class="o">=</span> <span class="n">resonant_finder</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">,</span> <span class="n">more</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">J_dp0</span><span class="p">,</span><span class="n">J_dp180</span><span class="p">),</span><span class="nb">max</span><span class="p">(</span><span class="n">J_dp0</span><span class="p">,</span><span class="n">J_dp180</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.J_lim">
    <p>def <span class="ident">J_lim</span>(</p><p>q, S1, S2, r, verbose=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Compute the limits on the magnitude of the total angular momentum J, defined
as J=|L+S1+S2|.    </p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>Jmin,Jmax=precession.J_lim(q,S1,S2,r, verbose=False)
</pre></div>


<p><strong>Parameters:</strong></p>
<ul>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>r</code>: binary separation.</li>
<li><code>verbose</code>: if <code>True</code> print additional information.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>Jmin</code>: minimum value of J from geometrical constraints.</li>
<li><code>Jmax</code>: maximum value of J from geometrical constraints.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.J_lim', this);">Show source &equiv;</a></p>
  <div id="source-precession.J_lim" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">J_lim</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Compute the limits on the magnitude of the total angular momentum J, defined</span>
<span class="sd">    as J=|L+S1+S2|.    </span>

<span class="sd">    **Call:**</span>

<span class="sd">        Jmin,Jmax=precession.J_lim(q,S1,S2,r, verbose=False)</span>
<span class="sd">    </span>
<span class="sd">    **Parameters:**</span>
<span class="sd"> </span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `r`: binary separation.</span>
<span class="sd">    - `verbose`: if `True` print additional information.</span>

<span class="sd">    **Returns:**</span>
<span class="sd">    </span>
<span class="sd">    - `Jmin`: minimum value of J from geometrical constraints.</span>
<span class="sd">    - `Jmax`: maximum value of J from geometrical constraints.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">L</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>    
    <span class="n">Jmin</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="mf">1e-20</span><span class="p">,</span><span class="n">L</span><span class="o">-</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">,</span><span class="n">S1</span><span class="o">-</span><span class="n">L</span><span class="o">-</span><span class="n">S2</span><span class="p">,</span><span class="n">S2</span><span class="o">-</span><span class="n">S1</span><span class="o">-</span><span class="n">L</span><span class="p">)</span>
    <span class="n">Jmax</span><span class="o">=</span><span class="n">L</span><span class="o">+</span><span class="n">S1</span><span class="o">+</span><span class="n">S2</span>
    
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&quot;[J_lim] L=&quot;</span><span class="p">,</span><span class="n">L</span><span class="p">,</span> <span class="s">&quot; S1=&quot;</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="s">&quot; S2=&quot;</span><span class="p">,</span><span class="n">S2</span>
        <span class="k">print</span> <span class="s">&quot;[J_lim] Jmin=&quot;</span><span class="p">,</span><span class="n">Jmin</span><span class="p">,</span> <span class="s">&quot; Jmax=&quot;</span><span class="p">,</span><span class="n">Jmax</span>
        <span class="k">if</span> <span class="n">Jmin</span><span class="o">==</span><span class="mf">1e-20</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;[J_lim] Jmin=0, Jmax=L+S1+S2&quot;</span>
        <span class="k">elif</span> <span class="n">Jmin</span><span class="o">==</span><span class="n">L</span><span class="o">-</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;[J_lim] Jmin=L-S1-S2, Jmax=L+S1+S2&quot;</span>
        <span class="k">if</span> <span class="n">Jmin</span><span class="o">==</span><span class="n">S1</span><span class="o">-</span><span class="n">L</span><span class="o">-</span><span class="n">S2</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;[J_lim] Jmin=S1-L-S2, Jmax=L+S1+S2&quot;</span>
        <span class="k">if</span> <span class="n">Jmin</span><span class="o">==</span><span class="n">S2</span><span class="o">-</span><span class="n">L</span><span class="o">-</span><span class="n">S1</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;[J_lim] Jmin=S2-L-S1, Jmax=L+S1+S2&quot;</span>
            
    <span class="k">return</span> <span class="n">Jmin</span><span class="p">,</span><span class="n">Jmax</span>    
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.Jframe_projection">
    <p>def <span class="ident">Jframe_projection</span>(</p><p>xi, S, J, q, S1, S2, r)</p>
    </div>
    

    
  
    <div class="desc"><p>Project the three momenta on the reference frame aligned with the total
angular momentum J. The z axis points in the J direction, and the x axis
lies in the plane spanned by J and L. The y axis complete an orthonormal
triad. Note that this is not an inertial frame (not even on the precession
time) because it precesses together with L.</p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>Jvec,Lvec,S1vec,S2vec,Svec=precession.Jframe_projection(xi,S,J,q,S1,S2,r)
</pre></div>


<p><strong>Parameters:</strong></p>
<ul>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>S</code>: magnitude of the total spin.</li>
<li><code>J</code>: magnitude of the total angular momentum.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>r</code>: binary separation.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>Jvec</code>: components of J in a reference frame (3 values for x,y,z).</li>
<li><code>Lvec</code>: components of L in a reference frame (3 values for x,y,z).</li>
<li><code>S1vec</code>: components of S1 in a reference frame (3 values for x,y,z).</li>
<li><code>S2vec</code>: components of S2 in a reference frame (3 values for x,y,z).</li>
<li><code>Svec</code>: components of S in a reference frame (3 values for x,y,z).</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.Jframe_projection', this);">Show source &equiv;</a></p>
  <div id="source-precession.Jframe_projection" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">Jframe_projection</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">):</span>    

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Project the three momenta on the reference frame aligned with the total</span>
<span class="sd">    angular momentum J. The z axis points in the J direction, and the x axis</span>
<span class="sd">    lies in the plane spanned by J and L. The y axis complete an orthonormal</span>
<span class="sd">    triad. Note that this is not an inertial frame (not even on the precession</span>
<span class="sd">    time) because it precesses together with L.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        Jvec,Lvec,S1vec,S2vec,Svec=precession.Jframe_projection(xi,S,J,q,S1,S2,r)</span>
<span class="sd">    </span>
<span class="sd">    **Parameters:**</span>

<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `S`: magnitude of the total spin.</span>
<span class="sd">    - `J`: magnitude of the total angular momentum.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `r`: binary separation.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `Jvec`: components of J in a reference frame (3 values for x,y,z).</span>
<span class="sd">    - `Lvec`: components of L in a reference frame (3 values for x,y,z).</span>
<span class="sd">    - `S1vec`: components of S1 in a reference frame (3 values for x,y,z).</span>
<span class="sd">    - `S2vec`: components of S2 in a reference frame (3 values for x,y,z).</span>
<span class="sd">    - `Svec`: components of S in a reference frame (3 values for x,y,z).</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="k">global</span> <span class="n">flags_q1</span>
    <span class="n">L</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
    
    <span class="k">if</span> <span class="n">q</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">flags_q1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">==</span><span class="bp">False</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;[Jframe_projection] Warning q=1: input here is cos(varphi), not S.&quot;</span>
            <span class="n">flags_q1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="bp">True</span>
        <span class="n">varphi</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">S</span><span class="p">)</span>
        <span class="n">S</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">xi</span><span class="o">*</span><span class="n">L</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">varphi</span><span class="o">=</span><span class="n">get_varphi</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">sign</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        
    <span class="n">Jx</span> <span class="o">=</span> <span class="mf">0.</span>
    <span class="n">Jy</span> <span class="o">=</span> <span class="mf">0.</span>
    <span class="n">Jz</span> <span class="o">=</span> <span class="n">J</span> <span class="c"># Definition!</span>
    
    <span class="n">Lx</span> <span class="o">=</span> <span class="p">(</span> <span class="p">(((</span><span class="n">L</span><span class="o">+</span><span class="n">S</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="n">S</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span><span class="p">)</span> <span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">J</span><span class="p">)</span>
    <span class="n">Ly</span> <span class="o">=</span> <span class="mf">0.</span> <span class="c"># Definition!</span>
    <span class="n">Lz</span> <span class="o">=</span> <span class="p">(</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">J</span><span class="p">)</span>
    
    <span class="n">S1x</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="mf">4.</span><span class="o">*</span><span class="n">J</span><span class="o">*</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">*</span> \
          <span class="p">(</span> <span class="o">-</span><span class="mf">1.</span><span class="o">*</span><span class="p">(</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">S1</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(((</span><span class="n">L</span><span class="o">+</span><span class="n">S</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="n">S</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span><span class="p">)</span> \
          <span class="o">+</span> <span class="p">(</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(((</span><span class="n">S1</span><span class="o">+</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">varphi</span><span class="p">)</span> <span class="p">)</span>
    <span class="n">S1y</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">S</span><span class="p">))</span><span class="o">*</span> \
          <span class="p">(((</span><span class="n">S1</span><span class="o">+</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span><span class="p">)</span>  <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">varphi</span><span class="p">)</span>
    <span class="n">S1z</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="mf">4.</span><span class="o">*</span><span class="n">J</span><span class="o">*</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">*</span> \
          <span class="p">(</span> <span class="p">(</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">S1</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> \
          <span class="o">+</span> <span class="p">(((</span><span class="n">L</span><span class="o">+</span><span class="n">S</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="n">S</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span><span class="p">)</span> <span class="o">*</span><span class="p">(((</span><span class="n">S1</span><span class="o">+</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span><span class="p">)</span> <span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">varphi</span><span class="p">)</span> <span class="p">)</span>

    <span class="n">S2x</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="mf">4.</span><span class="o">*</span><span class="n">J</span><span class="o">*</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">*</span> \
          <span class="p">(</span> <span class="p">(</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">S2</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S1</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(((</span><span class="n">L</span><span class="o">+</span><span class="n">S</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="n">S</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span><span class="p">)</span> \
          <span class="o">+</span> <span class="p">(</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(((</span><span class="n">S1</span><span class="o">+</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">varphi</span><span class="p">)</span> <span class="p">)</span>
    <span class="n">S2y</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">S</span><span class="p">))</span><span class="o">*</span> \
          <span class="p">(((</span><span class="n">S1</span><span class="o">+</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span><span class="p">)</span>  <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">varphi</span><span class="p">)</span>
    <span class="n">S2z</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="mf">4.</span><span class="o">*</span><span class="n">J</span><span class="o">*</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">*</span> \
          <span class="p">(</span> <span class="p">(</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">S2</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S1</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> \
          <span class="o">-</span> <span class="p">(((</span><span class="n">L</span><span class="o">+</span><span class="n">S</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="n">S</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span><span class="p">)</span> <span class="o">*</span><span class="p">(((</span><span class="n">S1</span><span class="o">+</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="p">((</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span><span class="p">)</span> <span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">varphi</span><span class="p">)</span> <span class="p">)</span>    

    <span class="n">Jvec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Jx</span><span class="p">,</span><span class="n">Jy</span><span class="p">,</span><span class="n">Jz</span><span class="p">])</span>
    <span class="n">Lvec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">Lx</span><span class="p">,</span><span class="n">Ly</span><span class="p">,</span><span class="n">Lz</span><span class="p">])</span>
    <span class="n">S1vec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">S1x</span><span class="p">,</span><span class="n">S1y</span><span class="p">,</span><span class="n">S1z</span><span class="p">])</span>
    <span class="n">S2vec</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">S2x</span><span class="p">,</span><span class="n">S2y</span><span class="p">,</span><span class="n">S2z</span><span class="p">])</span>
    <span class="n">Svec</span><span class="o">=</span> <span class="n">S1vec</span><span class="o">+</span><span class="n">S2vec</span>

    <span class="k">if</span> <span class="bp">False</span><span class="p">:</span> <span class="c">#Sanity check. These sets of numbers should really be the same</span>
        <span class="k">print</span> <span class="s">&quot;[Jframe_projection] Check varphi&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">varphi</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">varphi</span><span class="p">)</span>
        <span class="k">print</span> <span class="s">&quot;[Jframe_projection] Check J norm&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Jvec</span><span class="p">),</span> <span class="n">J</span>
        <span class="k">print</span> <span class="s">&quot;[Jframe_projection] Check norm&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Lvec</span><span class="p">),</span> <span class="n">L</span>
        <span class="k">print</span> <span class="s">&quot;[Jframe_projection] Check norm&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">S1vec</span><span class="p">),</span> <span class="n">S1</span>
        <span class="k">print</span> <span class="s">&quot;[Jframe_projection] Check norm&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">S2vec</span><span class="p">),</span> <span class="n">S2</span>
        <span class="k">print</span> <span class="s">&quot;[Jframe_projection] Check norm&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">Svec</span><span class="p">),</span> <span class="n">S</span>

    <span class="k">return</span> <span class="n">Jvec</span><span class="p">,</span><span class="n">Lvec</span><span class="p">,</span><span class="n">S1vec</span><span class="p">,</span><span class="n">S2vec</span><span class="p">,</span><span class="n">Svec</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.Jofr">
    <p>def <span class="ident">Jofr</span>(</p><p>xi, J_initial, r_vals, q, S1, S2)</p>
    </div>
    

    
  
    <div class="desc"><p>Single integration of the dJ/dL equation to perfom precession-averaged
inspiral. Input/output are provided in J and r, but the internal integrator
uses kappa and u (see <a href="#precession.dkappadu"><code>dkappadu</code></a>). Integration is performed using
scipy's <code>odeint</code>.</p>
<p>This function integrates to/from FINITE separations only.</p>
<p>It takes the desired output separations r_vals, and the intial condition for
the total angular momentum J_initial. The latter must be consistent with the
initial separation (i.e. r_vals[0]) and the value of xi; an error is raised
in case of inconsistencies. It doesn't matter if you integrate from large to
small separations of the other way round, as long as J_initial is consistent
with r_vals[0]. It returns a vector with the values of J at each input
separation, the first item being just the initial condition.</p>
<p>We recommend to use this function through the wrapper <a href="#precession.evolve_J"><code>evolve_J</code></a>
provided.</p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>J_vals=precession.Jofr(xi,J_initial,r_vals,q,S1,S2)
</pre></div>


<p><strong>Parameters:</strong></p>
<ul>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>J_initial</code>: initial condition for numerical integration.</li>
<li><code>r_vals</code>: binary separation (array).</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>J_vals</code>: magnitude of the total angular momentum (array).</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.Jofr', this);">Show source &equiv;</a></p>
  <div id="source-precession.Jofr" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">Jofr</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">J_initial</span><span class="p">,</span><span class="n">r_vals</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Single integration of the dJ/dL equation to perfom precession-averaged</span>
<span class="sd">    inspiral. Input/output are provided in J and r, but the internal integrator</span>
<span class="sd">    uses kappa and u (see `precession.dkappadu`). Integration is performed using</span>
<span class="sd">    scipy&#39;s `odeint`.</span>
<span class="sd">    </span>
<span class="sd">    This function integrates to/from FINITE separations only.</span>
<span class="sd">    </span>
<span class="sd">    It takes the desired output separations r_vals, and the intial condition for</span>
<span class="sd">    the total angular momentum J_initial. The latter must be consistent with the</span>
<span class="sd">    initial separation (i.e. r_vals[0]) and the value of xi; an error is raised</span>
<span class="sd">    in case of inconsistencies. It doesn&#39;t matter if you integrate from large to</span>
<span class="sd">    small separations of the other way round, as long as J_initial is consistent</span>
<span class="sd">    with r_vals[0]. It returns a vector with the values of J at each input</span>
<span class="sd">    separation, the first item being just the initial condition.</span>
<span class="sd">    </span>
<span class="sd">    We recommend to use this function through the wrapper `precession.evolve_J`</span>
<span class="sd">    provided.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        J_vals=precession.Jofr(xi,J_initial,r_vals,q,S1,S2)</span>
<span class="sd">    </span>
<span class="sd">    **Parameters:**</span>

<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `J_initial`: initial condition for numerical integration.</span>
<span class="sd">    - `r_vals`: binary separation (array).</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `J_vals`: magnitude of the total angular momentum (array).</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">L_vals</span><span class="o">=</span><span class="p">[</span> <span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">r_vals</span><span class="p">]</span>
    <span class="n">kappa_initial</span><span class="o">=</span> <span class="p">(</span><span class="n">J_initial</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="p">(</span><span class="n">L_vals</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">L_vals</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">u_vals</span><span class="o">=</span><span class="p">[</span> <span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">L</span><span class="p">)</span> <span class="k">for</span> <span class="n">L</span> <span class="ow">in</span> <span class="n">L_vals</span><span class="p">]</span>

    <span class="c"># Analytical solution for q=1. S is constant on the radiation-reaction time</span>
    <span class="k">if</span> <span class="n">q</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">L_initial</span><span class="o">=</span><span class="n">L_vals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">Ssq</span><span class="o">=</span><span class="n">J_initial</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L_initial</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">xi</span><span class="o">*</span><span class="n">L_initial</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">J_vals</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Ssq</span><span class="o">+</span><span class="p">((</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">xi</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">((</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span><span class="p">))</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">r_vals</span><span class="p">]</span>
    
    <span class="c"># Numerical integration</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c">#sing = [ M*((1.+q)**2*(S1+S2)/(q*M**2))**2 ,  M*((1.+q)**2*(S1-S2)/(q*M**2))**2 ] # Expected singularities. Not needed</span>
        <span class="c"># Increase h0 to prevent occasional slowing down of the integration</span>
        <span class="n">res</span> <span class="o">=</span><span class="n">integrate</span><span class="o">.</span><span class="n">odeint</span><span class="p">(</span><span class="n">dkappadu</span><span class="p">,</span> <span class="n">kappa_initial</span><span class="p">,</span> <span class="n">u_vals</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">),</span> <span class="n">mxstep</span><span class="o">=</span><span class="mi">50000</span><span class="p">,</span> <span class="n">full_output</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">printmessg</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="c">#,h0=0.001)#,tcrit=sing)</span>
        <span class="n">kappa_vals</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">res</span><span class="p">]</span>
        <span class="n">J_vals</span><span class="o">=</span> <span class="p">[</span> <span class="p">(</span><span class="n">k</span><span class="o">*</span><span class="mf">2.</span><span class="o">*</span><span class="n">L</span> <span class="o">+</span> <span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">L</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">kappa_vals</span><span class="p">,</span><span class="n">L_vals</span><span class="p">)]</span>
    <span class="k">return</span> <span class="n">J_vals</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.Jofr_checkpoint">
    <p>def <span class="ident">Jofr_checkpoint</span>(</p><p>xi, J_initial, r_vals, q, S1, S2)</p>
    </div>
    

    
  
    <div class="desc"><p>Auxiliary function, see <a href="#precession.evolve_J"><code>evolve_J</code></a>.</p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>savename=precession.Jofr_checkpoint(xi,J_initial,r_vals,q,S1,S2)
</pre></div>


<p><strong>Parameters:</strong></p>
<ul>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>J_initial</code>: initial condition for numerical integration.</li>
<li><code>r_vals</code>: binary separation (array).</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>savename</code>: checkpoint filename.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.Jofr_checkpoint', this);">Show source &equiv;</a></p>
  <div id="source-precession.Jofr_checkpoint" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">Jofr_checkpoint</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">J_initial</span><span class="p">,</span><span class="n">r_vals</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Auxiliary function, see `precession.evolve_J`.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        savename=precession.Jofr_checkpoint(xi,J_initial,r_vals,q,S1,S2)</span>
<span class="sd">    </span>
<span class="sd">    **Parameters:**</span>

<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `J_initial`: initial condition for numerical integration.</span>
<span class="sd">    - `r_vals`: binary separation (array).</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `savename`: checkpoint filename.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s">&quot;mkdir -p &quot;</span><span class="o">+</span><span class="n">storedir</span><span class="p">)</span> 
    <span class="n">savename</span><span class="o">=</span> <span class="n">storedir</span><span class="o">+</span><span class="s">&quot;/evJ_&quot;</span><span class="o">+</span><span class="s">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">J_initial</span><span class="p">,</span><span class="nb">max</span><span class="p">(</span><span class="n">r_vals</span><span class="p">),</span><span class="nb">min</span><span class="p">(</span><span class="n">r_vals</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">r_vals</span><span class="p">),</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">)])</span><span class="o">+</span><span class="s">&quot;.dat&quot;</span>
        
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">savename</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">&quot;[evolve_J] Transferring binary. Output:&quot;</span><span class="p">,</span> <span class="n">savename</span>
        <span class="n">outfilesave</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">savename</span><span class="p">,</span><span class="s">&quot;w&quot;</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
       
        <span class="n">J_vals</span><span class="o">=</span> <span class="n">Jofr</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">J_initial</span><span class="p">,</span><span class="n">r_vals</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">J_f</span><span class="p">,</span><span class="n">r_f</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">J_vals</span><span class="p">,</span><span class="n">r_vals</span><span class="p">):</span>        
            <span class="n">outfilesave</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">r_f</span><span class="p">)</span><span class="o">+</span><span class="s">&quot; &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">J_f</span><span class="p">)</span><span class="o">+</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
        <span class="n">outfilesave</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="c">#else:</span>
    <span class="c">#    print &quot;[evolve_J] Skipping. Output:&quot;, savename</span>
    
    <span class="k">return</span> <span class="n">savename</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.Jofr_infinity">
    <p>def <span class="ident">Jofr_infinity</span>(</p><p>xi, kappa_inf, r_vals, q, S1, S2)</p>
    </div>
    

    
  
    <div class="desc"><p>Single integration of the dJ/dL equation to perfom precession-averaged
inspiral. Input/output are provided in J and r, but the internal integrator
uses kappa and u (see <a href="#precession.dkappadu"><code>dkappadu</code></a>). Integration is performed using
scipy's <code>odeint</code>.</p>
<p>This function integrates FROM INFINITE separation (u=0) only.</p>
<p>The latter must be consistent with <a href="#precession.kappainf_lim"><code>kappainf_lim</code></a>; an error is
raised in case of inconsistencies. It assume that the array r_vals is sorted
in reversed order, i.e. that you are integrating from large to small
separations. It returns a vector with the values of J at each input
separation. The initial condition is NOT returned by this function (unlike
the <a href="#precession.Jofr"><code>Jofr</code></a> for integrations to/from finite separations). If q=1,
kappa_inf is degenerate with xi: the required initial condition is assumed
to be S (which is constant).</p>
<p>We recommend to use this function through the wrapper
<a href="#precession.evolve_J_infinity"><code>evolve_J_infinity</code></a> provided.</p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>J_vals=precession.Jofr_infinity(xi,kappa_inf,r_vals,q,S1,S2)
</pre></div>


<p><strong>Parameters:</strong></p>
<ul>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>kappa_inf</code>: asymptotic value of kappa at large separations.</li>
<li><code>r_vals</code>: binary separation (array).</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>J_vals</code>: magnitude of the total angular momentum (array).</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.Jofr_infinity', this);">Show source &equiv;</a></p>
  <div id="source-precession.Jofr_infinity" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">Jofr_infinity</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">kappa_inf</span><span class="p">,</span><span class="n">r_vals</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">):</span> 

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Single integration of the dJ/dL equation to perfom precession-averaged</span>
<span class="sd">    inspiral. Input/output are provided in J and r, but the internal integrator</span>
<span class="sd">    uses kappa and u (see `precession.dkappadu`). Integration is performed using</span>
<span class="sd">    scipy&#39;s `odeint`.</span>

<span class="sd">    This function integrates FROM INFINITE separation (u=0) only.</span>

<span class="sd">    The latter must be consistent with `precession.kappainf_lim`; an error is</span>
<span class="sd">    raised in case of inconsistencies. It assume that the array r_vals is sorted</span>
<span class="sd">    in reversed order, i.e. that you are integrating from large to small</span>
<span class="sd">    separations. It returns a vector with the values of J at each input</span>
<span class="sd">    separation. The initial condition is NOT returned by this function (unlike</span>
<span class="sd">    the `precession.Jofr` for integrations to/from finite separations). If q=1,</span>
<span class="sd">    kappa_inf is degenerate with xi: the required initial condition is assumed</span>
<span class="sd">    to be S (which is constant).</span>

<span class="sd">    We recommend to use this function through the wrapper</span>
<span class="sd">    `precession.evolve_J_infinity` provided.</span>
<span class="sd"> </span>
<span class="sd">    **Call:**</span>

<span class="sd">        J_vals=precession.Jofr_infinity(xi,kappa_inf,r_vals,q,S1,S2)</span>

<span class="sd">    **Parameters:**</span>

<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `kappa_inf`: asymptotic value of kappa at large separations.</span>
<span class="sd">    - `r_vals`: binary separation (array).</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `J_vals`: magnitude of the total angular momentum (array).</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="c"># ASSUMES r_vals is sorted in reversed order!!!</span>
    <span class="n">L_vals</span><span class="o">=</span><span class="p">[</span> <span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">r_vals</span><span class="p">]</span>

    <span class="k">global</span> <span class="n">flags_q1</span> 
    <span class="k">if</span> <span class="n">q</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">flags_q1</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="o">==</span><span class="bp">False</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;[Jofr_infinity] Warning q=1: required intial condition is S, not kappa_inf.&quot;</span>
            <span class="n">flags_q1</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="o">=</span><span class="bp">True</span> <span class="c"># Suppress future warnings</span>
        <span class="n">S</span><span class="o">=</span><span class="n">kappa_inf</span>
        <span class="n">J_vals</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">xi</span><span class="o">*</span><span class="n">L</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">L</span> <span class="ow">in</span> <span class="n">L_vals</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">u_vals</span><span class="o">=</span><span class="p">[</span> <span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">L</span><span class="p">)</span> <span class="k">for</span> <span class="n">L</span> <span class="ow">in</span> <span class="n">L_vals</span><span class="p">]</span>
        <span class="n">u_vals</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.</span><span class="p">)</span> <span class="c"># Add initial condition, r=inifinty u=0</span>
    
        <span class="c"># Numerical integration from u=0   </span>
        <span class="c"># Increase h0 to prevent occasional slowing down of the integration</span>
        <span class="n">res</span> <span class="o">=</span><span class="n">integrate</span><span class="o">.</span><span class="n">odeint</span><span class="p">(</span><span class="n">dkappadu</span><span class="p">,</span> <span class="n">kappa_inf</span><span class="p">,</span> <span class="n">u_vals</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">),</span> <span class="n">mxstep</span><span class="o">=</span><span class="mi">50000</span><span class="p">,</span> <span class="n">full_output</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">printmessg</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">h0</span><span class="o">=</span><span class="mf">2e-4</span><span class="p">)</span>

        <span class="n">kappa_vals</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">res</span><span class="p">][</span><span class="mi">1</span><span class="p">:]</span> <span class="c"># Remove initial condition (not present in r_vals...)</span>
        <span class="n">J_vals</span><span class="o">=</span> <span class="p">[</span> <span class="p">(</span><span class="n">k</span><span class="o">*</span><span class="mf">2.</span><span class="o">*</span><span class="n">L</span> <span class="o">+</span> <span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">L</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">kappa_vals</span><span class="p">,</span><span class="n">L_vals</span><span class="p">)]</span>
    
    <span class="k">return</span> <span class="n">J_vals</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.Jofr_infinity_checkpoint">
    <p>def <span class="ident">Jofr_infinity_checkpoint</span>(</p><p>xi, kappa_inf, r_vals, q, S1, S2)</p>
    </div>
    

    
  
    <div class="desc"><p>Auxiliary function, see <a href="#precession.evolve_J_infinity"><code>evolve_J_infinity</code></a>.</p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>savename=precession.Jofr_infinity_checkpoint(xi,kappa_inf,r_vals,q,S1,S2)
</pre></div>


<p><strong>Parameters:</strong></p>
<ul>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>kappa_inf</code>: asymptotic value of kappa at large separations.</li>
<li><code>r_vals</code>: binary separation (array).</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>savename</code>: checkpoint filename.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.Jofr_infinity_checkpoint', this);">Show source &equiv;</a></p>
  <div id="source-precession.Jofr_infinity_checkpoint" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">Jofr_infinity_checkpoint</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">kappa_inf</span><span class="p">,</span><span class="n">r_vals</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">):</span>
    
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Auxiliary function, see `precession.evolve_J_infinity`.</span>
<span class="sd"> </span>
<span class="sd">    **Call:**</span>

<span class="sd">        savename=precession.Jofr_infinity_checkpoint(xi,kappa_inf,r_vals,q,S1,S2)</span>

<span class="sd">    **Parameters:**</span>

<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `kappa_inf`: asymptotic value of kappa at large separations.</span>
<span class="sd">    - `r_vals`: binary separation (array).</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `savename`: checkpoint filename.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s">&quot;mkdir -p &quot;</span><span class="o">+</span><span class="n">storedir</span><span class="p">)</span> 
    <span class="n">savename</span><span class="o">=</span> <span class="n">storedir</span><span class="o">+</span><span class="s">&quot;/evJinf_&quot;</span><span class="o">+</span><span class="s">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">kappa_inf</span><span class="p">,</span><span class="nb">max</span><span class="p">(</span><span class="n">r_vals</span><span class="p">),</span><span class="nb">min</span><span class="p">(</span><span class="n">r_vals</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">r_vals</span><span class="p">),</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">)])</span><span class="o">+</span><span class="s">&quot;.dat&quot;</span>
        
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">savename</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">&quot;[evolve_J_infinity] Transferring binary. Output:&quot;</span><span class="p">,</span> <span class="n">savename</span>
        <span class="n">outfilesave</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">savename</span><span class="p">,</span><span class="s">&quot;w&quot;</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
       
        <span class="n">J_vals</span><span class="o">=</span> <span class="n">Jofr_infinity</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">kappa_inf</span><span class="p">,</span><span class="n">r_vals</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">J_f</span><span class="p">,</span><span class="n">r_f</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">J_vals</span><span class="p">,</span><span class="n">r_vals</span><span class="p">):</span>        
            <span class="n">outfilesave</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">r_f</span><span class="p">)</span><span class="o">+</span><span class="s">&quot; &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">J_f</span><span class="p">)</span><span class="o">+</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
        <span class="n">outfilesave</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="c">#else:</span>
    <span class="c">#    print &quot;[evolve_J_infinity] Skipping. Output:&quot;, savename</span>
    
    <span class="k">return</span> <span class="n">savename</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.Omegaz">
    <p>def <span class="ident">Omegaz</span>(</p><p>S, xi, J, q, S1, S2, r)</p>
    </div>
    

    
  
    <div class="desc"><p>Compute the (azimuthal) precessional frequency of the orbital angular
momentum L about the total angular momentum J.</p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>Omega=precession.Omegaz(S,xi,J,q,S1,S2,r)
</pre></div>


<p><strong>Parameters:</strong></p>
<ul>
<li><code>S</code>: magnitude of the total spin.</li>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>J</code>: magnitude of the total angular momentum.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>r</code>: binary separation.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>Omega</code>: precessional frequency of L about J.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.Omegaz', this);">Show source &equiv;</a></p>
  <div id="source-precession.Omegaz" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">Omegaz</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Compute the (azimuthal) precessional frequency of the orbital angular</span>
<span class="sd">    momentum L about the total angular momentum J.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        Omega=precession.Omegaz(S,xi,J,q,S1,S2,r)</span>
<span class="sd">    </span>
<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `S`: magnitude of the total spin.</span>
<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `J`: magnitude of the total angular momentum.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `r`: binary separation.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `Omega`: precessional frequency of L about J.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">L</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
    <span class="n">eta</span><span class="o">=</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">t1</span><span class="o">=</span><span class="p">(</span><span class="n">J</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span><span class="o">*</span><span class="p">((</span><span class="n">eta</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="o">/</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">t2</span><span class="o">=</span><span class="p">(</span><span class="mf">3.</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">eta</span><span class="p">))</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="p">(</span><span class="n">eta</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">xi</span><span class="o">/</span><span class="n">L</span><span class="p">))</span>
    <span class="n">t3</span><span class="o">=</span><span class="p">(</span><span class="mf">3.</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">q</span><span class="o">*</span><span class="p">(</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="n">S</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">((</span><span class="n">L</span><span class="o">+</span><span class="n">S</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="p">)))</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="p">(</span><span class="n">eta</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">xi</span><span class="o">/</span><span class="n">L</span><span class="p">))</span>
    <span class="n">t4</span><span class="o">=</span><span class="mf">4.</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">S1</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">t5</span><span class="o">=</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="mf">4.</span><span class="o">*</span><span class="n">eta</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">L</span><span class="o">*</span><span class="n">xi</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">t1</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">t2</span><span class="o">-</span><span class="n">t3</span><span class="o">*</span><span class="p">(</span><span class="n">t4</span><span class="o">-</span><span class="n">t5</span><span class="p">))</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.OmegazdtdS">
    <p>def <span class="ident">OmegazdtdS</span>(</p><p>S, xi, J, q, S1, S2, r, sign=1.0)</p>
    </div>
    

    
  
    <div class="desc"><p>Auxiliary function Omega_z * dt/dS. See <a href="#precession.Omegaz"><code>Omegaz</code></a> and <a href="#precession.dSdt"><code>dSdt</code></a>.</p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>OmegadtdS=precession.OmegazdtdS(S,xi,J,q,S1,S2,r,sign=1.):
</pre></div>


<p><strong>Parameters:</strong></p>
<ul>
<li><code>S</code>: magnitude of the total spin.</li>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>J</code>: magnitude of the total angular momentum.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>r</code>: binary separation.</li>
<li><code>sign</code>: if 1 return angle in [0,pi], if -1 return angle in [-pi,0].</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>OmegadtdS</code>: Omega_z * dt/dS.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.OmegazdtdS', this);">Show source &equiv;</a></p>
  <div id="source-precession.OmegazdtdS" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">OmegazdtdS</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">sign</span><span class="o">=</span><span class="mf">1.</span><span class="p">):</span>
    
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Auxiliary function Omega_z * dt/dS. See `precession.Omegaz` and `precession.dSdt`.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        OmegadtdS=precession.OmegazdtdS(S,xi,J,q,S1,S2,r,sign=1.):</span>
<span class="sd">    </span>
<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `S`: magnitude of the total spin.</span>
<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `J`: magnitude of the total angular momentum.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `r`: binary separation.</span>
<span class="sd">    - `sign`: if 1 return angle in [0,pi], if -1 return angle in [-pi,0].</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `OmegadtdS`: Omega_z * dt/dS.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">global</span> <span class="n">flags_q1</span>
    <span class="k">if</span> <span class="n">q</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">flags_q1</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="o">==</span><span class="bp">False</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;[OmegazdtdS] Warning q=1: input here is cos(varphi), not S; now computing Omegaz * dt / d(cos(varphi))&quot;</span>
            <span class="n">flags_q1</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="o">=</span><span class="bp">True</span>
        <span class="n">cosvarphi</span><span class="o">=</span><span class="n">S</span> <span class="c"># The input variable is actually cos(varphi)</span>
        <span class="n">L</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
        <span class="n">S</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">xi</span><span class="o">*</span><span class="n">L</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Omegaz</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dSdt</span><span class="p">(</span><span class="n">cosvarphi</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">sign</span><span class="p">))</span>
    
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Omegaz</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dSdt</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">sign</span><span class="p">))</span> 
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.S3sines_comp">
    <p>def <span class="ident">S3sines_comp</span>(</p><p>S, xi, kappa, q, S1, S2, u)</p>
    </div>
    

    
  
    <div class="desc"><p>Auxiliary function, see <a href="#precession.dkappadu"><code>dkappadu</code></a>.</p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>denominator=precession.S3sines_comp(S,xi,kappa,q,S1,S2,u)
</pre></div>


<p><strong>Parameters:</strong></p>
<ul>
<li><code>S</code>: magnitude of the total spin.</li>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>kappa</code>: rescaling of the total angular momentum to compactify the inspiral domain.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>u</code>: rescaling of the orbital angular momentum to compactify the inspiral domain.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>denominator</code>: denominator in integrand <code>precession.dkappapu</code>.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.S3sines_comp', this);">Show source &equiv;</a></p>
  <div id="source-precession.S3sines_comp" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">S3sines_comp</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">kappa</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">u</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Auxiliary function, see `precession.dkappadu`.</span>
<span class="sd">        </span>
<span class="sd">    **Call:**</span>

<span class="sd">        denominator=precession.S3sines_comp(S,xi,kappa,q,S1,S2,u)</span>

<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `S`: magnitude of the total spin.</span>
<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `kappa`: rescaling of the total angular momentum to compactify the inspiral domain.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `u`: rescaling of the orbital angular momentum to compactify the inspiral domain.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `denominator`: denominator in integrand `precession.dkappapu`.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">ct1</span><span class="o">=</span> <span class="p">(</span> <span class="n">kappa</span> <span class="o">-</span> <span class="n">u</span><span class="o">*</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span>  <span class="o">-</span> <span class="n">q</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">xi</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span> <span class="p">)</span><span class="o">/</span><span class="p">((</span><span class="mf">1.</span><span class="o">-</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">S1</span><span class="p">)</span>
    <span class="n">ct2</span><span class="o">=</span> <span class="n">q</span><span class="o">*</span><span class="p">(</span> <span class="o">-</span><span class="n">kappa</span> <span class="o">+</span> <span class="n">u</span><span class="o">*</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span>  <span class="o">+</span> <span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">xi</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span> <span class="p">)</span><span class="o">/</span><span class="p">((</span><span class="mf">1.</span><span class="o">-</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">S2</span><span class="p">)</span>
    <span class="n">ct12</span><span class="o">=</span><span class="p">(</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S1</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">S1</span><span class="o">*</span><span class="n">S2</span><span class="p">)</span>
    <span class="n">t3</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">ct1</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">ct2</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">ct12</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span><span class="mf">2.</span><span class="o">*</span><span class="n">ct1</span><span class="o">*</span><span class="n">ct2</span><span class="o">*</span><span class="n">ct12</span><span class="p">))</span><span class="o">**.</span><span class="mi">5</span><span class="p">,</span> <span class="mf">1e-20</span><span class="p">)</span> <span class="c"># I know abs is dirty, but does the job </span>
    <span class="k">if</span> <span class="n">t3</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="c"># prevent occasional crash</span>
        <span class="n">t3</span><span class="o">=</span><span class="mf">1e-20</span>
    <span class="k">return</span> <span class="n">S</span><span class="o">**</span><span class="mi">3</span><span class="o">/</span><span class="n">t3</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.S_of_t">
    <p>def <span class="ident">S_of_t</span>(</p><p>t, Sb_min, Sb_max, xi, J, q, S1, S2, r)</p>
    </div>
    

    
  
    <div class="desc"><p>Integrate <a href="#precession.dSdt"><code>dSdt</code></a> to find S (time) as a function of t (magnitude
of the total spin). In practice, this is done by inverting 
<a href="#precession.t_of_S"><code>t_of_S</code></a>. Sb_min and Sb_max are passed to this function (and not
computed within it) for computational efficiency. This function can only
integrate over half precession period (i.e. from 0 to tau/2 at most). If you
want S(t) over more precession periods you should stich different solutions
together, consistently with the argument sign (in particular, flip sign
every half period).</p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>S=precession.S_of_t(t,Sb_min,Sb_max,xi,J,q,S1,S2,r,t_initial=0,sign=1.)
</pre></div>


<p><strong>Parameters:</strong></p>
<ul>
<li><code>t</code>: time (in total mass units).</li>
<li><code>S_final</code>: upper edge of the integration domain.</li>
<li><code>Sb_min</code>: minimum value of S from geometrical constraints. This is S- in our papers.</li>
<li><code>Sb_max</code>: maximum value of S from geometrical constraints. This is S+ in our papers.</li>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>J</code>: magnitude of the total angular momentum.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>r</code>: binary separation.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>S</code>: magnitude of the total spin.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.S_of_t', this);">Show source &equiv;</a></p>
  <div id="source-precession.S_of_t" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">S_of_t</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">Sb_min</span><span class="p">,</span><span class="n">Sb_max</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Integrate `precession.dSdt` to find S (time) as a function of t (magnitude</span>
<span class="sd">    of the total spin). In practice, this is done by inverting </span>
<span class="sd">    `precession.t_of_S`. Sb_min and Sb_max are passed to this function (and not</span>
<span class="sd">    computed within it) for computational efficiency. This function can only</span>
<span class="sd">    integrate over half precession period (i.e. from 0 to tau/2 at most). If you</span>
<span class="sd">    want S(t) over more precession periods you should stich different solutions</span>
<span class="sd">    together, consistently with the argument sign (in particular, flip sign</span>
<span class="sd">    every half period).</span>

<span class="sd">    **Call:**</span>

<span class="sd">        S=precession.S_of_t(t,Sb_min,Sb_max,xi,J,q,S1,S2,r,t_initial=0,sign=1.)</span>
<span class="sd">    </span>
<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `t`: time (in total mass units).</span>
<span class="sd">    - `S_final`: upper edge of the integration domain.</span>
<span class="sd">    - `Sb_min`: minimum value of S from geometrical constraints. This is S- in our papers.</span>
<span class="sd">    - `Sb_max`: maximum value of S from geometrical constraints. This is S+ in our papers.</span>
<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `J`: magnitude of the total angular momentum.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `r`: binary separation.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `S`: magnitude of the total spin.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">tau</span><span class="o">=</span><span class="n">precession_period</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>

    <span class="k">global</span> <span class="n">flags_q1</span>
    <span class="k">if</span> <span class="n">q</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">flags_q1</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">==</span><span class="bp">False</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;[S_of_t] Warning q=1: output here is cos(varphi) not S; now computing cos(varphi)(t) )&quot;</span>
            <span class="n">flags_q1</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">=</span><span class="bp">True</span>
            
        <span class="n">L</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">xi</span><span class="o">*</span><span class="n">L</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">S_min</span><span class="p">,</span><span class="n">S_max</span><span class="o">=</span><span class="n">St_limits</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">S</span><span class="o">-</span><span class="n">S_min</span><span class="p">)</span><span class="o">&lt;</span><span class="mf">1e-8</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">S</span><span class="o">-</span><span class="n">S_max</span><span class="p">)</span><span class="o">&lt;</span><span class="mf">1e-8</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;[S_of_t] Warning: you are at resonance, varphi is ill defined here.&quot;</span>
            <span class="k">return</span> <span class="mf">0.</span>
        <span class="k">elif</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">t</span> <span class="o">&gt;</span> <span class="n">tau</span><span class="o">/</span><span class="mf">2.</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">False</span><span class="p">,</span> <span class="s">&quot;[S_of_t] Error. You&#39;re trying to integrate over more than one (half)period&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">S</span><span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="k">lambda</span> <span class="n">S</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span> <span class="n">sp</span><span class="o">.</span><span class="n">integrate</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="n">dtdS</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">))[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="n">t</span> <span class="p">,</span> <span class="n">Sb_min</span><span class="p">,</span> <span class="n">Sb_max</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">S</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Sb_min</span><span class="o">-</span><span class="n">Sb_max</span><span class="p">)</span><span class="o">&lt;</span><span class="mf">1e-8</span><span class="p">:</span> <span class="c"># This happens when [Sb_limits] fails in bracketing of the solutions. In practice, this is a resonant binary.</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">Sb_min</span><span class="p">,</span><span class="n">Sb_min</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">t</span> <span class="o">&gt;</span> <span class="n">tau</span><span class="o">/</span><span class="mf">2.</span><span class="p">:</span>
        <span class="k">assert</span> <span class="bp">False</span><span class="p">,</span> <span class="s">&quot;[S_of_t] Error. You&#39;re trying to integrate over more than one (half)period&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">S</span><span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="k">lambda</span> <span class="n">S</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span> <span class="n">sp</span><span class="o">.</span><span class="n">integrate</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="n">dtdS</span><span class="p">,</span> <span class="n">Sb_min</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">))[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="n">t</span> <span class="p">,</span> <span class="n">Sb_min</span><span class="p">,</span> <span class="n">Sb_max</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">S</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.Sb_limits">
    <p>def <span class="ident">Sb_limits</span>(</p><p>xi, J, q, S1, S2, r)</p>
    </div>
    

    
  
    <div class="desc"><p>Compute the <em>bounded</em> limits on S, using xi as a constant of motion. The
routine first guesses where the extrema are expected to be, then brakets the
solution, and finally runs root finder. In some cases the braketing may
fail: this typically happens if the two roots are very close (DeltaS&lt;1e-8)
and cannot be distinguished numerically. In this case, assume Sb_min=Sb_max.</p>
<p>WARNING: This function is critical. It is well tested, but is tricky
numerical issues may still be present.</p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>Sb_min,Sb_max=precession.Sb_limits(xi,J,q,S1,S2,r)
</pre></div>


<p><strong>Parameters:</strong></p>
<ul>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>J</code>: magnitude of the total angular momentum.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>r</code>: binary separation.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>Sb_min</code>: minimum value of S from geometrical constraints. This is S- in our papers.</li>
<li><code>Sb_max</code>: maximum value of S from geometrical constraints. This is S+ in our papers.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.Sb_limits', this);">Show source &equiv;</a></p>
  <div id="source-precession.Sb_limits" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">Sb_limits</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">):</span>
    
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Compute the *bounded* limits on S, using xi as a constant of motion. The</span>
<span class="sd">    routine first guesses where the extrema are expected to be, then brakets the</span>
<span class="sd">    solution, and finally runs root finder. In some cases the braketing may</span>
<span class="sd">    fail: this typically happens if the two roots are very close (DeltaS&lt;1e-8)</span>
<span class="sd">    and cannot be distinguished numerically. In this case, assume Sb_min=Sb_max.</span>

<span class="sd">    WARNING: This function is critical. It is well tested, but is tricky</span>
<span class="sd">    numerical issues may still be present.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        Sb_min,Sb_max=precession.Sb_limits(xi,J,q,S1,S2,r)</span>

<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `J`: magnitude of the total angular momentum.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `r`: binary separation.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `Sb_min`: minimum value of S from geometrical constraints. This is S- in our papers.</span>
<span class="sd">    - `Sb_max`: maximum value of S from geometrical constraints. This is S+ in our papers.   </span>
<span class="sd">    &#39;&#39;&#39;</span>
 
    <span class="n">St_min</span><span class="p">,</span><span class="n">St_max</span><span class="o">=</span><span class="n">St_limits</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">St_max</span><span class="o">&lt;</span><span class="n">St_min</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&quot;[Sb_limits] Problem in the absolute limits at r=&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="o">+</span><span class="s">&quot;. Assume Sb_min=Sb_max=mean(St_min,St_max)&quot;</span>        
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">St_min</span><span class="p">,</span><span class="n">St_max</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">St_min</span><span class="p">,</span><span class="n">St_max</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">q</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="c"># if q=1 the effective potential loop shrinks to a lime (Sb_min=Sb_max) and the equations xi_/pm(S)=xi can be solved analytically.</span>
        <span class="n">L</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
        <span class="n">Sb_both</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">xi</span><span class="o">*</span><span class="n">L</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Sb_both</span><span class="p">,</span><span class="n">Sb_both</span>

    <span class="c"># Remember: xi_minus=xi_plus at St_min and St_max</span>
    <span class="n">xi_low</span><span class="o">=</span><span class="n">xi_minus</span><span class="p">(</span><span class="n">St_min</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span> 
    <span class="n">xi_up</span><span class="o">=</span><span class="n">xi_minus</span><span class="p">(</span><span class="n">St_max</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
 
    <span class="c">#Debug option: print the parameter-space region of the initial guess</span>
    <span class="n">whereareyou</span><span class="o">=</span><span class="bp">False</span>
 
    <span class="c"># Both roots on xi_plus. Split the interval first</span>
    <span class="k">if</span> <span class="n">xi</span> <span class="o">&gt;</span> <span class="n">xi_low</span> <span class="ow">and</span> <span class="n">xi</span> <span class="o">&gt;</span> <span class="n">xi_up</span><span class="p">:</span>    
        <span class="k">if</span> <span class="n">whereareyou</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;[Sb_limits] Both roots on xi_plus&quot;</span>
        
        <span class="n">resmax</span><span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">fminbound</span><span class="p">(</span><span class="k">lambda</span> <span class="n">S</span><span class="p">:</span> <span class="o">-</span><span class="mf">1.</span><span class="o">*</span><span class="n">xi_plus</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">),</span> <span class="n">St_min</span><span class="p">,</span> <span class="n">St_max</span><span class="p">,</span><span class="n">full_output</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">S_up</span><span class="o">=</span><span class="n">resmax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">xi_max</span><span class="o">=-</span><span class="mf">1.</span><span class="o">*</span><span class="n">resmax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        
        <span class="k">if</span> <span class="n">xi_max</span><span class="o">&lt;</span><span class="n">xi</span><span class="p">:</span> <span class="c">#Braket failed!</span>
            <span class="k">print</span> <span class="s">&quot;[Sb_limits] Braket failed on xi_plus at r=&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="o">+</span><span class="s">&quot;. Assume Sb_min=Sb_max&quot;</span>
            <span class="c">#print  xi_plus(S_up,J,q,S1,S2,r), xi</span>
            <span class="n">Sb_min</span><span class="o">=</span><span class="n">S_up</span>
            <span class="n">Sb_max</span><span class="o">=</span><span class="n">S_up</span>  
        <span class="k">else</span><span class="p">:</span> <span class="c">#Braket succeeded!</span>
            <span class="n">Sb_min</span><span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="k">lambda</span> <span class="n">S</span><span class="p">:</span> <span class="n">xi_plus</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span><span class="o">-</span><span class="n">xi</span><span class="p">,</span> <span class="n">St_min</span><span class="p">,</span> <span class="n">S_up</span><span class="p">)</span>
            <span class="n">Sb_max</span><span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="k">lambda</span> <span class="n">S</span><span class="p">:</span> <span class="n">xi_plus</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span><span class="o">-</span><span class="n">xi</span><span class="p">,</span> <span class="n">S_up</span><span class="p">,</span> <span class="n">St_max</span><span class="p">)</span>

    <span class="c"># Both roots on xi_minus. Split the interval first</span>
    <span class="k">elif</span> <span class="n">xi</span> <span class="o">&lt;</span> <span class="n">xi_low</span> <span class="ow">and</span> <span class="n">xi</span> <span class="o">&lt;</span> <span class="n">xi_up</span><span class="p">:</span>    
        <span class="k">if</span> <span class="n">whereareyou</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;[Sb_limits] Both roots on xi_minus&quot;</span>
            
        <span class="n">resmin</span><span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">fminbound</span><span class="p">(</span><span class="k">lambda</span> <span class="n">S</span><span class="p">:</span> <span class="n">xi_minus</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">),</span> <span class="n">St_min</span><span class="p">,</span> <span class="n">St_max</span><span class="p">,</span><span class="n">full_output</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">S_low</span><span class="o">=</span><span class="n">resmin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">xi_min</span><span class="o">=</span><span class="n">resmin</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                 
        <span class="k">if</span> <span class="n">xi_min</span><span class="o">&gt;</span><span class="n">xi</span><span class="p">:</span> <span class="c">#Braket failed! </span>
            <span class="k">print</span> <span class="s">&quot;[Sb_limits] Braket failed on xi_minus at r=&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">r</span><span class="p">)</span><span class="o">+</span><span class="s">&quot;. Assume Sb_min=Sb_max&quot;</span>
            <span class="n">Sb_min</span><span class="o">=</span><span class="n">S_low</span>
            <span class="n">Sb_max</span><span class="o">=</span><span class="n">S_low</span>  
        <span class="k">else</span><span class="p">:</span> <span class="c">#Braket succeeded!</span>
            <span class="n">Sb_min</span><span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="k">lambda</span> <span class="n">S</span><span class="p">:</span> <span class="n">xi_minus</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span><span class="o">-</span><span class="n">xi</span><span class="p">,</span> <span class="n">St_min</span><span class="p">,</span> <span class="n">S_low</span><span class="p">)</span>
            <span class="n">Sb_max</span><span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="k">lambda</span> <span class="n">S</span><span class="p">:</span> <span class="n">xi_minus</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span><span class="o">-</span><span class="n">xi</span><span class="p">,</span> <span class="n">S_low</span><span class="p">,</span> <span class="n">St_max</span><span class="p">)</span>

    <span class="c"># One root on xi_plus and the other one on xi_plus. No additional maximization is neeeded</span>
    <span class="k">elif</span> <span class="n">xi</span> <span class="o">&gt;=</span> <span class="n">xi_low</span> <span class="ow">and</span> <span class="n">xi</span> <span class="o">&lt;=</span> <span class="n">xi_up</span><span class="p">:</span>    
        <span class="k">if</span> <span class="n">whereareyou</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;[Sb_limits] Sb_min on xi_plus, Sb_max on xi_minus&quot;</span>

        <span class="n">Sb_min</span><span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="k">lambda</span> <span class="n">S</span><span class="p">:</span> <span class="n">xi_plus</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span><span class="o">-</span><span class="n">xi</span><span class="p">,</span> <span class="n">St_min</span><span class="p">,</span> <span class="n">St_max</span><span class="p">)</span>
        <span class="n">Sb_max</span><span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="k">lambda</span> <span class="n">S</span><span class="p">:</span> <span class="n">xi_minus</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span><span class="o">-</span><span class="n">xi</span><span class="p">,</span> <span class="n">St_min</span><span class="p">,</span> <span class="n">St_max</span><span class="p">)</span>
    
    <span class="k">elif</span> <span class="n">xi</span> <span class="o">&lt;=</span> <span class="n">xi_low</span> <span class="ow">and</span> <span class="n">xi</span> <span class="o">&gt;=</span> <span class="n">xi_up</span><span class="p">:</span>    
        <span class="k">if</span> <span class="n">whereareyou</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;[Sb_limits] Sb_min on xi_minus, Sb_max on xi_plus&quot;</span>

        <span class="n">Sb_min</span><span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="k">lambda</span> <span class="n">S</span><span class="p">:</span> <span class="n">xi_minus</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span><span class="o">-</span><span class="n">xi</span><span class="p">,</span> <span class="n">St_min</span><span class="p">,</span> <span class="n">St_max</span><span class="p">)</span>
        <span class="n">Sb_max</span><span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="k">lambda</span> <span class="n">S</span><span class="p">:</span> <span class="n">xi_plus</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span><span class="o">-</span><span class="n">xi</span><span class="p">,</span> <span class="n">St_min</span><span class="p">,</span> <span class="n">St_max</span><span class="p">)</span>
                    
    <span class="k">else</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&quot;[Sb_limits] Erorr in case selection&quot;</span>
        <span class="k">print</span> <span class="s">&quot;xi=&quot;</span><span class="p">,</span> <span class="n">xi</span>
        <span class="k">print</span> <span class="s">&quot;xi(Stmin)=&quot;</span><span class="p">,</span> <span class="n">xi_low</span>
        <span class="k">print</span> <span class="s">&quot;xi(Stmax)=&quot;</span><span class="p">,</span> <span class="n">xi_up</span>
        <span class="k">print</span> <span class="s">&quot;Stmin=&quot;</span><span class="p">,</span> <span class="n">St_min</span>
        <span class="k">print</span> <span class="s">&quot;Stmax&quot;</span><span class="p">,</span> <span class="n">St_max</span>
        <span class="k">print</span> <span class="s">&quot;J=&quot;</span><span class="p">,</span> <span class="n">J</span>
        <span class="k">print</span> <span class="s">&quot;L=&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
        <span class="k">print</span> <span class="s">&quot;r=&quot;</span><span class="p">,</span> <span class="n">r</span>
        <span class="k">assert</span> <span class="bp">False</span><span class="p">,</span> <span class="s">&quot;[Sb_limits] Erorr in case selection&quot;</span>
    
    <span class="n">btol</span><span class="o">=</span><span class="mf">1e-8</span> <span class="c"># Never go to close to the actual limits, because of numerical stabilty</span>
    <span class="n">Sb_min</span><span class="o">+=</span><span class="n">btol</span>
    <span class="n">Sb_max</span><span class="o">-=</span><span class="n">btol</span>

    <span class="k">if</span> <span class="n">whereareyou</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&quot;[Sb_limits] Results:&quot;</span><span class="p">,</span> <span class="n">Sb_min</span><span class="p">,</span><span class="n">Sb_max</span>
    
    <span class="k">if</span> <span class="n">Sb_min</span><span class="o">&gt;</span><span class="n">Sb_max</span><span class="p">:</span> <span class="c"># This may happen (numerically) if they&#39;re too close to each other. Assume they&#39;re the same.</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">Sb_min</span><span class="p">,</span><span class="n">Sb_max</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">Sb_min</span><span class="p">,</span><span class="n">Sb_max</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span> 
        <span class="k">return</span> <span class="n">Sb_min</span><span class="p">,</span> <span class="n">Sb_max</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.Sb_limits_comp">
    <p>def <span class="ident">Sb_limits_comp</span>(</p><p>xi, kappa, q, S1, S2, u)</p>
    </div>
    

    
  
    <div class="desc"><p>Auxiliary function, see <a href="#precession.Sb_limits"><code>Sb_limits</code></a>.</p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>Sb_min,Sb_max=precession.Sb_limits_comp(xi,kappa,q,S1,S2,u)
</pre></div>


<p><strong>Parameters:</strong></p>
<ul>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>kappa</code>: rescaling of the total angular momentum to compactify the inspiral domain.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>u</code>: rescaling of the orbital angular momentum to compactify the inspiral domain.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>Sb_min</code>: minimum value of S from geometrical constraints. This is S- in our papers.</li>
<li><code>Sb_max</code>: maximum value of S from geometrical constraints. This is S+ in our papers.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.Sb_limits_comp', this);">Show source &equiv;</a></p>
  <div id="source-precession.Sb_limits_comp" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">Sb_limits_comp</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">kappa</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">u</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Auxiliary function, see `precession.Sb_limits`.</span>
<span class="sd">        </span>
<span class="sd">    **Call:**</span>

<span class="sd">        Sb_min,Sb_max=precession.Sb_limits_comp(xi,kappa,q,S1,S2,u)</span>

<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `kappa`: rescaling of the total angular momentum to compactify the inspiral domain.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `u`: rescaling of the orbital angular momentum to compactify the inspiral domain.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `Sb_min`: minimum value of S from geometrical constraints. This is S- in our papers.</span>
<span class="sd">    - `Sb_max`: maximum value of S from geometrical constraints. This is S+ in our papers.   </span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">global</span> <span class="n">flags_q1</span>
    <span class="k">if</span> <span class="n">q</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">u</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">flags_q1</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span><span class="o">==</span><span class="bp">False</span><span class="p">:</span>
                <span class="k">print</span> <span class="s">&quot;[Sb_limits_comp] Warning q=1,u=0: input for kappa means S&quot;</span>
                <span class="n">flags_q1</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span><span class="o">=</span><span class="bp">True</span>
            <span class="n">Sb_both</span><span class="o">=</span><span class="n">kappa</span>
        <span class="k">else</span><span class="p">:</span>
           <span class="n">Sb_both</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">kappa</span><span class="o">/</span><span class="n">u</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="n">xi</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">u</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Sb_both</span><span class="p">,</span><span class="n">Sb_both</span>

    <span class="n">St_min</span><span class="p">,</span><span class="n">St_max</span><span class="o">=</span><span class="n">St_limits_comp</span><span class="p">(</span><span class="n">kappa</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">u</span><span class="p">)</span>
    <span class="n">xi_low</span><span class="o">=</span><span class="n">xi_minus_comp</span><span class="p">(</span><span class="n">St_min</span><span class="p">,</span><span class="n">kappa</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">u</span><span class="p">)</span> 
    <span class="n">xi_up</span><span class="o">=</span><span class="n">xi_minus_comp</span><span class="p">(</span><span class="n">St_max</span><span class="p">,</span><span class="n">kappa</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">u</span><span class="p">)</span>
 
    <span class="c">#Debug option: print the parameter-space region of the initial guess</span>
    <span class="n">whereareyou</span><span class="o">=</span><span class="bp">False</span>
 
    <span class="c"># Both roots on xi_plus. Split the interval first</span>
    <span class="k">if</span> <span class="n">xi</span> <span class="o">&gt;</span> <span class="n">xi_low</span> <span class="ow">and</span> <span class="n">xi</span> <span class="o">&gt;</span> <span class="n">xi_up</span><span class="p">:</span>    

        <span class="k">if</span> <span class="n">whereareyou</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;[Sb_limits_comp] Both roots on xi_plus&quot;</span>

        <span class="n">resmax</span><span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">fminbound</span><span class="p">(</span><span class="k">lambda</span> <span class="n">S</span><span class="p">:</span> <span class="o">-</span><span class="mf">1.</span><span class="o">*</span><span class="n">xi_plus_comp</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">kappa</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">u</span><span class="p">),</span> <span class="n">St_min</span><span class="p">,</span> <span class="n">St_max</span><span class="p">,</span><span class="n">full_output</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">S_up</span><span class="o">=</span><span class="n">resmax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">xi_max</span><span class="o">=-</span><span class="mf">1.</span><span class="o">*</span><span class="n">resmax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">xi_max</span><span class="o">&lt;</span><span class="n">xi</span><span class="p">:</span> <span class="c">#Braket failed!</span>
            <span class="k">print</span> <span class="s">&quot;[Sb_limits_comp] Braket failed on xi_plus at u=&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">+</span><span class="s">&quot;. Assume Sb_min=Sb_max&quot;</span>
            <span class="c">#print  xi_plus(S_up,J,q,S1,S2,r), xi</span>
            <span class="n">Sb_min</span><span class="o">=</span><span class="n">S_up</span>
            <span class="n">Sb_max</span><span class="o">=</span><span class="n">S_up</span>  
        <span class="k">else</span><span class="p">:</span> <span class="c">#Braket succeeded!</span>
                    
            <span class="n">Sb_min</span><span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="k">lambda</span> <span class="n">S</span><span class="p">:</span> <span class="n">xi_plus_comp</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">kappa</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">u</span><span class="p">)</span><span class="o">-</span><span class="n">xi</span><span class="p">,</span> <span class="n">St_min</span><span class="p">,</span> <span class="n">S_up</span><span class="p">)</span>
            <span class="n">Sb_max</span><span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="k">lambda</span> <span class="n">S</span><span class="p">:</span> <span class="n">xi_plus_comp</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">kappa</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">u</span><span class="p">)</span><span class="o">-</span><span class="n">xi</span><span class="p">,</span> <span class="n">S_up</span><span class="p">,</span> <span class="n">St_max</span><span class="p">)</span>

    <span class="c"># Both roots on xi_minus. Split the interval first</span>
    <span class="k">elif</span> <span class="n">xi</span> <span class="o">&lt;</span> <span class="n">xi_low</span> <span class="ow">and</span> <span class="n">xi</span> <span class="o">&lt;</span> <span class="n">xi_up</span><span class="p">:</span>    
        
        <span class="k">if</span> <span class="n">whereareyou</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;[Sb_limits_comp] Both roots on xi_minus&quot;</span>
            
        <span class="n">resmin</span><span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">fminbound</span><span class="p">(</span><span class="k">lambda</span> <span class="n">S</span><span class="p">:</span> <span class="n">xi_minus_comp</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">kappa</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">u</span><span class="p">),</span> <span class="n">St_min</span><span class="p">,</span> <span class="n">St_max</span><span class="p">,</span><span class="n">full_output</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">S_low</span><span class="o">=</span><span class="n">resmin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">xi_min</span><span class="o">=</span><span class="n">resmin</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                 
        <span class="k">if</span> <span class="n">xi_min</span><span class="o">&gt;</span><span class="n">xi</span><span class="p">:</span> <span class="c">#Braket failed! </span>
            <span class="k">print</span> <span class="s">&quot;[Sb_limits_comp] Braket failed on xi_minus at u=&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">+</span><span class="s">&quot;. Assume Sb_min=Sb_max&quot;</span>
            <span class="n">Sb_min</span><span class="o">=</span><span class="n">S_low</span>
            <span class="n">Sb_max</span><span class="o">=</span><span class="n">S_low</span>  
        <span class="k">else</span><span class="p">:</span> <span class="c">#Braket succeeded!</span>
            <span class="n">Sb_min</span><span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="k">lambda</span> <span class="n">S</span><span class="p">:</span> <span class="n">xi_minus_comp</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">kappa</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">u</span><span class="p">)</span><span class="o">-</span><span class="n">xi</span><span class="p">,</span> <span class="n">St_min</span><span class="p">,</span> <span class="n">S_low</span><span class="p">)</span>
            <span class="n">Sb_max</span><span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="k">lambda</span> <span class="n">S</span><span class="p">:</span> <span class="n">xi_minus_comp</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">kappa</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">u</span><span class="p">)</span><span class="o">-</span><span class="n">xi</span><span class="p">,</span> <span class="n">S_low</span><span class="p">,</span> <span class="n">St_max</span><span class="p">)</span>

    <span class="c"># One root on xi_plus and the other one on xi_plus. No additional maximization is neeeded</span>
    <span class="k">elif</span> <span class="n">xi</span> <span class="o">&gt;=</span> <span class="n">xi_low</span> <span class="ow">and</span> <span class="n">xi</span> <span class="o">&lt;=</span> <span class="n">xi_up</span><span class="p">:</span>    

        <span class="k">if</span> <span class="n">whereareyou</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;[Sb_limits_comp] Sb_min on xi_plus, Sb_max on xi_minus&quot;</span>

        <span class="n">Sb_min</span><span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="k">lambda</span> <span class="n">S</span><span class="p">:</span> <span class="n">xi_plus_comp</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">kappa</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">u</span><span class="p">)</span><span class="o">-</span><span class="n">xi</span><span class="p">,</span> <span class="n">St_min</span><span class="p">,</span> <span class="n">St_max</span><span class="p">)</span>
        <span class="n">Sb_max</span><span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="k">lambda</span> <span class="n">S</span><span class="p">:</span> <span class="n">xi_minus_comp</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">kappa</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">u</span><span class="p">)</span><span class="o">-</span><span class="n">xi</span><span class="p">,</span> <span class="n">St_min</span><span class="p">,</span> <span class="n">St_max</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">xi</span> <span class="o">&lt;=</span> <span class="n">xi_low</span> <span class="ow">and</span> <span class="n">xi</span> <span class="o">&gt;=</span> <span class="n">xi_up</span><span class="p">:</span>    
    
        <span class="k">if</span> <span class="n">whereareyou</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;[Sb_limits_comp] Sb_min on xi_minus, Sb_max on xi_plus&quot;</span>

        <span class="n">Sb_min</span><span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="k">lambda</span> <span class="n">S</span><span class="p">:</span> <span class="n">xi_minus_comp</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">kappa</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">u</span><span class="p">)</span><span class="o">-</span><span class="n">xi</span><span class="p">,</span> <span class="n">St_min</span><span class="p">,</span> <span class="n">St_max</span><span class="p">)</span>
        <span class="n">Sb_max</span><span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="k">lambda</span> <span class="n">S</span><span class="p">:</span> <span class="n">xi_plus_comp</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">kappa</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">u</span><span class="p">)</span><span class="o">-</span><span class="n">xi</span><span class="p">,</span> <span class="n">St_min</span><span class="p">,</span> <span class="n">St_max</span><span class="p">)</span>
                    
    <span class="k">else</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&quot;[Sb_limits_comp] Erorr in case selection&quot;</span>
        <span class="k">print</span> <span class="s">&quot;xi=&quot;</span><span class="p">,</span> <span class="n">xi</span>
        <span class="k">print</span> <span class="s">&quot;xi(stmin)=&quot;</span><span class="p">,</span> <span class="n">xi_low</span>
        <span class="k">print</span> <span class="s">&quot;xi(stmax)=&quot;</span><span class="p">,</span> <span class="n">xi_up</span>
        <span class="k">print</span> <span class="s">&quot;Stmin=&quot;</span><span class="p">,</span> <span class="n">St_min</span>
        <span class="k">print</span> <span class="s">&quot;Stmax&quot;</span><span class="p">,</span> <span class="n">St_max</span>
        <span class="k">print</span> <span class="s">&quot;kappa=&quot;</span><span class="p">,</span> <span class="n">kappa</span>
        <span class="k">print</span> <span class="s">&quot;u=&quot;</span><span class="p">,</span> <span class="n">u</span>
        <span class="k">assert</span> <span class="bp">False</span><span class="p">,</span> <span class="s">&quot;[Sb_limits_comp] Erorr in case selection&quot;</span>
        
    <span class="n">btol</span><span class="o">=</span><span class="mf">1e-8</span> <span class="c"># Never go to close to the actual limits, because everything blows up there</span>
    <span class="n">Sb_min</span><span class="o">+=</span><span class="n">btol</span>
    <span class="n">Sb_max</span><span class="o">-=</span><span class="n">btol</span>
    
    <span class="k">if</span> <span class="n">whereareyou</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&quot;[Sb_limits_comp] Results:&quot;</span><span class="p">,</span> <span class="n">Sb_min</span><span class="p">,</span><span class="n">Sb_max</span>
    
    
    <span class="k">if</span> <span class="n">Sb_min</span><span class="o">&gt;</span><span class="n">Sb_max</span><span class="p">:</span> <span class="c"># This may happen (numerically) if they&#39;re too close to each other. Assume they&#39;re the same.</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">Sb_min</span><span class="p">,</span><span class="n">Sb_max</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">Sb_min</span><span class="p">,</span><span class="n">Sb_max</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span> 
        <span class="k">return</span> <span class="n">Sb_min</span><span class="p">,</span> <span class="n">Sb_max</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.Ssines_comp">
    <p>def <span class="ident">Ssines_comp</span>(</p><p>S, xi, kappa, q, S1, S2, u)</p>
    </div>
    

    
  
    <div class="desc"><p>Auxiliary function, see <a href="#precession.dkappadu"><code>dkappadu</code></a>.</p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>numerator=precession.Ssines_comp(S,xi,kappa,q,S1,S2,u)
</pre></div>


<p><strong>Parameters:</strong></p>
<ul>
<li><code>S</code>: magnitude of the total spin.</li>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>kappa</code>: rescaling of the total angular momentum to compactify the inspiral domain.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>u</code>: rescaling of the orbital angular momentum to compactify the inspiral domain.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>numerator</code>: numerator in integrand <code>precession.dkappapu</code>.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.Ssines_comp', this);">Show source &equiv;</a></p>
  <div id="source-precession.Ssines_comp" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">Ssines_comp</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">kappa</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">u</span><span class="p">):</span>
    
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Auxiliary function, see `precession.dkappadu`.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        numerator=precession.Ssines_comp(S,xi,kappa,q,S1,S2,u)</span>

<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `S`: magnitude of the total spin.</span>
<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `kappa`: rescaling of the total angular momentum to compactify the inspiral domain.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `u`: rescaling of the orbital angular momentum to compactify the inspiral domain.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `numerator`: numerator in integrand `precession.dkappapu`.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="n">ct1</span><span class="o">=</span> <span class="p">(</span> <span class="n">kappa</span> <span class="o">-</span> <span class="n">u</span><span class="o">*</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span>  <span class="o">-</span> <span class="n">q</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">xi</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span> <span class="p">)</span><span class="o">/</span><span class="p">((</span><span class="mf">1.</span><span class="o">-</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">S1</span><span class="p">)</span>
    <span class="n">ct2</span><span class="o">=</span> <span class="n">q</span><span class="o">*</span><span class="p">(</span> <span class="o">-</span><span class="n">kappa</span> <span class="o">+</span> <span class="n">u</span><span class="o">*</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span>  <span class="o">+</span> <span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">xi</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span> <span class="p">)</span><span class="o">/</span><span class="p">((</span><span class="mf">1.</span><span class="o">-</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">S2</span><span class="p">)</span>
    <span class="n">ct12</span><span class="o">=</span><span class="p">(</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S1</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">S1</span><span class="o">*</span><span class="n">S2</span><span class="p">)</span>
    <span class="n">t3</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">ct1</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">ct2</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">ct12</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span><span class="mf">2.</span><span class="o">*</span><span class="n">ct1</span><span class="o">*</span><span class="n">ct2</span><span class="o">*</span><span class="n">ct12</span><span class="p">))</span><span class="o">**.</span><span class="mi">5</span><span class="p">,</span> <span class="mf">1e-20</span><span class="p">)</span> <span class="c"># I know abs is dirty, but does the job </span>
    <span class="k">return</span> <span class="n">S</span><span class="o">/</span><span class="n">t3</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.Sso_limits">
    <p>def <span class="ident">Sso_limits</span>(</p><p>S1, S2)</p>
    </div>
    

    
  
    <div class="desc"><p>Compute the <em>spin-only</em> limits on the magnitude of the total spin S,
considering the single constraint S=S1+S2.  This is needed e.g. to provide
initial condition to precession-averaged integration from infinity in the
q=1 limit.</p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>Sso_min,Sso_max=precession.Sso_limits(S1,S2)
</pre></div>


<p><strong>Parameters:</strong></p>
<ul>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>Sso_min</code>: minimum value of S from the spin constraint only.</li>
<li><code>Sso_max</code>: maximum value of S from the spin constraint only.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.Sso_limits', this);">Show source &equiv;</a></p>
  <div id="source-precession.Sso_limits" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">Sso_limits</span><span class="p">(</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">):</span>
    
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Compute the *spin-only* limits on the magnitude of the total spin S,</span>
<span class="sd">    considering the single constraint S=S1+S2.  This is needed e.g. to provide</span>
<span class="sd">    initial condition to precession-averaged integration from infinity in the</span>
<span class="sd">    q=1 limit.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        Sso_min,Sso_max=precession.Sso_limits(S1,S2)</span>

<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>

<span class="sd">    **Returns:**</span>
<span class="sd">    </span>
<span class="sd">    - `Sso_min`: minimum value of S from the spin constraint only.</span>
<span class="sd">    - `Sso_max`: maximum value of S from the spin constraint only.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">),</span> <span class="n">S1</span><span class="o">+</span><span class="n">S2</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.St_limits">
    <p>def <span class="ident">St_limits</span>(</p><p>J, q, S1, S2, r, verbose=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Compute the <em>total</em> limits on the magnitude of the total spin S. S has to
satisfy both S=S1+S2 and S=J-L.</p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>St_min,St_max=precession.St_limits(J,q,S1,S2,r,verbose=False)
</pre></div>


<p><strong>Parameters:</strong></p>
<ul>
<li><code>J</code>: magnitude of the total angular momentum.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>r</code>: binary separation.</li>
<li><code>verbose</code>: if <code>True</code> print additional information.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>St_min</code>: minimum value of S from geometrical constraints. This is S_min in our papers.</li>
<li><code>St_max</code>: maximum value of S from geometrical constraints. This is S_max in our papers.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.St_limits', this);">Show source &equiv;</a></p>
  <div id="source-precession.St_limits" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">St_limits</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
     
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Compute the *total* limits on the magnitude of the total spin S. S has to</span>
<span class="sd">    satisfy both S=S1+S2 and S=J-L.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        St_min,St_max=precession.St_limits(J,q,S1,S2,r,verbose=False)</span>
<span class="sd">    </span>
<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `J`: magnitude of the total angular momentum.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `r`: binary separation.</span>
<span class="sd">    - `verbose`: if `True` print additional information.</span>

<span class="sd">    **Returns:**</span>
<span class="sd">    </span>
<span class="sd">    - `St_min`: minimum value of S from geometrical constraints. This is S_min in our papers.</span>
<span class="sd">    - `St_max`: maximum value of S from geometrical constraints. This is S_max in our papers.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">ttol</span><span class="o">=</span><span class="mf">0.0</span>
    <span class="n">L</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
    <span class="n">St_min</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">J</span><span class="o">-</span><span class="n">L</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">)))</span>
    <span class="n">St_max</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="n">J</span><span class="o">+</span><span class="n">L</span><span class="p">,</span><span class="n">S1</span><span class="o">+</span><span class="n">S2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&quot;[S_lim] L=&quot;</span><span class="p">,</span><span class="n">L</span><span class="p">,</span> <span class="s">&quot; J&quot;</span><span class="p">,</span><span class="n">J</span><span class="p">,</span> <span class="s">&quot; S1=&quot;</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="s">&quot; S2=&quot;</span><span class="p">,</span><span class="n">S2</span>
        <span class="k">print</span> <span class="s">&quot;[S_lim] St_min=&quot;</span><span class="p">,</span><span class="n">St_min</span><span class="p">,</span> <span class="s">&quot; St_max=&quot;</span><span class="p">,</span><span class="n">St_max</span>
        <span class="k">if</span> <span class="n">St_min</span><span class="o">==</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">J</span><span class="o">-</span><span class="n">L</span><span class="p">)</span> <span class="ow">and</span> <span class="n">St_max</span><span class="o">==</span><span class="n">J</span><span class="o">+</span><span class="n">L</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;[S_lim] St_min=|J-L|, St_max=J+L&quot;</span>
        <span class="k">elif</span> <span class="n">St_min</span><span class="o">==</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">J</span><span class="o">-</span><span class="n">L</span><span class="p">)</span> <span class="ow">and</span> <span class="n">St_max</span><span class="o">==</span><span class="n">S1</span><span class="o">+</span><span class="n">S2</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;[S_lim] St_min=|J-L|, St_max=S1+S2&quot;</span>
        <span class="k">elif</span> <span class="n">St_min</span><span class="o">==</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">)</span> <span class="ow">and</span> <span class="n">St_max</span><span class="o">==</span><span class="n">J</span><span class="o">+</span><span class="n">L</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;[S_lim] St_min=|S1-S2|, St_max=J+L&quot;</span>
        <span class="k">elif</span> <span class="n">St_min</span><span class="o">==</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">)</span> <span class="ow">and</span> <span class="n">St_max</span><span class="o">==</span><span class="n">S1</span><span class="o">+</span><span class="n">S2</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;[S_lim] St_min=|S1-S2|, St_max=S1+S2&quot;</span>

    <span class="k">return</span> <span class="n">St_min</span><span class="o">+</span><span class="n">ttol</span><span class="p">,</span><span class="n">St_max</span><span class="o">-</span><span class="n">ttol</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.St_limits_comp">
    <p>def <span class="ident">St_limits_comp</span>(</p><p>kappa, q, S1, S2, u)</p>
    </div>
    

    
  
    <div class="desc"><p>Auxiliary function, see <a href="#precession.St_limits"><code>St_limits</code></a>.</p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>St_min,St_max=precession.St_limits_comp(kappa,q,S1,S2,u)
</pre></div>


<p><strong>Parameters:</strong></p>
<ul>
<li><code>kappa</code>: rescaling of the total angular momentum to compactify the inspiral domain.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>u</code>: rescaling of the orbital angular momentum to compactify the inspiral domain.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>St_min</code>: minimum value of S from geometrical constraints. This is S_min in our papers.</li>
<li><code>St_max</code>: maximum value of S from geometrical constraints. This is S_max in our papers.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.St_limits_comp', this);">Show source &equiv;</a></p>
  <div id="source-precession.St_limits_comp" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">St_limits_comp</span><span class="p">(</span><span class="n">kappa</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">u</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Auxiliary function, see `precession.St_limits`.</span>
<span class="sd">    </span>
<span class="sd">    **Call:**</span>

<span class="sd">        St_min,St_max=precession.St_limits_comp(kappa,q,S1,S2,u)</span>

<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `kappa`: rescaling of the total angular momentum to compactify the inspiral domain.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `u`: rescaling of the orbital angular momentum to compactify the inspiral domain.</span>

<span class="sd">    **Returns:**</span>
<span class="sd">    </span>
<span class="sd">    - `St_min`: minimum value of S from geometrical constraints. This is S_min in our papers.</span>
<span class="sd">    - `St_max`: maximum value of S from geometrical constraints. This is S_max in our papers.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="n">u</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">St_min</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">kappa</span><span class="p">))</span>
        <span class="n">St_max</span><span class="o">=</span><span class="n">S1</span><span class="o">+</span><span class="n">S2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">St_min</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span> <span class="p">((</span><span class="mf">1.</span><span class="o">+</span><span class="mi">4</span><span class="o">*</span><span class="n">kappa</span><span class="o">*</span><span class="n">u</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">u</span><span class="p">)))</span>
        <span class="n">St_max</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="n">S1</span><span class="o">+</span><span class="n">S2</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span> <span class="p">((</span><span class="mf">1.</span><span class="o">+</span><span class="mi">4</span><span class="o">*</span><span class="n">kappa</span><span class="o">*</span><span class="n">u</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">u</span><span class="p">)))</span>

    <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">St_min</span><span class="p">),</span><span class="nb">float</span><span class="p">(</span><span class="n">St_max</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.aligned_configurations">
    <p>def <span class="ident">aligned_configurations</span>(</p><p>q, S1, S2, r)</p>
    </div>
    

    
  
    <div class="desc"><p>Values of xi and J corresponding to the four (anti)aligned configuration:
up-up (spins of both primary and secondary BH aligned with L); up-up (spins
of both primary and secondary BH antialigned with L); up-down (spin of the
primary BH aligned with L; spin of the secondary BH antialigned with L);
down-up (spin of the primary BH aligned with L; spin of the secondary BH
antialigned with L).</p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>xiupup,xidowndown,xiupdown,xidownup,Jupup,Jdowndown,Jupdown,Jdownup=precession.aligned_configurations(q,S1,S2,r)
</pre></div>


<p><strong>Parameters:</strong></p>
<ul>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>r</code>: binary separation.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>xiupup</code>: xi of the up-up configuration.</li>
<li><code>xidowndown</code>: xi of the down-down configuration.</li>
<li><code>xiupdown</code>: xi of the up-down configuration.</li>
<li><code>xidownup</code>: xi of the down-up configuration.</li>
<li><code>Jupup</code>: J of the up-up configuration.</li>
<li><code>Jdowndown</code>: J of the down-down configuration.</li>
<li><code>Jupdown</code>: J of the up-down configuration.</li>
<li><code>Jdownup</code>: J of the down-up configuration.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.aligned_configurations', this);">Show source &equiv;</a></p>
  <div id="source-precession.aligned_configurations" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">aligned_configurations</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Values of xi and J corresponding to the four (anti)aligned configuration:</span>
<span class="sd">    up-up (spins of both primary and secondary BH aligned with L); up-up (spins</span>
<span class="sd">    of both primary and secondary BH antialigned with L); up-down (spin of the</span>
<span class="sd">    primary BH aligned with L; spin of the secondary BH antialigned with L);</span>
<span class="sd">    down-up (spin of the primary BH aligned with L; spin of the secondary BH</span>
<span class="sd">    antialigned with L).</span>

<span class="sd">    **Call:**</span>

<span class="sd">        xiupup,xidowndown,xiupdown,xidownup,Jupup,Jdowndown,Jupdown,Jdownup=precession.aligned_configurations(q,S1,S2,r)</span>

<span class="sd">    **Parameters:**</span>

<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">     - `r`: binary separation.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `xiupup`: xi of the up-up configuration.</span>
<span class="sd">    - `xidowndown`: xi of the down-down configuration.</span>
<span class="sd">    - `xiupdown`: xi of the up-down configuration.</span>
<span class="sd">    - `xidownup`: xi of the down-up configuration.</span>
<span class="sd">    - `Jupup`: J of the up-up configuration.</span>
<span class="sd">    - `Jdowndown`: J of the down-down configuration.</span>
<span class="sd">    - `Jupdown`: J of the up-down configuration.</span>
<span class="sd">    - `Jdownup`: J of the down-up configuration.</span>
<span class="sd">    &#39;&#39;&#39;</span>



    <span class="n">L</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
    
    <span class="n">xiupup</span><span class="o">=</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">S1</span><span class="o">+</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">q</span><span class="o">**-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">S2</span>
    <span class="n">xidowndown</span><span class="o">=-</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">S1</span><span class="o">-</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">q</span><span class="o">**-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">S2</span>
    <span class="n">xiupdown</span><span class="o">=</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">S1</span><span class="o">-</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">q</span><span class="o">**-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">S2</span>
    <span class="n">xidownup</span><span class="o">=-</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">S1</span><span class="o">+</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">q</span><span class="o">**-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">S2</span>

    <span class="n">Jupup</span><span class="o">=</span><span class="n">L</span><span class="o">+</span><span class="n">S1</span><span class="o">+</span><span class="n">S2</span>
    <span class="n">Jdowndown</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">)</span>
    <span class="n">Jupdown</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">L</span><span class="o">+</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">)</span>
    <span class="n">Jdownup</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="n">S1</span><span class="o">+</span><span class="n">S2</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">xiupup</span><span class="p">,</span><span class="n">xidowndown</span><span class="p">,</span><span class="n">xiupdown</span><span class="p">,</span><span class="n">xidownup</span><span class="p">,</span><span class="n">Jupup</span><span class="p">,</span><span class="n">Jdowndown</span><span class="p">,</span><span class="n">Jupdown</span><span class="p">,</span><span class="n">Jdownup</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.alpha_of_S">
    <p>def <span class="ident">alpha_of_S</span>(</p><p>S_initial, S_final, Sb_min, Sb_max, xi, J, q, S1, S2, r, alpha_initial=0, sign=1.0)</p>
    </div>
    

    
  
    <div class="desc"><p>Integrate `precession.Omegaz' to find the precession angle spanned by L
about J, phiL, as a function of S. Sb_min and Sb_max are passed to this
function (and not computed in it) to speed things up. This function can only
integrate over half precession period (i.e. from Sb_min to Sb_max at most).
If you want phiL(S) over more precession periods you should stich different
solutions together, consistently with the argument sign (in particular, flip
sign every half period).</p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>phiL=precession.alpha_of_S(S_initial,S_final,Sb_min,Sb_max,xi,J,q,S1,S2,r,alpha_initial=0,sign=1.):
</pre></div>


<p><strong>Parameters:</strong></p>
<ul>
<li><code>S_initial</code>: lower edge of the integration domain.</li>
<li><code>S_final</code>: upper edge of the integration domain.</li>
<li><code>Sb_min</code>: minimum value of S from geometrical constraints. This is S- in our papers.</li>
<li><code>Sb_max</code>: maximum value of S from geometrical constraints. This is S+ in our papers.</li>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>J</code>: magnitude of the total angular momentum.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>r</code>: binary separation.</li>
<li><code>alpha_initial</code>: initial integration angle.</li>
<li><code>sign</code>: if 1 return angle in [0,pi], if -1 return angle in [-pi,0].</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>phiL</code>: azimuthal angle spanned by L about J.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.alpha_of_S', this);">Show source &equiv;</a></p>
  <div id="source-precession.alpha_of_S" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">alpha_of_S</span><span class="p">(</span> <span class="n">S_initial</span><span class="p">,</span><span class="n">S_final</span> <span class="p">,</span><span class="n">Sb_min</span><span class="p">,</span><span class="n">Sb_max</span> <span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">,</span> <span class="n">alpha_initial</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">sign</span><span class="o">=</span><span class="mf">1.</span><span class="p">):</span>
    
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Integrate `precession.Omegaz&#39; to find the precession angle spanned by L</span>
<span class="sd">    about J, phiL, as a function of S. Sb_min and Sb_max are passed to this</span>
<span class="sd">    function (and not computed in it) to speed things up. This function can only</span>
<span class="sd">    integrate over half precession period (i.e. from Sb_min to Sb_max at most).</span>
<span class="sd">    If you want phiL(S) over more precession periods you should stich different</span>
<span class="sd">    solutions together, consistently with the argument sign (in particular, flip</span>
<span class="sd">    sign every half period).</span>

<span class="sd">    **Call:**</span>

<span class="sd">        phiL=precession.alpha_of_S(S_initial,S_final,Sb_min,Sb_max,xi,J,q,S1,S2,r,alpha_initial=0,sign=1.):</span>
<span class="sd">    </span>
<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `S_initial`: lower edge of the integration domain.</span>
<span class="sd">    - `S_final`: upper edge of the integration domain.</span>
<span class="sd">    - `Sb_min`: minimum value of S from geometrical constraints. This is S- in our papers.</span>
<span class="sd">    - `Sb_max`: maximum value of S from geometrical constraints. This is S+ in our papers.</span>
<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `J`: magnitude of the total angular momentum.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `r`: binary separation.</span>
<span class="sd">    - `alpha_initial`: initial integration angle.</span>
<span class="sd">    - `sign`: if 1 return angle in [0,pi], if -1 return angle in [-pi,0].</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `phiL`: azimuthal angle spanned by L about J.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">global</span> <span class="n">flags_q1</span>
    <span class="k">if</span> <span class="n">q</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">flags_q1</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="o">==</span><span class="bp">False</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;[alpha_of_S] Warning q=1: input here is cos(varphi), not S; now computing alpha(cosvarphi)&quot;</span>
            <span class="n">flags_q1</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="o">=</span><span class="bp">True</span>
        
        <span class="n">L</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">xi</span><span class="o">*</span><span class="n">L</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">S_min</span><span class="p">,</span><span class="n">S_max</span><span class="o">=</span><span class="n">St_limits</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">S</span><span class="o">-</span><span class="n">S_min</span><span class="p">)</span><span class="o">&lt;</span><span class="mf">1e-8</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">S</span><span class="o">-</span><span class="n">S_max</span><span class="p">)</span><span class="o">&lt;</span><span class="mf">1e-8</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;[alpha_of_S] Warning: you are at resonance, varphi is ill defined here.&quot;</span>
            <span class="k">return</span> <span class="mf">0.</span>
        <span class="k">elif</span> <span class="nb">min</span><span class="p">(</span><span class="n">S_initial</span><span class="p">,</span><span class="n">S_final</span><span class="p">)</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="nb">max</span><span class="p">(</span><span class="n">S_initial</span><span class="p">,</span><span class="n">S_final</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">False</span><span class="p">,</span> <span class="s">&quot;[alpha_of_S] Error. You&#39;re trying to integrate over more than one (half)period&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># If q=1, S is constant and therefore Omegaz is also constant. It can be taken out of the integral.</span>
            <span class="n">deltat</span><span class="o">=</span><span class="n">t_of_S</span><span class="p">(</span><span class="n">S_initial</span><span class="p">,</span><span class="n">S_final</span><span class="p">,</span><span class="n">Sb_min</span><span class="p">,</span><span class="n">Sb_max</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">alpha_initial</span> <span class="o">+</span> <span class="n">Omegaz</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span> <span class="o">*</span><span class="n">deltat</span>            
    
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Sb_min</span><span class="o">-</span><span class="n">Sb_max</span><span class="p">)</span><span class="o">&lt;</span><span class="mf">1e-8</span><span class="p">:</span> <span class="c"># This typically happen when [Sb_limits] fails in bracketing of the solutions. In practice, this is a resonant binary.</span>
        <span class="k">return</span> <span class="mf">0.</span>
    <span class="k">elif</span> <span class="nb">min</span><span class="p">(</span><span class="n">S_initial</span><span class="p">,</span><span class="n">S_final</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">Sb_min</span> <span class="ow">or</span> <span class="nb">max</span><span class="p">(</span><span class="n">S_initial</span><span class="p">,</span><span class="n">S_final</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">Sb_max</span><span class="p">:</span>
        <span class="k">assert</span> <span class="bp">False</span><span class="p">,</span> <span class="s">&quot;[alpha_of_S] Error. You&#39;re trying to integrate over more than one (half)period&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c"># Actual integration</span>
        <span class="n">res</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">integrate</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="n">OmegazdtdS</span><span class="p">,</span> <span class="n">S_initial</span><span class="p">,</span> <span class="n">S_final</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">sign</span><span class="p">),</span><span class="n">full_output</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>               
        <span class="k">return</span> <span class="n">alpha_initial</span> <span class="o">+</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.alphaz">
    <p>def <span class="ident">alphaz</span>(</p><p>xi, J, q, S1, S2, r)</p>
    </div>
    

    
  
    <div class="desc"><p>Angle spanned by L about J in a single precession cycle. This is
<a href="#precession.alpha_of_S"><code>alpha_of_S</code></a> integrated from Sb_min to Sb_max times 2.</p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>alpha=precession.alphaz(xi,J,q,S1,S2,r)
</pre></div>


<p><strong>Parameters:</strong></p>
<ul>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>J</code>: magnitude of the total angular momentum.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>r</code>: binary separation.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>alpha</code>: azimuthal angle spanned by L about J in an entire precession cycle.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.alphaz', this);">Show source &equiv;</a></p>
  <div id="source-precession.alphaz" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">alphaz</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Angle spanned by L about J in a single precession cycle. This is</span>
<span class="sd">    `precession.alpha_of_S` integrated from Sb_min to Sb_max times 2.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        alpha=precession.alphaz(xi,J,q,S1,S2,r)</span>
<span class="sd">    </span>
<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `J`: magnitude of the total angular momentum.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `r`: binary separation.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `alpha`: azimuthal angle spanned by L about J in an entire precession cycle.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="n">q</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="c"># If q=1, the limits must be specified in cos(varphi)</span>
        <span class="n">Sb_min</span><span class="o">=-</span><span class="mi">1</span>
        <span class="n">Sb_max</span><span class="o">=</span><span class="mi">1</span>
        <span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="n">alpha_of_S</span><span class="p">(</span><span class="n">Sb_min</span><span class="p">,</span><span class="n">Sb_max</span><span class="p">,</span><span class="n">Sb_min</span><span class="p">,</span><span class="n">Sb_max</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span> 
        
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Sb_min</span><span class="p">,</span><span class="n">Sb_max</span><span class="o">=</span><span class="n">Sb_limits</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Sb_min</span><span class="o">-</span><span class="n">Sb_max</span><span class="p">)</span><span class="o">&lt;</span><span class="mf">1e-8</span><span class="p">:</span> <span class="c"># This typically happen when [Sb_limits] fails in bracketing of the solutions. In practice, this is a resonant binary.</span>
            <span class="k">return</span> <span class="mf">0.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">integrate</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="n">OmegazdtdS</span><span class="p">,</span> <span class="n">Sb_min</span><span class="p">,</span> <span class="n">Sb_max</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">),</span> <span class="n">full_output</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">2</span><span class="o">*</span><span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.cutoff">
    <p>def <span class="ident">cutoff</span>(</p><p>detector, M_msun)</p>
    </div>
    

    
  
    <div class="desc"><p>Return the GW frequency and binary separation (in total-mass units) when
binary enter the sensitivity window of a typical ground-based LIGO-like
detector or a LISA-like space mission.</p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>r,f=precession.cutoff(detector,M_msun)
</pre></div>


<p><strong>Parameters:</strong></p>
<ul>
<li><code>detector</code>: specify either <em>space</em> or <em>ground</em>.</li>
<li><code>M_msun</code>: binary total mass in solar masses.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>r</code>: binary separation.</li>
<li><code>f</code>: emitted GW frequency in Hertz.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.cutoff', this);">Show source &equiv;</a></p>
  <div id="source-precession.cutoff" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">cutoff</span><span class="p">(</span><span class="n">detector</span><span class="p">,</span><span class="n">M_msun</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Return the GW frequency and binary separation (in total-mass units) when</span>
<span class="sd">    binary enter the sensitivity window of a typical ground-based LIGO-like</span>
<span class="sd">    detector or a LISA-like space mission.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        r,f=precession.cutoff(detector,M_msun)</span>
<span class="sd">    </span>
<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `detector`: specify either *space* or *ground*.</span>
<span class="sd">    - `M_msun`: binary total mass in solar masses.</span>

<span class="sd">    **Returns:**</span>
<span class="sd">    </span>
<span class="sd">    - `r`: binary separation.</span>
<span class="sd">    - `f`: emitted GW frequency in Hertz.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="n">detector</span><span class="o">==</span><span class="s">&quot;ground&quot;</span><span class="p">:</span>
        <span class="n">fcut</span><span class="o">=</span><span class="mi">10</span> <span class="c"># Hz</span>
    <span class="k">elif</span> <span class="n">detector</span><span class="o">==</span><span class="s">&quot;space&quot;</span><span class="p">:</span>
        <span class="n">fcut</span><span class="o">=</span> <span class="mf">1e-5</span> <span class="c"># Hz</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="bp">False</span><span class="p">,</span> <span class="s">&quot;[cutoff] Please select &#39;space&#39; or &#39;ground&#39;. Otherwise run ftor with the chosen frequency&quot;</span>
    <span class="n">rcut</span><span class="o">=</span><span class="n">ftor</span><span class="p">(</span><span class="n">fcut</span><span class="p">,</span><span class="n">M_msun</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">rcut</span><span class="p">,</span> <span class="n">fcut</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.dJdL">
    <p>def <span class="ident">dJdL</span>(</p><p>J, r, xi, q, S1, S2)</p>
    </div>
    

    
  
    <div class="desc"><p>Inspiral ODE describing the evolution of the magnitude of the total angular
momentum vs. the separation r. This function is NOT used by the ODE solvers
(see <a href="#precession.dkappadu"><code>dkappadu</code></a>).</p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>dJdL=precession.dJdL(J,r,xi,q,S1,S2)
</pre></div>


<p><strong>Parameters:</strong></p>
<ul>
<li><code>J</code>: magnitude of the total angular momentum.</li>
<li><code>r</code>: binary separation.</li>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>dJdL</code>: precession-averaged derivative of J with respect to L.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.dJdL', this);">Show source &equiv;</a></p>
  <div id="source-precession.dJdL" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">dJdL</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Inspiral ODE describing the evolution of the magnitude of the total angular</span>
<span class="sd">    momentum vs. the separation r. This function is NOT used by the ODE solvers</span>
<span class="sd">    (see `precession.dkappadu`).</span>

<span class="sd">    **Call:**</span>

<span class="sd">        dJdL=precession.dJdL(J,r,xi,q,S1,S2)</span>
<span class="sd">    </span>
<span class="sd">    **Parameters:**</span>

<span class="sd">    - `J`: magnitude of the total angular momentum.</span>
<span class="sd">    - `r`: binary separation.</span>
<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `dJdL`: precession-averaged derivative of J with respect to L.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">L</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>    
    <span class="n">kappa</span><span class="o">=</span><span class="p">(</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">L</span><span class="p">)</span>
    <span class="n">u</span><span class="o">=</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">L</span><span class="p">)</span>
    <span class="n">S2pre</span><span class="o">=</span><span class="n">dkappadu</span><span class="p">(</span><span class="n">kappa</span><span class="p">,</span><span class="n">u</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">)</span>
    <span class="n">dJdL</span><span class="o">=</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">L</span><span class="o">*</span><span class="n">J</span><span class="p">))</span><span class="o">*</span><span class="p">(</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S2pre</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dJdL</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.dJdr">
    <p>def <span class="ident">dJdr</span>(</p><p>J, r, xi, q, S1, S2)</p>
    </div>
    

    
  
    <div class="desc"><p>Inspiral ODE describing the evolution of the magnitude of the total angular
momentum vs. the separation r. This function is NOT used by the ODE solvers
(see <a href="#precession.dkappadu"><code>dkappadu</code></a>).</p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>dJdr=precession.dJdr(J,r,xi,q,S1,S2)
</pre></div>


<p><strong>Parameters:</strong></p>
<ul>
<li><code>J</code>: magnitude of the total angular momentum.</li>
<li><code>r</code>: binary separation.</li>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>dJdr</code>: precession-averaged derivative of J with respect to r.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.dJdr', this);">Show source &equiv;</a></p>
  <div id="source-precession.dJdr" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">dJdr</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Inspiral ODE describing the evolution of the magnitude of the total angular</span>
<span class="sd">    momentum vs. the separation r. This function is NOT used by the ODE solvers</span>
<span class="sd">    (see `precession.dkappadu`).</span>

<span class="sd">    **Call:**</span>

<span class="sd">        dJdr=precession.dJdr(J,r,xi,q,S1,S2)</span>
<span class="sd">    </span>
<span class="sd">    **Parameters:**</span>

<span class="sd">    - `J`: magnitude of the total angular momentum.</span>
<span class="sd">    - `r`: binary separation.</span>
<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `dJdr`: precession-averaged derivative of J with respect to r.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">L</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>    
    <span class="n">kappa</span><span class="o">=</span><span class="p">(</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">L</span><span class="p">)</span>
    <span class="n">u</span><span class="o">=</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">L</span><span class="p">)</span>
    <span class="n">S2pre</span><span class="o">=</span><span class="n">dkappadu</span><span class="p">(</span><span class="n">kappa</span><span class="p">,</span><span class="n">u</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">)</span>
    <span class="n">dJdL</span><span class="o">=</span><span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">L</span><span class="o">*</span><span class="n">J</span><span class="p">))</span><span class="o">*</span><span class="p">(</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S2pre</span><span class="p">)</span>
    <span class="n">dLdr</span><span class="o">=</span><span class="n">L</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">r</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">dJdL</span><span class="o">*</span><span class="n">dLdr</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.dSdt">
    <p>def <span class="ident">dSdt</span>(</p><p>S, xi, J, q, S1, S2, r, sign=1.0)</p>
    </div>
    

    
  
    <div class="desc"><p>Compute the derivative of S with respect to t (on the precessional time
only, i.e. assuming J is constant). Uses the spin-precession equations, but
not the radiation reaction equation. The additional sign lets you specifiy
the sign of the angle deltaphi: for consistency with what presented in our
papers, use sign=1 if you are in the second half of the precession cycle
(deltaphi is in [0,pi]) and sign=-1 if you are in the first half of the
precession cycle (deltaphi is in [-pi,0]). If q=1, this function computes
d(cos(varphi))/dt.</p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>dSdt=precession.dSdt(S,xi,J,q,S1,S2,r,sign=1.)
</pre></div>


<p><strong>Parameters:</strong></p>
<ul>
<li><code>S</code>: magnitude of the total spin.</li>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>J</code>: magnitude of the total angular momentum.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>r</code>: binary separation.</li>
<li><code>sign</code>: if 1 return angle in [0,pi], if -1 return angle in [-pi,0].</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>dSdt</code>: precessional-cycle speed.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.dSdt', this);">Show source &equiv;</a></p>
  <div id="source-precession.dSdt" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">dSdt</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">sign</span><span class="o">=</span><span class="mf">1.</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Compute the derivative of S with respect to t (on the precessional time</span>
<span class="sd">    only, i.e. assuming J is constant). Uses the spin-precession equations, but</span>
<span class="sd">    not the radiation reaction equation. The additional sign lets you specifiy</span>
<span class="sd">    the sign of the angle deltaphi: for consistency with what presented in our</span>
<span class="sd">    papers, use sign=1 if you are in the second half of the precession cycle</span>
<span class="sd">    (deltaphi is in [0,pi]) and sign=-1 if you are in the first half of the</span>
<span class="sd">    precession cycle (deltaphi is in [-pi,0]). If q=1, this function computes</span>
<span class="sd">    d(cos(varphi))/dt.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        dSdt=precession.dSdt(S,xi,J,q,S1,S2,r,sign=1.)</span>
<span class="sd">    </span>
<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `S`: magnitude of the total spin.</span>
<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `J`: magnitude of the total angular momentum.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `r`: binary separation.</span>
<span class="sd">    - `sign`: if 1 return angle in [0,pi], if -1 return angle in [-pi,0].</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `dSdt`: precessional-cycle speed.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">global</span> <span class="n">flags_q1</span>   

    <span class="n">L</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
    <span class="n">eta</span><span class="o">=</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>

    <span class="k">if</span> <span class="n">q</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">flags_q1</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">==</span><span class="bp">False</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;[dSdt] Warning q=1: input here is cos(varphi), not S; now computing d(cos(varphi))/dt &quot;</span>
            <span class="n">flags_q1</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">=</span><span class="bp">True</span>
        
        <span class="n">cosvarphi</span> <span class="o">=</span> <span class="n">S</span> <span class="c"># The input variable is actually cos(varphi)</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">xi</span><span class="o">*</span><span class="n">L</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">S_min</span><span class="p">,</span><span class="n">S_max</span><span class="o">=</span><span class="n">St_limits</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">S</span><span class="o">-</span><span class="n">S_min</span><span class="p">)</span><span class="o">&lt;</span><span class="mf">1e-8</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">S</span><span class="o">-</span><span class="n">S_max</span><span class="p">)</span><span class="o">&lt;</span><span class="mf">1e-8</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;[dSdt] Warning: you are at resonance, varphi is ill-defined here.&quot;</span>
            <span class="k">return</span> <span class="mf">0.</span>
        
        <span class="c"># Compute d(cos(varphi))/dt</span>
        <span class="n">t6</span><span class="o">=</span><span class="p">((</span><span class="n">S1</span><span class="o">+</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">t7</span><span class="o">=</span><span class="p">(</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>        
        <span class="n">B</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">xi</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span><span class="o">*</span><span class="n">t6</span><span class="o">*</span><span class="n">t7</span>
        <span class="c">#B=max(0.0,B)</span>
        <span class="n">t1</span><span class="o">=</span> <span class="p">(</span><span class="mi">12</span><span class="o">*</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">S1</span><span class="o">*</span><span class="n">S2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">B</span><span class="p">))</span>
        <span class="n">t2</span><span class="o">=</span> <span class="p">(</span><span class="n">eta</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span><span class="o">/</span><span class="n">L</span><span class="o">**</span><span class="mi">6</span>
        <span class="n">t3</span><span class="o">=</span> <span class="mi">1</span><span class="o">-</span><span class="p">(</span><span class="n">eta</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">xi</span><span class="p">)</span><span class="o">/</span><span class="n">L</span>
        <span class="n">ct1</span><span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">S1</span><span class="o">*</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">*</span><span class="p">(</span><span class="n">xi</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">S1</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">B</span><span class="p">)</span><span class="o">*</span><span class="n">cosvarphi</span><span class="p">)</span>
        <span class="n">ct2</span><span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">S2</span><span class="o">*</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">*</span><span class="p">(</span><span class="n">xi</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">S2</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S1</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">B</span><span class="p">)</span><span class="o">*</span><span class="n">cosvarphi</span><span class="p">)</span>
        <span class="n">ct12</span><span class="o">=</span><span class="p">(</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S1</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">S1</span><span class="o">*</span><span class="n">S2</span><span class="p">)</span>
        <span class="n">t4</span><span class="o">=</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">ct1</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">ct2</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">ct12</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span><span class="mf">2.</span><span class="o">*</span><span class="n">ct1</span><span class="o">*</span><span class="n">ct2</span><span class="o">*</span><span class="n">ct12</span><span class="p">))</span><span class="o">**.</span><span class="mi">5</span>        
        <span class="n">der</span><span class="o">=</span><span class="n">sign</span><span class="o">*</span><span class="n">t1</span><span class="o">*</span><span class="n">t2</span><span class="o">*</span><span class="n">t3</span><span class="o">*</span><span class="n">t4</span>

    <span class="k">else</span><span class="p">:</span>
        
        <span class="c"># Compute dS/dt</span>
        <span class="n">t1</span><span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mf">3.</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">q</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span><span class="n">S1</span><span class="o">*</span><span class="n">S2</span><span class="o">*</span><span class="n">eta</span><span class="o">**</span><span class="mi">6</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">9</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">q</span><span class="o">*</span><span class="n">S</span><span class="o">*</span><span class="n">L</span><span class="o">**</span><span class="mi">5</span><span class="p">)</span>
        <span class="n">t2</span><span class="o">=</span> <span class="mf">1.</span><span class="o">-</span><span class="p">((</span><span class="n">eta</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">xi</span><span class="p">)</span><span class="o">/</span><span class="n">L</span><span class="p">)</span>
        <span class="c">#It&#39;s faster if you don&#39;t call [parametric_angles] here. Equivalent to </span>
            <span class="c">#theta1,theta2,deltaphi,theta12 = parametric_angles(S,J,xi,q,S1,S2,r)    </span>
            <span class="c">#der=sign*t1*t2*np.sin(theta1)*np.sin(theta2)*np.sin(deltaphi)</span>
        <span class="n">ct1</span><span class="o">=</span> <span class="p">(</span> <span class="p">((</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="n">L</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">q</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">xi</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span> <span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">S1</span><span class="p">)</span>
        <span class="n">ct2</span><span class="o">=</span> <span class="p">(</span> <span class="p">((</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">q</span><span class="o">/</span><span class="n">L</span><span class="p">))</span> <span class="o">+</span> <span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">q</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">xi</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span> <span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">S2</span><span class="p">)</span>
        <span class="n">ct12</span><span class="o">=</span><span class="p">(</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S1</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">S1</span><span class="o">*</span><span class="n">S2</span><span class="p">)</span>
        <span class="n">t3</span><span class="o">=</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">ct1</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">ct2</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">ct12</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span><span class="mf">2.</span><span class="o">*</span><span class="n">ct1</span><span class="o">*</span><span class="n">ct2</span><span class="o">*</span><span class="n">ct12</span><span class="p">))</span><span class="o">**.</span><span class="mi">5</span> <span class="c"># I know abs is dirty, but does the job</span>
        <span class="n">der</span><span class="o">=</span><span class="n">sign</span><span class="o">*</span><span class="n">t1</span><span class="o">*</span><span class="n">t2</span><span class="o">*</span><span class="n">t3</span>
        
    <span class="k">return</span> <span class="n">der</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.dkappadu">
    <p>def <span class="ident">dkappadu</span>(</p><p>kappa, u, xi, q, S1, S2)</p>
    </div>
    

    
  
    <div class="desc"><p>Inspiral ODE to perform precession-averaged inspiral: dkappa/du = S^2_pre.
We use variables kappa and u (rather than J and L, see <a href="#precession.dJdL"><code>dJdL</code></a>)
because this formulation naturally allows for integration from infinitely
large separations, i.e. u=0. This function is only the actual equation, not
the ODE solver.</p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>dkappadu=precession.dkappadu(kappa,u,xi,q,S1,S2)
</pre></div>


<p><strong>Parameters:</strong></p>
<ul>
<li><code>kappa</code>: rescaling of the total angular momentum to compactify the inspiral domain.</li>
<li><code>u</code>: rescaling of the orbital angular momentum to compactify the inspiral domain.</li>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>dkappadu</code>: precession-averaged derivative of kappa with respect to u.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.dkappadu', this);">Show source &equiv;</a></p>
  <div id="source-precession.dkappadu" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">dkappadu</span><span class="p">(</span><span class="n">kappa</span><span class="p">,</span><span class="n">u</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">):</span>    
      
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Inspiral ODE to perform precession-averaged inspiral: dkappa/du = S^2_pre.</span>
<span class="sd">    We use variables kappa and u (rather than J and L, see `precession.dJdL`)</span>
<span class="sd">    because this formulation naturally allows for integration from infinitely</span>
<span class="sd">    large separations, i.e. u=0. This function is only the actual equation, not</span>
<span class="sd">    the ODE solver.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        dkappadu=precession.dkappadu(kappa,u,xi,q,S1,S2)</span>
<span class="sd">    </span>
<span class="sd">    **Parameters:**</span>

<span class="sd">    - `kappa`: rescaling of the total angular momentum to compactify the inspiral domain.</span>
<span class="sd">    - `u`: rescaling of the orbital angular momentum to compactify the inspiral domain.</span>
<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `dkappadu`: precession-averaged derivative of kappa with respect to u.</span>
<span class="sd">    &#39;&#39;&#39;</span>
  
    <span class="n">dkappadu_debug</span><span class="o">=</span><span class="bp">False</span> <span class="c">#Debug option</span>
    <span class="k">if</span> <span class="n">dkappadu_debug</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&quot;[dkappadu] ODE int: u=&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">u</span><span class="p">)</span><span class="o">+</span><span class="s">&quot;</span><span class="se">\t\t</span><span class="s">kappa=&quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">kappa</span><span class="p">))</span>
    
    <span class="n">Sb_min</span><span class="p">,</span><span class="n">Sb_max</span> <span class="o">=</span> <span class="n">Sb_limits_comp</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">kappa</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">u</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Sb_min</span><span class="o">-</span><span class="n">Sb_max</span><span class="p">)</span><span class="o">&lt;</span><span class="mf">1e-8</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">dkappadu_debug</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;[dkappadu] Warning. Applyting analytical approximation. u=&quot;</span><span class="p">,</span><span class="n">u</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">Sb_min</span><span class="p">,</span><span class="n">Sb_max</span><span class="p">]))</span><span class="o">**</span><span class="mi">2</span>
    <span class="k">else</span><span class="p">:</span>      
        <span class="n">up</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">integrate</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="n">S3sines_comp</span><span class="p">,</span> <span class="n">Sb_min</span><span class="p">,</span> <span class="n">Sb_max</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">kappa</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">u</span><span class="p">),</span> <span class="n">full_output</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">down</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">integrate</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="n">Ssines_comp</span> <span class="p">,</span> <span class="n">Sb_min</span><span class="p">,</span> <span class="n">Sb_max</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">kappa</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">u</span><span class="p">),</span> <span class="n">full_output</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">up</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">down</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.dtdS">
    <p>def <span class="ident">dtdS</span>(</p><p>S, xi, J, q, S1, S2, r, sign=1.0)</p>
    </div>
    

    
  
    <div class="desc"><p>Auxiliary function dt/dS=(dS/dt)^-1. See <a href="#precession.dSdt"><code>dSdt</code></a>.</p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>dtdS=precession.dtdS(S,xi,J,q,S1,S2,r,sign=1.)
</pre></div>


<p><strong>Parameters:</strong></p>
<ul>
<li><code>S</code>: magnitude of the total spin.</li>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>J</code>: magnitude of the total angular momentum.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>r</code>: binary separation.</li>
<li><code>sign</code>: if 1 return angle in [0,pi], if -1 return angle in [-pi,0].</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>dtdS</code>: inverse of the precessional-cycle speed.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.dtdS', this);">Show source &equiv;</a></p>
  <div id="source-precession.dtdS" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">dtdS</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">sign</span><span class="o">=</span><span class="mf">1.</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Auxiliary function dt/dS=(dS/dt)^-1. See `precession.dSdt`.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        dtdS=precession.dtdS(S,xi,J,q,S1,S2,r,sign=1.)</span>
<span class="sd">    </span>
<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `S`: magnitude of the total spin.</span>
<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `J`: magnitude of the total angular momentum.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `r`: binary separation.</span>
<span class="sd">    - `sign`: if 1 return angle in [0,pi], if -1 return angle in [-pi,0].</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `dtdS`: inverse of the precessional-cycle speed.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">return</span> <span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">dSdt</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">sign</span><span class="p">))</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.dxidS_minus">
    <p>def <span class="ident">dxidS_minus</span>(</p><p>S, J, q, S1, S2, r)</p>
    </div>
    

    
  
    <div class="desc"><p>Derivative of the effective potential xi_minus with respect to S.    </p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>dxidS=precession.dxidS_minus(S,J,q,S1,S2,r)
</pre></div>


<p><strong>Parameters:</strong></p>
<ul>
<li><code>S</code>: magnitude of the total spin.</li>
<li><code>J</code>: magnitude of the total angular momentum.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>r</code>: binary separation.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>dxidS</code>: derivative of effective potential with respect to S.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.dxidS_minus', this);">Show source &equiv;</a></p>
  <div id="source-precession.dxidS_minus" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">dxidS_minus</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">):</span>
    
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Derivative of the effective potential xi_minus with respect to S.    </span>

<span class="sd">    **Call:**</span>

<span class="sd">        dxidS=precession.dxidS_minus(S,J,q,S1,S2,r)</span>
<span class="sd">    </span>
<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `S`: magnitude of the total spin.</span>
<span class="sd">    - `J`: magnitude of the total angular momentum.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `r`: binary separation.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `dxidS`: derivative of effective potential with respect to S.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">L</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
    <span class="n">A1</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="n">S</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">A2</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">L</span><span class="o">+</span><span class="n">S</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">A3</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">A4</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">S1</span><span class="o">+</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">Fm</span> <span class="o">=</span> <span class="p">(</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">S1</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">q</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">-</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">q</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">A1</span><span class="o">*</span><span class="n">A2</span><span class="o">*</span><span class="n">A3</span><span class="o">*</span><span class="n">A4</span>
    <span class="n">G</span><span class="o">=</span><span class="mi">4</span><span class="o">*</span><span class="n">q</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">L</span>
    <span class="n">dFmdS</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">S</span><span class="o">*</span><span class="p">(</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">S1</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">q</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">S</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">q</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(((</span><span class="n">L</span><span class="o">-</span><span class="n">S</span><span class="p">)</span><span class="o">*</span><span class="n">A2</span><span class="o">*</span><span class="n">A3</span><span class="o">*</span><span class="n">A4</span><span class="p">)</span><span class="o">/</span><span class="n">A1</span><span class="o">+</span><span class="p">((</span><span class="n">L</span><span class="o">+</span><span class="n">S</span><span class="p">)</span><span class="o">*</span><span class="n">A3</span><span class="o">*</span><span class="n">A4</span><span class="o">*</span><span class="n">A1</span><span class="p">)</span><span class="o">/</span><span class="n">A2</span><span class="o">+</span><span class="p">(</span><span class="n">S</span><span class="o">*</span><span class="n">A4</span><span class="o">*</span><span class="n">A1</span><span class="o">*</span><span class="n">A2</span><span class="p">)</span><span class="o">/</span><span class="n">A3</span><span class="o">-</span><span class="p">(</span><span class="n">S</span><span class="o">*</span><span class="n">A1</span><span class="o">*</span><span class="n">A2</span><span class="o">*</span><span class="n">A3</span><span class="p">)</span><span class="o">/</span><span class="n">A4</span><span class="p">)</span>
    <span class="n">dGdS</span><span class="o">=</span><span class="mi">8</span><span class="o">*</span><span class="n">q</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">S</span><span class="o">*</span><span class="n">L</span>
    <span class="n">dximdS</span><span class="o">=</span><span class="p">(</span><span class="n">dFmdS</span><span class="o">*</span><span class="n">G</span><span class="o">-</span><span class="n">dGdS</span><span class="o">*</span><span class="n">Fm</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">G</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dximdS</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.dxidS_plus">
    <p>def <span class="ident">dxidS_plus</span>(</p><p>S, J, q, S1, S2, r)</p>
    </div>
    

    
  
    <div class="desc"><p>Derivative of the effective potential xi_plus with respect to S.    </p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>dxidS=precession.dxidS_plus(S,J,q,S1,S2,r)
</pre></div>


<p><strong>Parameters:</strong></p>
<ul>
<li><code>S</code>: magnitude of the total spin.</li>
<li><code>J</code>: magnitude of the total angular momentum.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>r</code>: binary separation.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>dxidS</code>: derivative of effective potential with respect to S.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.dxidS_plus', this);">Show source &equiv;</a></p>
  <div id="source-precession.dxidS_plus" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">dxidS_plus</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Derivative of the effective potential xi_plus with respect to S.    </span>

<span class="sd">    **Call:**</span>

<span class="sd">        dxidS=precession.dxidS_plus(S,J,q,S1,S2,r)</span>
<span class="sd">    </span>
<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `S`: magnitude of the total spin.</span>
<span class="sd">    - `J`: magnitude of the total angular momentum.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `r`: binary separation.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `dxidS`: derivative of effective potential with respect to S.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="n">L</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
    <span class="n">A1</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="n">S</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">A2</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">L</span><span class="o">+</span><span class="n">S</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">A3</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">A4</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">S1</span><span class="o">+</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">Fp</span> <span class="o">=</span> <span class="p">(</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">S1</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">q</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">+</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">q</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">A1</span><span class="o">*</span><span class="n">A2</span><span class="o">*</span><span class="n">A3</span><span class="o">*</span><span class="n">A4</span>
    <span class="n">G</span><span class="o">=</span><span class="mi">4</span><span class="o">*</span><span class="n">q</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">L</span>
    <span class="n">dFpdS</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">S</span><span class="o">*</span><span class="p">(</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">S1</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">q</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">S</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">q</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(((</span><span class="n">L</span><span class="o">-</span><span class="n">S</span><span class="p">)</span><span class="o">*</span><span class="n">A2</span><span class="o">*</span><span class="n">A3</span><span class="o">*</span><span class="n">A4</span><span class="p">)</span><span class="o">/</span><span class="n">A1</span><span class="o">+</span><span class="p">((</span><span class="n">L</span><span class="o">+</span><span class="n">S</span><span class="p">)</span><span class="o">*</span><span class="n">A3</span><span class="o">*</span><span class="n">A4</span><span class="o">*</span><span class="n">A1</span><span class="p">)</span><span class="o">/</span><span class="n">A2</span><span class="o">+</span><span class="p">(</span><span class="n">S</span><span class="o">*</span><span class="n">A4</span><span class="o">*</span><span class="n">A1</span><span class="o">*</span><span class="n">A2</span><span class="p">)</span><span class="o">/</span><span class="n">A3</span><span class="o">-</span><span class="p">(</span><span class="n">S</span><span class="o">*</span><span class="n">A1</span><span class="o">*</span><span class="n">A2</span><span class="o">*</span><span class="n">A3</span><span class="p">)</span><span class="o">/</span><span class="n">A4</span><span class="p">)</span>
    <span class="n">dGdS</span><span class="o">=</span><span class="mi">8</span><span class="o">*</span><span class="n">q</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">S</span><span class="o">*</span><span class="n">L</span>
    <span class="n">dxipdS</span><span class="o">=</span><span class="p">(</span><span class="n">dFpdS</span><span class="o">*</span><span class="n">G</span><span class="o">-</span><span class="n">dGdS</span><span class="o">*</span><span class="n">Fp</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">G</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">dxipdS</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.empty_temp">
    <p>def <span class="ident">empty_temp</span>(</p><p>)</p>
    </div>
    

    
  
    <div class="desc"><p>Remove all checkpoints.</p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>precession.empty_temp()
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.empty_temp', this);">Show source &equiv;</a></p>
  <div id="source-precession.empty_temp" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">empty_temp</span><span class="p">():</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Remove all checkpoints.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        precession.empty_temp()</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="k">global</span> <span class="n">storedir</span>
    <span class="k">print</span> <span class="s">&quot;[empty_temp] Removing temp files from directory: &quot;</span><span class="o">+</span><span class="n">storedir</span>
    <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s">&quot;rm -rf &quot;</span><span class="o">+</span><span class="n">storedir</span><span class="p">)</span> 
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.evolve_J">
    <p>def <span class="ident">evolve_J</span>(</p><p>xi_vals, J_vals, r_vals, q_vals, S1_vals, S2_vals)</p>
    </div>
    

    
  
    <div class="desc"><p>Wrapper of <a href="#precession.Jofr"><code>Jofr</code></a> to enable parallelization through the python
<code>parmap</code> module; the number of available cores can be specified using the
integer global variable <code>precession.CPUs</code> (all available cores will be used
by default). Evolve a sequence of binaries with the different q, S1, S2, xi
and initial values of J and save outputs at the SAME r_vals. Output is a 2D
array, where e.g. J_vals[0] is the first binary (1D array at all output
separations) and J_vals[0][0] is the first binary at the first output
separation (this is a scalar). We strongly reccommend using this function,
even for a single binary.</p>
<p>Checkpointing is implemented: results are stored in <a href="#precession.storedir"><code>storedir</code></a>.</p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>Jf_vals=precession.evolve_J(xi_vals,Ji_vals,r_vals,q_vals,S1_vals,S2_vals)
</pre></div>


<p><strong>Parameters:</strong></p>
<ul>
<li><code>xi_vals</code>: projection of the effective spin along the orbital angular momentum (array).</li>
<li><code>Ji_vals</code>: initial condition for numerical integration (array).</li>
<li><code>r_vals</code>: binary separation (array).</li>
<li><code>q_vals</code>: binary mass ratio. Must be q&lt;=1 (array).</li>
<li><code>S1_vals</code>: spin magnitude of the primary BH (array).</li>
<li><code>S2_vals</code>: spin magnitude of the secondary BH (array).</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>Jf_vals</code>: magnitude of the total angular momentum (2D array).</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.evolve_J', this);">Show source &equiv;</a></p>
  <div id="source-precession.evolve_J" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">evolve_J</span><span class="p">(</span><span class="n">xi_vals</span><span class="p">,</span><span class="n">J_vals</span><span class="p">,</span><span class="n">r_vals</span><span class="p">,</span><span class="n">q_vals</span><span class="p">,</span><span class="n">S1_vals</span><span class="p">,</span><span class="n">S2_vals</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Wrapper of `precession.Jofr` to enable parallelization through the python</span>
<span class="sd">    `parmap` module; the number of available cores can be specified using the</span>
<span class="sd">    integer global variable `precession.CPUs` (all available cores will be used</span>
<span class="sd">    by default). Evolve a sequence of binaries with the different q, S1, S2, xi</span>
<span class="sd">    and initial values of J and save outputs at the SAME r_vals. Output is a 2D</span>
<span class="sd">    array, where e.g. J_vals[0] is the first binary (1D array at all output</span>
<span class="sd">    separations) and J_vals[0][0] is the first binary at the first output</span>
<span class="sd">    separation (this is a scalar). We strongly reccommend using this function,</span>
<span class="sd">    even for a single binary.</span>

<span class="sd">    Checkpointing is implemented: results are stored in `precession.storedir`.</span>
<span class="sd"> </span>
<span class="sd">    **Call:**</span>

<span class="sd">        Jf_vals=precession.evolve_J(xi_vals,Ji_vals,r_vals,q_vals,S1_vals,S2_vals)</span>
<span class="sd">     </span>
<span class="sd">    **Parameters:**</span>

<span class="sd">    - `xi_vals`: projection of the effective spin along the orbital angular momentum (array).</span>
<span class="sd">    - `Ji_vals`: initial condition for numerical integration (array).</span>
<span class="sd">    - `r_vals`: binary separation (array).</span>
<span class="sd">    - `q_vals`: binary mass ratio. Must be q&lt;=1 (array).</span>
<span class="sd">    - `S1_vals`: spin magnitude of the primary BH (array).</span>
<span class="sd">    - `S2_vals`: spin magnitude of the secondary BH (array).</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `Jf_vals`: magnitude of the total angular momentum (2D array).</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">global</span> <span class="n">CPUs</span>
    <span class="n">single_flag</span><span class="o">=</span><span class="bp">False</span>
    
    <span class="k">try</span><span class="p">:</span> <span class="c"># Convert float to array if you&#39;re evolving just one binary</span>
        <span class="nb">len</span><span class="p">(</span><span class="n">q_vals</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">xi_vals</span><span class="o">=</span><span class="p">[</span><span class="n">xi_vals</span><span class="p">]</span>
        <span class="n">J_vals</span><span class="o">=</span><span class="p">[</span><span class="n">J_vals</span><span class="p">]</span>
        <span class="n">q_vals</span><span class="o">=</span><span class="p">[</span><span class="n">q_vals</span><span class="p">]</span>
        <span class="n">S1_vals</span><span class="o">=</span><span class="p">[</span><span class="n">S1_vals</span><span class="p">]</span>
        <span class="n">S2_vals</span><span class="o">=</span><span class="p">[</span><span class="n">S2_vals</span><span class="p">]</span>
        <span class="n">single_flag</span><span class="o">=</span><span class="bp">True</span>
    <span class="k">try</span><span class="p">:</span> <span class="c"># Set default</span>
        <span class="n">CPUs</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">CPUs</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">print</span> <span class="s">&quot;[evolve_J] Default parallel computation&quot;</span>
    <span class="c"># Parallelization.</span>
    <span class="k">if</span> <span class="n">CPUs</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="c"># Run on all cpus on the current machine! (default option)</span>
        <span class="n">filelist</span><span class="o">=</span><span class="n">parmap</span><span class="o">.</span><span class="n">starmap</span><span class="p">(</span><span class="n">Jofr_checkpoint</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xi_vals</span><span class="p">,</span><span class="n">J_vals</span><span class="p">,</span> <span class="p">[</span><span class="n">r_vals</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q_vals</span><span class="p">))],</span><span class="n">q_vals</span><span class="p">,</span><span class="n">S1_vals</span><span class="p">,</span><span class="n">S2_vals</span><span class="p">),</span><span class="n">parallel</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> 
    <span class="k">elif</span> <span class="n">CPUs</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="c"># 1 cpus done by explicitely switching parallelization off</span>
        <span class="n">filelist</span><span class="o">=</span><span class="n">parmap</span><span class="o">.</span><span class="n">starmap</span><span class="p">(</span><span class="n">Jofr_checkpoint</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xi_vals</span><span class="p">,</span><span class="n">J_vals</span><span class="p">,</span> <span class="p">[</span><span class="n">r_vals</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q_vals</span><span class="p">))],</span><span class="n">q_vals</span><span class="p">,</span><span class="n">S1_vals</span><span class="p">,</span><span class="n">S2_vals</span><span class="p">),</span><span class="n">parallel</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> 
    <span class="k">else</span><span class="p">:</span> <span class="c"># Run on a given number of CPUs        </span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">CPUs</span><span class="p">)</span>
        <span class="n">filelist</span><span class="o">=</span><span class="n">parmap</span><span class="o">.</span><span class="n">starmap</span><span class="p">(</span><span class="n">Jofr_checkpoint</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xi_vals</span><span class="p">,</span><span class="n">J_vals</span><span class="p">,</span> <span class="p">[</span><span class="n">r_vals</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q_vals</span><span class="p">))],</span><span class="n">q_vals</span><span class="p">,</span><span class="n">S1_vals</span><span class="p">,</span><span class="n">S2_vals</span><span class="p">),</span><span class="n">pool</span><span class="o">=</span><span class="n">p</span><span class="p">)</span> 

    <span class="n">J_fvals</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="nb">file</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">filelist</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">&quot;[evolve_J] Reading:&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="nb">file</span>
        <span class="n">dummy</span><span class="p">,</span><span class="n">J_f</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="nb">file</span><span class="p">,</span><span class="n">unpack</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
             
        <span class="n">J_fvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">J_f</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">single_flag</span><span class="o">==</span><span class="bp">True</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">J_fvals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">J_fvals</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.evolve_J_backwards">
    <p>def <span class="ident">evolve_J_backwards</span>(</p><p>xi_vals, J_vals, r, q_vals, S1_vals, S2_vals)</p>
    </div>
    

    
  
    <div class="desc"><p>Wrapper of <a href="#precession.kappa_backwards"><code>kappa_backwards</code></a> to enable parallelization through
the python <code>parmap</code> module; the number of available cores can be specified
using the integer global variable <code>precession.CPUs</code> (all available cores
will be used by default). Evolve a sequence of binaries with the different
q, S1,S2, xi and kappa_inf from the SAME separation r.</p>
<p>Checkpointing is implemented: results are stored in <a href="#precession.storedir"><code>storedir</code></a>.</p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>kappainf_vals=precession.evolve_J_backwards(xi_vals,J_vals,r,q_vals,S1_vals,S2_vals)
</pre></div>


<p><strong>Parameters:</strong></p>
<ul>
<li><code>xi_vals</code>: projection of the effective spin along the orbital angular momentum (array).</li>
<li><code>J</code>: magnitude of the total angular momentum (array).</li>
<li><code>r</code>: binary separation.</li>
<li><code>q_vals</code>: binary mass ratio. Must be q&lt;=1 (array).</li>
<li><code>S1_vals</code>: spin magnitude of the primary BH (array).</li>
<li><code>S2_vals</code>: spin magnitude of the secondary BH (array).</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>kappainf_vals</code>: asymptotic value of kappa at large separations (array).</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.evolve_J_backwards', this);">Show source &equiv;</a></p>
  <div id="source-precession.evolve_J_backwards" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">evolve_J_backwards</span><span class="p">(</span><span class="n">xi_vals</span><span class="p">,</span><span class="n">J_vals</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">q_vals</span><span class="p">,</span><span class="n">S1_vals</span><span class="p">,</span><span class="n">S2_vals</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Wrapper of `precession.kappa_backwards` to enable parallelization through</span>
<span class="sd">    the python `parmap` module; the number of available cores can be specified</span>
<span class="sd">    using the integer global variable `precession.CPUs` (all available cores</span>
<span class="sd">    will be used by default). Evolve a sequence of binaries with the different</span>
<span class="sd">    q, S1,S2, xi and kappa_inf from the SAME separation r.</span>

<span class="sd">    Checkpointing is implemented: results are stored in `precession.storedir`.</span>
<span class="sd"> </span>
<span class="sd">    **Call:**</span>

<span class="sd">        kappainf_vals=precession.evolve_J_backwards(xi_vals,J_vals,r,q_vals,S1_vals,S2_vals)</span>

<span class="sd">    **Parameters:**</span>

<span class="sd">    - `xi_vals`: projection of the effective spin along the orbital angular momentum (array).</span>
<span class="sd">    - `J`: magnitude of the total angular momentum (array).</span>
<span class="sd">    - `r`: binary separation.</span>
<span class="sd">    - `q_vals`: binary mass ratio. Must be q&lt;=1 (array).</span>
<span class="sd">    - `S1_vals`: spin magnitude of the primary BH (array).</span>
<span class="sd">    - `S2_vals`: spin magnitude of the secondary BH (array).</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `kappainf_vals`: asymptotic value of kappa at large separations (array).</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">global</span> <span class="n">CPUs</span>

    <span class="n">flag</span><span class="o">=</span><span class="bp">False</span>
    <span class="k">try</span><span class="p">:</span> <span class="c">#Convert float to array, if you&#39;re evolving just one binary</span>
        <span class="nb">len</span><span class="p">(</span><span class="n">q_vals</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">xi_vals</span><span class="o">=</span><span class="p">[</span><span class="n">xi_vals</span><span class="p">]</span>
        <span class="n">J_vals</span><span class="o">=</span><span class="p">[</span><span class="n">J_vals</span><span class="p">]</span>
        <span class="n">q_vals</span><span class="o">=</span><span class="p">[</span><span class="n">q_vals</span><span class="p">]</span>
        <span class="n">S1_vals</span><span class="o">=</span><span class="p">[</span><span class="n">S1_vals</span><span class="p">]</span>
        <span class="n">S2_vals</span><span class="o">=</span><span class="p">[</span><span class="n">S2_vals</span><span class="p">]</span>
        <span class="n">flag</span><span class="o">=</span><span class="bp">True</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">CPUs</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">CPUs</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">print</span> <span class="s">&quot;[evolve_J_backwards] Default parallel computation&quot;</span>
    <span class="c">#Parallelization... python is cool indeed</span>
    <span class="k">if</span> <span class="n">CPUs</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="c">#Run on all cpus on the current machine! (default option)</span>
        <span class="n">filelist</span><span class="o">=</span><span class="n">parmap</span><span class="o">.</span><span class="n">starmap</span><span class="p">(</span><span class="n">kappa_backwards_checkpoint</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xi_vals</span><span class="p">,</span><span class="n">J_vals</span><span class="p">,[</span><span class="n">r</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q_vals</span><span class="p">))],</span><span class="n">q_vals</span><span class="p">,</span><span class="n">S1_vals</span><span class="p">,</span><span class="n">S2_vals</span><span class="p">),</span><span class="n">parallel</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> 
    <span class="k">elif</span> <span class="n">CPUs</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="c">#1 cpus done by explicitely removing parallelization</span>
        <span class="n">filelist</span><span class="o">=</span><span class="n">parmap</span><span class="o">.</span><span class="n">starmap</span><span class="p">(</span><span class="n">kappa_backwards_checkpoint</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xi_vals</span><span class="p">,</span><span class="n">J_vals</span><span class="p">,[</span><span class="n">r</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q_vals</span><span class="p">))],</span><span class="n">q_vals</span><span class="p">,</span><span class="n">S1_vals</span><span class="p">,</span><span class="n">S2_vals</span><span class="p">),</span><span class="n">parallel</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> 
    <span class="k">else</span><span class="p">:</span> <span class="c"># Run on a given number of CPUs        </span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">CPUs</span><span class="p">)</span>
        <span class="n">filelist</span><span class="o">=</span><span class="n">parmap</span><span class="o">.</span><span class="n">starmap</span><span class="p">(</span><span class="n">kappa_backwards_checkpoint</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xi_vals</span><span class="p">,</span><span class="n">J_vals</span><span class="p">,[</span><span class="n">r</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q_vals</span><span class="p">))],</span><span class="n">q_vals</span><span class="p">,</span><span class="n">S1_vals</span><span class="p">,</span><span class="n">S2_vals</span><span class="p">),</span><span class="n">pool</span><span class="o">=</span><span class="n">p</span><span class="p">)</span> 

    <span class="n">kappainf_vals</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="nb">file</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">filelist</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">&quot;[evolve_J_backwards] Reading:&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="nb">file</span>
        <span class="n">kappa_inf</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="nb">file</span><span class="p">,</span><span class="n">unpack</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>     
        <span class="n">kappainf_vals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kappa_inf</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">flag</span><span class="o">==</span><span class="bp">True</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">kappainf_vals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">kappainf_vals</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.evolve_J_infinity">
    <p>def <span class="ident">evolve_J_infinity</span>(</p><p>xi_vals, kappainf_vals, r_vals, q_vals, S1_vals, S2_vals)</p>
    </div>
    

    
  
    <div class="desc"><p>Wrapper of <a href="#precession.Jofr_infinity"><code>Jofr_infinity</code></a> to enable parallelization through the
python <code>parmap</code> module; the number of available cores can be specified using
the integer global variable <code>precession.CPUs</code> (all available cores will be
used by default). Evolve a sequence of binaries with the different q, S1,
S2, xi and initial values of J and save outputs at the SAME separations
r_vals. Output is a 2D array, where e.g. J_vals[0] is the first binary (1D
array at all output separations) and J_vals[0][0] is the first binary at the
first output separation (this is a scalar). We strongly reccommend using
this function, even for a single binary.</p>
<p>Checkpointing is implemented: results are stored in <a href="#precession.storedir"><code>storedir</code></a>.</p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>Jf_vals=precession.evolve_J_infinity(xi_vals,kappainf_vals,r_vals,q_vals,S1_vals,S2_vals)
</pre></div>


<p><strong>Parameters:</strong></p>
<ul>
<li><code>xi_vals</code>: projection of the effective spin along the orbital angular momentum (array).</li>
<li><code>kappainf_vals</code>: asymptotic value of kappa at large separations (array).</li>
<li><code>r_vals</code>: binary separation (array).</li>
<li><code>q_vals</code>: binary mass ratio. Must be q&lt;=1 (array).</li>
<li><code>S1_vals</code>: spin magnitude of the primary BH (array).</li>
<li><code>S2_vals</code>: spin magnitude of the secondary BH (array).</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>Jf_vals</code>: magnitude of the total angular momentum (2D array).</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.evolve_J_infinity', this);">Show source &equiv;</a></p>
  <div id="source-precession.evolve_J_infinity" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">evolve_J_infinity</span><span class="p">(</span><span class="n">xi_vals</span><span class="p">,</span><span class="n">kappainf_vals</span><span class="p">,</span><span class="n">r_vals</span><span class="p">,</span><span class="n">q_vals</span><span class="p">,</span><span class="n">S1_vals</span><span class="p">,</span><span class="n">S2_vals</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Wrapper of `precession.Jofr_infinity` to enable parallelization through the</span>
<span class="sd">    python `parmap` module; the number of available cores can be specified using</span>
<span class="sd">    the integer global variable `precession.CPUs` (all available cores will be</span>
<span class="sd">    used by default). Evolve a sequence of binaries with the different q, S1,</span>
<span class="sd">    S2, xi and initial values of J and save outputs at the SAME separations</span>
<span class="sd">    r_vals. Output is a 2D array, where e.g. J_vals[0] is the first binary (1D</span>
<span class="sd">    array at all output separations) and J_vals[0][0] is the first binary at the</span>
<span class="sd">    first output separation (this is a scalar). We strongly reccommend using</span>
<span class="sd">    this function, even for a single binary.</span>

<span class="sd">    Checkpointing is implemented: results are stored in `precession.storedir`.</span>
<span class="sd"> </span>
<span class="sd">    **Call:**</span>

<span class="sd">        Jf_vals=precession.evolve_J_infinity(xi_vals,kappainf_vals,r_vals,q_vals,S1_vals,S2_vals)</span>

<span class="sd">    **Parameters:**</span>

<span class="sd">    - `xi_vals`: projection of the effective spin along the orbital angular momentum (array).</span>
<span class="sd">    - `kappainf_vals`: asymptotic value of kappa at large separations (array).</span>
<span class="sd">    - `r_vals`: binary separation (array).</span>
<span class="sd">    - `q_vals`: binary mass ratio. Must be q&lt;=1 (array).</span>
<span class="sd">    - `S1_vals`: spin magnitude of the primary BH (array).</span>
<span class="sd">    - `S2_vals`: spin magnitude of the secondary BH (array).</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `Jf_vals`: magnitude of the total angular momentum (2D array).</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">global</span> <span class="n">CPUs</span>

    <span class="n">single_flag</span><span class="o">=</span><span class="bp">False</span>
    <span class="k">try</span><span class="p">:</span> <span class="c">#Convert float to array if you&#39;re evolving just one binary</span>
        <span class="nb">len</span><span class="p">(</span><span class="n">q_vals</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">xi_vals</span><span class="o">=</span><span class="p">[</span><span class="n">xi_vals</span><span class="p">]</span>
        <span class="n">kappainf_vals</span><span class="o">=</span><span class="p">[</span><span class="n">kappainf_vals</span><span class="p">]</span>
        <span class="n">q_vals</span><span class="o">=</span><span class="p">[</span><span class="n">q_vals</span><span class="p">]</span>
        <span class="n">S1_vals</span><span class="o">=</span><span class="p">[</span><span class="n">S1_vals</span><span class="p">]</span>
        <span class="n">S2_vals</span><span class="o">=</span><span class="p">[</span><span class="n">S2_vals</span><span class="p">]</span>
        <span class="n">single_flag</span><span class="o">=</span><span class="bp">True</span>
    <span class="k">try</span><span class="p">:</span> <span class="c"># Set default</span>
        <span class="n">CPUs</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">CPUs</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">print</span> <span class="s">&quot;[evolve_J_infinity] Default parallel computation&quot;</span>
    <span class="c"># Parallelization</span>
    <span class="k">if</span> <span class="n">CPUs</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="c"># Run on all cpus on the current machine! (default option)</span>
        <span class="n">filelist</span><span class="o">=</span><span class="n">parmap</span><span class="o">.</span><span class="n">starmap</span><span class="p">(</span><span class="n">Jofr_infinity_checkpoint</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xi_vals</span><span class="p">,</span><span class="n">kappainf_vals</span><span class="p">,[</span><span class="n">r_vals</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q_vals</span><span class="p">))],</span><span class="n">q_vals</span><span class="p">,</span><span class="n">S1_vals</span><span class="p">,</span><span class="n">S2_vals</span><span class="p">),</span><span class="n">parallel</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> 
    <span class="k">elif</span> <span class="n">CPUs</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="c"># 1 cpus done by explicitely removing parallelization</span>
        <span class="n">filelist</span><span class="o">=</span><span class="n">parmap</span><span class="o">.</span><span class="n">starmap</span><span class="p">(</span><span class="n">Jofr_infinity_checkpoint</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xi_vals</span><span class="p">,</span><span class="n">kappainf_vals</span><span class="p">,[</span><span class="n">r_vals</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q_vals</span><span class="p">))],</span><span class="n">q_vals</span><span class="p">,</span><span class="n">S1_vals</span><span class="p">,</span><span class="n">S2_vals</span><span class="p">),</span><span class="n">parallel</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> 
    <span class="k">else</span><span class="p">:</span> <span class="c"># Run on a given number of CPUs        </span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">CPUs</span><span class="p">)</span>
        <span class="n">filelist</span><span class="o">=</span><span class="n">parmap</span><span class="o">.</span><span class="n">starmap</span><span class="p">(</span><span class="n">Jofr_infinity_checkpoint</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xi_vals</span><span class="p">,</span><span class="n">kappainf_vals</span><span class="p">,[</span><span class="n">r_vals</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q_vals</span><span class="p">))],</span><span class="n">q_vals</span><span class="p">,</span><span class="n">S1_vals</span><span class="p">,</span><span class="n">S2_vals</span><span class="p">),</span><span class="n">pool</span><span class="o">=</span><span class="n">p</span><span class="p">)</span> 

    <span class="n">J_fvals</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="nb">file</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">filelist</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">&quot;[evolve_J_infinity] Reading:&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="nb">file</span>
        <span class="n">dummy</span><span class="p">,</span><span class="n">J_f</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="nb">file</span><span class="p">,</span><span class="n">unpack</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
             
        <span class="n">J_fvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">J_f</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">single_flag</span><span class="o">==</span><span class="bp">True</span><span class="p">:</span>    
        <span class="k">return</span> <span class="n">J_fvals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">J_fvals</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.evolve_angles">
    <p>def <span class="ident">evolve_angles</span>(</p><p>theta1_vals, theta2_vals, deltaphi_vals, r_vals, q_vals, S1_vals, S2_vals)</p>
    </div>
    

    
  
    <div class="desc"><p>Binary evolution from the angles theta1, theta2 and deltaphi as initial data
(to/from FINITE separations only). This is our so-called <em>transfer
function</em>. The transfer procedure is implemented as follows:</p>
<ol>
<li>Convert theta1,theta2, deltaphi into J, xi and S.</li>
<li>Forget S and evolve J.</li>
<li>Resample S at the final separation according to dt/dS.</li>
<li>Covert J, xi and S back to theta1, theta2 and deltaphi; assign a random
sign to deltaphi.</li>
</ol>
<p>Parallelization through the python <code>parmap</code> module is implemented; the
number of available cores can be specified using the integer global variable
<code>precession.CPUs</code> (all available cores will be used by default). Evolve a
sequence of binaries with different values of q, S1,S2, theta1, theta2,
deltaphi (assumed to be specified at r_vals[0]) and save outputs at SAME
separations r_vals. Outputs are 2D arrays, where e.g theta1_fvals[0] is the
first binary (1D array at all output separations) and theta1_fvals[0][0] is
the first binary at the first output separation (this is a scalar).</p>
<p>Checkpointing is implemented: results are stored in <a href="#precession.storedir"><code>storedir</code></a>.</p>
<p><strong>Call:</strong>
    theta1f_vals,theta2f_vals,deltaphif_vals=precession.evolve_angles(theta1i_vals,theta2i_vals,deltaphii_vals,r_vals,q_vals,S1_vals,S2_vals)</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>theta1i_vals</code>: initial condition for theta1 (array).</li>
<li><code>theta2i_vals</code>: initial condition for theta2 (array).</li>
<li><code>deltaphii_vals</code>: initial condition for deltaphi (array).</li>
<li><code>r_vals</code>: binary separation (array).</li>
<li><code>q_vals</code>: binary mass ratio. Must be q&lt;=1 (array).</li>
<li><code>S1_vals</code>: spin magnitude of the primary BH (array).</li>
<li><code>S2_vals</code>: spin magnitude of the secondary BH (array).</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>theta1f_vals</code>: solutions for theta1 (2D array).</li>
<li><code>theta2f_vals</code>: solutions for theta2 (2D array).</li>
<li><code>deltaphif_vals</code>: solutions for deltaphi (2D array).</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.evolve_angles', this);">Show source &equiv;</a></p>
  <div id="source-precession.evolve_angles" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">evolve_angles</span><span class="p">(</span><span class="n">theta1_vals</span><span class="p">,</span><span class="n">theta2_vals</span><span class="p">,</span><span class="n">deltaphi_vals</span><span class="p">,</span><span class="n">r_vals</span><span class="p">,</span><span class="n">q_vals</span><span class="p">,</span><span class="n">S1_vals</span><span class="p">,</span><span class="n">S2_vals</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Binary evolution from the angles theta1, theta2 and deltaphi as initial data</span>
<span class="sd">    (to/from FINITE separations only). This is our so-called *transfer</span>
<span class="sd">    function*. The transfer procedure is implemented as follows:</span>

<span class="sd">    1. Convert theta1,theta2, deltaphi into J, xi and S.</span>
<span class="sd">    2. Forget S and evolve J.</span>
<span class="sd">    3. Resample S at the final separation according to dt/dS.</span>
<span class="sd">    4. Covert J, xi and S back to theta1, theta2 and deltaphi; assign a random</span>
<span class="sd">    sign to deltaphi.</span>

<span class="sd">    Parallelization through the python `parmap` module is implemented; the</span>
<span class="sd">    number of available cores can be specified using the integer global variable</span>
<span class="sd">    `precession.CPUs` (all available cores will be used by default). Evolve a</span>
<span class="sd">    sequence of binaries with different values of q, S1,S2, theta1, theta2,</span>
<span class="sd">    deltaphi (assumed to be specified at r_vals[0]) and save outputs at SAME</span>
<span class="sd">    separations r_vals. Outputs are 2D arrays, where e.g theta1_fvals[0] is the</span>
<span class="sd">    first binary (1D array at all output separations) and theta1_fvals[0][0] is</span>
<span class="sd">    the first binary at the first output separation (this is a scalar).</span>

<span class="sd">    Checkpointing is implemented: results are stored in `precession.storedir`.</span>

<span class="sd">    **Call:**</span>
<span class="sd">        theta1f_vals,theta2f_vals,deltaphif_vals=precession.evolve_angles(theta1i_vals,theta2i_vals,deltaphii_vals,r_vals,q_vals,S1_vals,S2_vals)</span>
<span class="sd">         </span>
<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `theta1i_vals`: initial condition for theta1 (array).</span>
<span class="sd">    - `theta2i_vals`: initial condition for theta2 (array).</span>
<span class="sd">    - `deltaphii_vals`: initial condition for deltaphi (array).</span>
<span class="sd">    - `r_vals`: binary separation (array).</span>
<span class="sd">    - `q_vals`: binary mass ratio. Must be q&lt;=1 (array).</span>
<span class="sd">    - `S1_vals`: spin magnitude of the primary BH (array).</span>
<span class="sd">    - `S2_vals`: spin magnitude of the secondary BH (array).</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `theta1f_vals`: solutions for theta1 (2D array).</span>
<span class="sd">    - `theta2f_vals`: solutions for theta2 (2D array).</span>
<span class="sd">    - `deltaphif_vals`: solutions for deltaphi (2D array).</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">global</span> <span class="n">CPUs</span>
    <span class="n">single_flag</span><span class="o">=</span><span class="bp">False</span>

    <span class="k">try</span><span class="p">:</span> <span class="c"># Convert float to array if you&#39;re evolving just one binary</span>
        <span class="nb">len</span><span class="p">(</span><span class="n">q_vals</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">single_flag</span><span class="o">=</span><span class="bp">True</span>
        <span class="n">theta1_vals</span><span class="o">=</span><span class="p">[</span><span class="n">theta1_vals</span><span class="p">]</span>
        <span class="n">theta2_vals</span><span class="o">=</span><span class="p">[</span><span class="n">theta2_vals</span><span class="p">]</span>
        <span class="n">deltaphi_vals</span><span class="o">=</span><span class="p">[</span><span class="n">deltaphi_vals</span><span class="p">]</span>
        <span class="n">q_vals</span><span class="o">=</span><span class="p">[</span><span class="n">q_vals</span><span class="p">]</span>
        <span class="n">S1_vals</span><span class="o">=</span><span class="p">[</span><span class="n">S1_vals</span><span class="p">]</span>
        <span class="n">S2_vals</span><span class="o">=</span><span class="p">[</span><span class="n">S2_vals</span><span class="p">]</span>
    <span class="k">try</span><span class="p">:</span> <span class="c"># Set default</span>
        <span class="n">CPUs</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">CPUs</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">print</span> <span class="s">&quot;[evolve_angles] Default parallel computation&quot;</span>

    <span class="n">loopflag</span><span class="o">=</span><span class="bp">True</span>
    <span class="k">while</span> <span class="n">loopflag</span><span class="p">:</span> <span class="c"># Restart is some of the cores crashed. This happend if you run too many binaries on too many different machines. Nevermind, trash the file and do it again.</span>
        <span class="n">loopflag</span><span class="o">=</span><span class="bp">False</span>

        <span class="c">#Parallelization</span>
        <span class="k">if</span> <span class="n">CPUs</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="c">#Run on all cpus on the current machine! (default option)    </span>
            <span class="n">filelist</span><span class="o">=</span><span class="n">parmap</span><span class="o">.</span><span class="n">starmap</span><span class="p">(</span><span class="n">evolve_angles_single</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">theta1_vals</span><span class="p">,</span><span class="n">theta2_vals</span><span class="p">,</span><span class="n">deltaphi_vals</span><span class="p">,[</span><span class="n">r_vals</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q_vals</span><span class="p">))],</span><span class="n">q_vals</span><span class="p">,</span><span class="n">S1_vals</span><span class="p">,</span><span class="n">S2_vals</span><span class="p">),</span><span class="n">parallel</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> 
        <span class="k">elif</span> <span class="n">CPUs</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="c">#1 cpus done by explicitely removing parallelization</span>
            <span class="n">filelist</span><span class="o">=</span><span class="n">parmap</span><span class="o">.</span><span class="n">starmap</span><span class="p">(</span><span class="n">evolve_angles_single</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">theta1_vals</span><span class="p">,</span><span class="n">theta2_vals</span><span class="p">,</span><span class="n">deltaphi_vals</span><span class="p">,[</span><span class="n">r_vals</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q_vals</span><span class="p">))],</span><span class="n">q_vals</span><span class="p">,</span><span class="n">S1_vals</span><span class="p">,</span><span class="n">S2_vals</span><span class="p">),</span><span class="n">parallel</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> 
        <span class="k">else</span><span class="p">:</span> <span class="c"># Run on a given number of CPUs        </span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">CPUs</span><span class="p">)</span>
            <span class="n">filelist</span><span class="o">=</span><span class="n">parmap</span><span class="o">.</span><span class="n">starmap</span><span class="p">(</span><span class="n">evolve_angles_single</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">theta1_vals</span><span class="p">,</span><span class="n">theta2_vals</span><span class="p">,</span><span class="n">deltaphi_vals</span><span class="p">,[</span><span class="n">r_vals</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q_vals</span><span class="p">))],</span><span class="n">q_vals</span><span class="p">,</span><span class="n">S1_vals</span><span class="p">,</span><span class="n">S2_vals</span><span class="p">),</span><span class="n">pool</span><span class="o">=</span><span class="n">p</span><span class="p">)</span> 

        <span class="n">theta1_fvals</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">theta2_fvals</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">deltaphi_fvals</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="nb">file</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">filelist</span><span class="p">):</span>
            <span class="k">print</span> <span class="s">&quot;[evolve_angles] Reading:&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="nb">file</span>
            <span class="n">numlines</span><span class="o">=</span><span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">open</span><span class="p">(</span><span class="nb">file</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">numlines</span><span class="o">!=</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">numlines</span><span class="o">!=</span><span class="nb">len</span><span class="p">(</span><span class="n">r_vals</span><span class="p">):</span> <span class="c"># Restart if core(s) crashed</span>
                <span class="k">print</span> <span class="s">&quot;[evolve_angles] Error on file&quot;</span><span class="p">,</span> <span class="nb">file</span><span class="p">,</span><span class="s">&quot;. Jobs are being restarted!&quot;</span>
                <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s">&quot;rm &quot;</span><span class="o">+</span><span class="nb">file</span><span class="p">)</span> 
                <span class="n">loopflag</span><span class="o">=</span><span class="bp">True</span>
 
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dummy</span><span class="p">,</span><span class="n">theta1_f</span><span class="p">,</span><span class="n">theta2_f</span><span class="p">,</span><span class="n">deltaphi_f</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="nb">file</span><span class="p">,</span><span class="n">unpack</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                <span class="n">theta1_fvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">theta1_f</span><span class="p">)</span>
                <span class="n">theta2_fvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">theta2_f</span><span class="p">)</span>
                <span class="n">deltaphi_fvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">deltaphi_f</span><span class="p">)</span>        
        
    <span class="k">if</span> <span class="n">single_flag</span><span class="o">==</span><span class="bp">True</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">theta1_fvals</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">theta2_fvals</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">deltaphi_fvals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">theta1_fvals</span><span class="p">,</span> <span class="n">theta2_fvals</span><span class="p">,</span> <span class="n">deltaphi_fvals</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.evolve_angles_single">
    <p>def <span class="ident">evolve_angles_single</span>(</p><p>theta1_i, theta2_i, deltaphi_i, r_vals, q, S1, S2)</p>
    </div>
    

    
  
    <div class="desc"><p>Auxiliary function, see <a href="#precession.evolve_angles"><code>evolve_angles</code></a>.</p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>savename=precession.evolve_angles(theta1_i,theta2_i,deltaphi_i,r_vals,q,S1,S2)
</pre></div>


<p><strong>Parameters:</strong></p>
<ul>
<li><code>theta1_i</code>: initial condition for theta1.</li>
<li><code>theta2_i</code>: initial condition for theta2</li>
<li><code>deltaphi_i</code>: initial condition for deltaphi.</li>
<li><code>r_vals</code>: binary separation (array).</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>savename</code>: checkpoint filename.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.evolve_angles_single', this);">Show source &equiv;</a></p>
  <div id="source-precession.evolve_angles_single" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">evolve_angles_single</span><span class="p">(</span><span class="n">theta1_i</span><span class="p">,</span><span class="n">theta2_i</span><span class="p">,</span><span class="n">deltaphi_i</span><span class="p">,</span><span class="n">r_vals</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Auxiliary function, see `precession.evolve_angles`.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        savename=precession.evolve_angles(theta1_i,theta2_i,deltaphi_i,r_vals,q,S1,S2)</span>

<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `theta1_i`: initial condition for theta1.</span>
<span class="sd">    - `theta2_i`: initial condition for theta2</span>
<span class="sd">    - `deltaphi_i`: initial condition for deltaphi.</span>
<span class="sd">    - `r_vals`: binary separation (array).</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `savename`: checkpoint filename.</span>
<span class="sd">    &#39;&#39;&#39;</span>


    <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s">&quot;mkdir -p &quot;</span><span class="o">+</span><span class="n">storedir</span><span class="p">)</span> 
    <span class="n">savename</span><span class="o">=</span> <span class="n">storedir</span><span class="o">+</span><span class="s">&quot;/eva_&quot;</span><span class="o">+</span><span class="s">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">(</span><span class="n">theta1_i</span><span class="p">,</span><span class="n">theta2_i</span><span class="p">,</span><span class="n">deltaphi_i</span><span class="p">,</span><span class="nb">max</span><span class="p">(</span><span class="n">r_vals</span><span class="p">),</span><span class="nb">min</span><span class="p">(</span><span class="n">r_vals</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">r_vals</span><span class="p">),</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">)])</span><span class="o">+</span><span class="s">&quot;.dat&quot;</span>
        
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">savename</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">&quot;[evolve_angles] Transferring binary. Output:&quot;</span><span class="p">,</span> <span class="n">savename</span>
        <span class="n">outfilesave</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">savename</span><span class="p">,</span><span class="s">&quot;w&quot;</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
       
        <span class="c"># Step 1. Get xi and J for each intial angle. Forget S    </span>
        <span class="n">xi</span><span class="p">,</span><span class="n">J_i</span><span class="p">,</span><span class="n">dummy</span><span class="o">=</span> <span class="n">from_the_angles</span><span class="p">(</span><span class="n">theta1_i</span><span class="p">,</span><span class="n">theta2_i</span><span class="p">,</span><span class="n">deltaphi_i</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r_vals</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> 
                
        <span class="c"># Step 2. Evolve binaires with the dJ/dr ODE.</span>
        <span class="n">J_vals</span><span class="o">=</span> <span class="n">Jofr</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">J_i</span><span class="p">,</span><span class="n">r_vals</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">J_f</span><span class="p">,</span><span class="n">r_f</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">J_vals</span><span class="p">,</span><span class="n">r_vals</span><span class="p">):</span>
            <span class="c"># Step 3. Select S at the final separation with weight dt/dS</span>
            <span class="n">S_f</span><span class="o">=</span><span class="n">samplingS</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">J_f</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r_f</span><span class="p">)</span>
            <span class="c"># Step 4. Back to theta1, theta2, deltaphi</span>
            <span class="n">theta1_f</span><span class="p">,</span><span class="n">theta2_f</span><span class="p">,</span><span class="n">deltaphi_f</span><span class="p">,</span><span class="n">dummy</span><span class="o">=</span> <span class="n">parametric_angles</span><span class="p">(</span><span class="n">S_f</span><span class="p">,</span><span class="n">J_f</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r_f</span><span class="p">)</span>
            <span class="n">deltaphi_f</span><span class="o">*=</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">([</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">])</span>
            <span class="c"># Step 5. Store data            </span>
            <span class="c">#outfilesave.write(str(r_f)+&quot; &quot;+str(xi)+&quot; &quot;+str(J_f)+&quot; &quot;+str(S_f)+&quot; &quot;+str(theta1_f)+&quot; &quot;+str(theta2_f)+&quot; &quot;+str(deltaphi_f)+&quot;\n&quot;)</span>
            <span class="n">outfilesave</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">r_f</span><span class="p">)</span><span class="o">+</span><span class="s">&quot; &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">theta1_f</span><span class="p">)</span><span class="o">+</span><span class="s">&quot; &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">theta2_f</span><span class="p">)</span><span class="o">+</span><span class="s">&quot; &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">deltaphi_f</span><span class="p">)</span><span class="o">+</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
        <span class="n">outfilesave</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="c">#else:</span>
    <span class="c">#    print &quot;[evolve_angles] Skipping. Output:&quot;, savename</span>
    
    <span class="k">return</span> <span class="n">savename</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.finalkick">
    <p>def <span class="ident">finalkick</span>(</p><p>theta1, theta2, deltaPhi, q, S1, S2, maxkick=False, kms=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Estimate the final kick of the BH remnant following a BH merger. We
implement the fitting formula to numerical relativity simulations developed
by the Rochester group. The larger contribution comes from the component of
the kick parallel to L. Flags let you switch on and off the various
contributions (all on by default): superkicks (Gonzalez et al. 2007a;
Campanelli et al. 2007), hang-up kicks (Lousto &amp; Zlochower 2011),
cross-kicks (Lousto &amp; Zlochower 2013). The orbital-plane kick components are
implemented as described in Kesden et al. 2010a. See also Gerosa and Sesana
2015.</p>
<p>The final kick depends on the orbital phase at merger Theta. By default,
this is assumed to be randonly distributed in [0,2pi]. The maximum kick is
realized for Theta=0 and can be computed with the optional argument
maxkick=True. This formula has to be applied <em>close to merger</em>, where
numerical relativity simulations are available. You should do a PN evolution
to transfer binaries at r~10M.</p>
<p>The final kick is returned in geometrical units (i.e. vkick/c) by default,
and converted to km/s if kms=True.</p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>vkick=precession.finalkick(theta1,theta2,deltaPhi,q,S1,S2,maxkick=False,kms=False)
</pre></div>


<p><strong>Parameters:</strong></p>
<ul>
<li><code>theta1</code>: angle between the spin of the primary and the orbital angular momentum.</li>
<li><code>theta2</code>: angle between the spin of the secondary and the orbital angular momentum.</li>
<li><code>deltaphi</code>: angle between the projection of the two spins on the orbital plane.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>maxkick</code>: if <code>True</code> maximizes over the orbital phase at merger.</li>
<li><code>kms</code>: if <code>True</code> convert result to km/s.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>vkick</code>: dimensionless kick of the BH remnant</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.finalkick', this);">Show source &equiv;</a></p>
  <div id="source-precession.finalkick" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">finalkick</span><span class="p">(</span><span class="n">theta1</span><span class="p">,</span><span class="n">theta2</span><span class="p">,</span><span class="n">deltaPhi</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">maxkick</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">kms</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Estimate the final kick of the BH remnant following a BH merger. We</span>
<span class="sd">    implement the fitting formula to numerical relativity simulations developed</span>
<span class="sd">    by the Rochester group. The larger contribution comes from the component of</span>
<span class="sd">    the kick parallel to L. Flags let you switch on and off the various</span>
<span class="sd">    contributions (all on by default): superkicks (Gonzalez et al. 2007a;</span>
<span class="sd">    Campanelli et al. 2007), hang-up kicks (Lousto &amp; Zlochower 2011),</span>
<span class="sd">    cross-kicks (Lousto &amp; Zlochower 2013). The orbital-plane kick components are</span>
<span class="sd">    implemented as described in Kesden et al. 2010a. See also Gerosa and Sesana</span>
<span class="sd">    2015.</span>

<span class="sd">    The final kick depends on the orbital phase at merger Theta. By default,</span>
<span class="sd">    this is assumed to be randonly distributed in [0,2pi]. The maximum kick is</span>
<span class="sd">    realized for Theta=0 and can be computed with the optional argument</span>
<span class="sd">    maxkick=True. This formula has to be applied *close to merger*, where</span>
<span class="sd">    numerical relativity simulations are available. You should do a PN evolution</span>
<span class="sd">    to transfer binaries at r~10M.</span>
<span class="sd">   </span>
<span class="sd">    The final kick is returned in geometrical units (i.e. vkick/c) by default,</span>
<span class="sd">    and converted to km/s if kms=True.</span>
<span class="sd">    </span>
<span class="sd">    **Call:**</span>

<span class="sd">        vkick=precession.finalkick(theta1,theta2,deltaPhi,q,S1,S2,maxkick=False,kms=False)</span>

<span class="sd">    **Parameters:**</span>

<span class="sd">    - `theta1`: angle between the spin of the primary and the orbital angular momentum.</span>
<span class="sd">    - `theta2`: angle between the spin of the secondary and the orbital angular momentum.</span>
<span class="sd">    - `deltaphi`: angle between the projection of the two spins on the orbital plane.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `maxkick`: if `True` maximizes over the orbital phase at merger.</span>
<span class="sd">    - `kms`: if `True` convert result to km/s.</span>

<span class="sd">    **Returns:**</span>
<span class="sd">    </span>
<span class="sd">    - `vkick`: dimensionless kick of the BH remnant</span>
<span class="sd">    &#39;&#39;&#39;</span>

    
    <span class="n">chi1</span><span class="o">=</span><span class="n">S1</span><span class="o">/</span><span class="p">(</span><span class="n">M</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span>   <span class="c"># Dimensionless spin</span>
    <span class="n">chi2</span><span class="o">=</span><span class="n">S2</span><span class="o">/</span><span class="p">(</span><span class="n">q</span><span class="o">*</span><span class="n">M</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span> <span class="c"># Dimensionless spin</span>
    <span class="n">eta</span><span class="o">=</span><span class="n">q</span><span class="o">*</span><span class="nb">pow</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">,</span><span class="o">-</span><span class="mf">2.</span><span class="p">)</span>     <span class="c"># Symmetric mass ratio</span>
    
    <span class="c"># Spins here are defined in a frame with L along z and S1 in xz</span>
    <span class="n">hatL</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">hatS1</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta1</span><span class="p">),</span><span class="mi">0</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta1</span><span class="p">)])</span>
    <span class="n">hatS2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta2</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">deltaPhi</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta2</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">deltaPhi</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta2</span><span class="p">)])</span>
    <span class="c">#Useful spin combinations. </span>
    <span class="n">Delta</span><span class="o">=</span> <span class="p">(</span><span class="n">q</span><span class="o">*</span><span class="n">chi2</span><span class="o">*</span><span class="n">hatS2</span><span class="o">-</span><span class="n">chi1</span><span class="o">*</span><span class="n">hatS1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span>
    <span class="n">Delta_par</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Delta</span><span class="p">,</span><span class="n">hatL</span><span class="p">)</span>
    <span class="n">Delta_perp</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">Delta</span><span class="p">,</span><span class="n">hatL</span><span class="p">))</span>
    <span class="n">chit</span><span class="o">=</span> <span class="p">(</span><span class="n">q</span><span class="o">*</span><span class="n">q</span><span class="o">*</span><span class="n">chi2</span><span class="o">*</span><span class="n">hatS2</span><span class="o">+</span><span class="n">chi1</span><span class="o">*</span><span class="n">hatS1</span><span class="p">)</span><span class="o">/</span><span class="nb">pow</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">,</span><span class="mf">2.</span><span class="p">)</span>
    <span class="n">chit_par</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">chit</span><span class="p">,</span><span class="n">hatL</span><span class="p">)</span>
    <span class="n">chit_perp</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">chit</span><span class="p">,</span><span class="n">hatL</span><span class="p">))</span>
    
    <span class="c">#Kick. Coefficients are quoted in km/s</span>
    
    <span class="c"># vm and vperp are like in Kesden at 2010a, vpar is modified from Lousto Zlochower 2013</span>
    <span class="n">zeta</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mf">145.</span><span class="p">)</span>
    <span class="n">A</span><span class="o">=</span><span class="mf">1.2e4</span>
    <span class="n">B</span><span class="o">=-</span><span class="mf">0.93</span>
    <span class="n">H</span><span class="o">=</span><span class="mf">6.9e3</span>

    <span class="c"># Switch on/off the various (super)kick contribution. Default are all on    </span>
    <span class="n">superkick</span><span class="o">=</span><span class="bp">True</span>
    <span class="n">hangupkick</span><span class="o">=</span><span class="bp">True</span>
    <span class="n">crosskick</span><span class="o">=</span><span class="bp">True</span>
    
    <span class="k">if</span> <span class="n">superkick</span><span class="o">==</span><span class="bp">True</span><span class="p">:</span>
        <span class="n">V11</span><span class="o">=</span><span class="mf">3677.76</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">V11</span><span class="o">=</span><span class="mf">0.</span>
    <span class="k">if</span> <span class="n">hangupkick</span><span class="o">==</span><span class="bp">True</span><span class="p">:</span>    
        <span class="n">VA</span><span class="o">=</span><span class="mf">2481.21</span>
        <span class="n">VB</span><span class="o">=</span><span class="mf">1792.45</span>
        <span class="n">VC</span><span class="o">=</span><span class="mf">1506.52</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">VA</span><span class="o">=</span><span class="mf">0.</span>
        <span class="n">VB</span><span class="o">=</span><span class="mf">0.</span>
        <span class="n">VC</span><span class="o">=</span><span class="mf">0.</span>
    <span class="k">if</span> <span class="n">crosskick</span><span class="o">==</span><span class="bp">True</span><span class="p">:</span>
        <span class="n">C2</span><span class="o">=</span><span class="mf">1140.</span>
        <span class="n">C3</span><span class="o">=</span><span class="mf">2481.</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">C2</span><span class="o">=</span><span class="mf">0.</span>
        <span class="n">C3</span><span class="o">=</span><span class="mf">0.</span>
        
    <span class="k">if</span> <span class="n">maxkick</span><span class="o">==</span><span class="bp">True</span><span class="p">:</span>
        <span class="n">bigTheta</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">bigTheta</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">2.</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
    
    <span class="n">vm</span><span class="o">=</span><span class="n">A</span><span class="o">*</span><span class="n">eta</span><span class="o">*</span><span class="n">eta</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">B</span><span class="o">*</span><span class="n">eta</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">q</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span>
    <span class="n">vperp</span><span class="o">=</span><span class="n">H</span><span class="o">*</span><span class="n">eta</span><span class="o">*</span><span class="n">eta</span><span class="o">*</span><span class="n">Delta_par</span>
    <span class="n">vpar</span><span class="o">=</span><span class="mf">16.</span><span class="o">*</span><span class="n">eta</span><span class="o">*</span><span class="n">eta</span><span class="o">*</span> <span class="p">(</span><span class="n">Delta_perp</span><span class="o">*</span><span class="p">(</span><span class="n">V11</span><span class="o">+</span><span class="mf">2.</span><span class="o">*</span><span class="n">VA</span><span class="o">*</span><span class="n">chit_par</span><span class="o">+</span><span class="mf">4.</span><span class="o">*</span><span class="n">VB</span><span class="o">*</span><span class="nb">pow</span><span class="p">(</span><span class="n">chit_par</span><span class="p">,</span><span class="mf">2.</span><span class="p">)</span><span class="o">+</span><span class="mf">8.</span><span class="o">*</span><span class="n">VC</span><span class="o">*</span><span class="nb">pow</span><span class="p">(</span><span class="n">chit_par</span><span class="p">,</span><span class="mf">3.</span><span class="p">))</span> <span class="o">+</span> <span class="n">chit_perp</span><span class="o">*</span><span class="n">Delta_par</span><span class="o">*</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">C2</span><span class="o">+</span><span class="mf">4.</span><span class="o">*</span><span class="n">C3</span><span class="o">*</span><span class="n">chit_par</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">bigTheta</span><span class="p">)</span>         
    <span class="n">vkick</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">([</span><span class="n">vm</span><span class="o">+</span><span class="n">vperp</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">zeta</span><span class="p">),</span><span class="n">vperp</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">zeta</span><span class="p">),</span><span class="n">vpar</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">vkick</span><span class="o">&gt;</span><span class="mi">5000</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&quot;[finalkick] Warning; I got v_kick&gt;5000km/s. This shouldn&#39;t be possibile&quot;</span>
    
    <span class="k">if</span> <span class="n">kms</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">vkick</span>
    <span class="k">else</span><span class="p">:</span>  <span class="c"># speed of light in km/s</span>
        <span class="k">return</span> <span class="n">vkick</span><span class="o">/</span><span class="mf">299792.458</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.finalmass">
    <p>def <span class="ident">finalmass</span>(</p><p>theta1, theta2, deltaPhi, q, S1, S2)</p>
    </div>
    

    
  
    <div class="desc"><p>Estimate the final mass of the BH renmant following a BH merger. We
implement the fitting formula to numerical relativity simulations by
Barausse Morozova Rezzolla 2012.  See also Gerosa and Sesana 2015. This
formula has to be applied <em>close to merger</em>, where numerical relativity
simulations are available. You should do a PN evolution to transfer binaries
at r~10M.</p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>Mfin=precession.finalmass(theta1,theta2,deltaPhi,q,S1,S2)
</pre></div>


<p><strong>Parameters:</strong></p>
<ul>
<li><code>theta1</code>: angle between the spin of the primary and the orbital angular momentum.</li>
<li><code>theta2</code>: angle between the spin of the secondary and the orbital angular momentum.</li>
<li><code>deltaphi</code>: angle between the projection of the two spins on the orbital plane.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>Mfin</code>: mass of the BH remnant, in units of the (pre-merger) binary total mass</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.finalmass', this);">Show source &equiv;</a></p>
  <div id="source-precession.finalmass" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">finalmass</span><span class="p">(</span><span class="n">theta1</span><span class="p">,</span><span class="n">theta2</span><span class="p">,</span><span class="n">deltaPhi</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Estimate the final mass of the BH renmant following a BH merger. We</span>
<span class="sd">    implement the fitting formula to numerical relativity simulations by</span>
<span class="sd">    Barausse Morozova Rezzolla 2012.  See also Gerosa and Sesana 2015. This</span>
<span class="sd">    formula has to be applied *close to merger*, where numerical relativity</span>
<span class="sd">    simulations are available. You should do a PN evolution to transfer binaries</span>
<span class="sd">    at r~10M.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        Mfin=precession.finalmass(theta1,theta2,deltaPhi,q,S1,S2)</span>

<span class="sd">    **Parameters:**</span>

<span class="sd">    - `theta1`: angle between the spin of the primary and the orbital angular momentum.</span>
<span class="sd">    - `theta2`: angle between the spin of the secondary and the orbital angular momentum.</span>
<span class="sd">    - `deltaphi`: angle between the projection of the two spins on the orbital plane.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>

<span class="sd">    **Returns:**</span>
<span class="sd">    </span>
<span class="sd">    - `Mfin`: mass of the BH remnant, in units of the (pre-merger) binary total mass</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">chi1</span><span class="o">=</span><span class="n">S1</span><span class="o">/</span><span class="p">(</span><span class="n">M</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span>   <span class="c"># Dimensionless spin</span>
    <span class="n">chi2</span><span class="o">=</span><span class="n">S2</span><span class="o">/</span><span class="p">(</span><span class="n">q</span><span class="o">*</span><span class="n">M</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span> <span class="c"># Dimensionless spin</span>
    <span class="n">eta</span><span class="o">=</span><span class="n">q</span><span class="o">*</span><span class="nb">pow</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">,</span><span class="o">-</span><span class="mf">2.</span><span class="p">)</span>     <span class="c"># Symmetric mass ratio</span>
    
    <span class="c"># Spins here are defined in a frame with L along z and S1 in xz</span>
    <span class="n">hatL</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">hatS1</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta1</span><span class="p">),</span><span class="mi">0</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta1</span><span class="p">)])</span>
    <span class="n">hatS2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta2</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">deltaPhi</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta2</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">deltaPhi</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta2</span><span class="p">)])</span>
    <span class="c">#Useful spin combinations. </span>
    <span class="n">Delta</span><span class="o">=</span> <span class="p">(</span><span class="n">q</span><span class="o">*</span><span class="n">chi2</span><span class="o">*</span><span class="n">hatS2</span><span class="o">-</span><span class="n">chi1</span><span class="o">*</span><span class="n">hatS1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span>
    <span class="n">Delta_par</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Delta</span><span class="p">,</span><span class="n">hatL</span><span class="p">)</span>
    <span class="n">Delta_perp</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">Delta</span><span class="p">,</span><span class="n">hatL</span><span class="p">))</span>
    <span class="n">chit</span><span class="o">=</span> <span class="p">(</span><span class="n">q</span><span class="o">*</span><span class="n">q</span><span class="o">*</span><span class="n">chi2</span><span class="o">*</span><span class="n">hatS2</span><span class="o">+</span><span class="n">chi1</span><span class="o">*</span><span class="n">hatS1</span><span class="p">)</span><span class="o">/</span><span class="nb">pow</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">,</span><span class="mf">2.</span><span class="p">)</span>
    <span class="n">chit_par</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">chit</span><span class="p">,</span><span class="n">hatL</span><span class="p">)</span>
    <span class="n">chit_perp</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">chit</span><span class="p">,</span><span class="n">hatL</span><span class="p">))</span>
    
    <span class="c">#Final mass. Barausse Morozova Rezzolla 2012</span>
    <span class="n">p0</span><span class="o">=</span><span class="mf">0.04827</span>
    <span class="n">p1</span><span class="o">=</span><span class="mf">0.01707</span>
    <span class="n">Z1</span><span class="o">=</span><span class="mf">1.</span><span class="o">+</span> <span class="nb">pow</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="nb">pow</span><span class="p">(</span><span class="n">chit_par</span><span class="p">,</span><span class="mf">2.</span><span class="p">),</span><span class="mf">1.</span><span class="o">/</span><span class="mf">3.</span><span class="p">)</span><span class="o">*</span> <span class="p">(</span><span class="nb">pow</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">chit_par</span><span class="p">,</span><span class="mf">1.</span><span class="o">/</span><span class="mf">3.</span><span class="p">)</span><span class="o">+</span><span class="nb">pow</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">chit_par</span><span class="p">,</span><span class="mf">1.</span><span class="o">/</span><span class="mf">3.</span><span class="p">))</span>
    <span class="n">Z2</span><span class="o">=</span><span class="nb">pow</span><span class="p">(</span><span class="mf">3.</span><span class="o">*</span><span class="nb">pow</span><span class="p">(</span><span class="n">chit_par</span><span class="p">,</span><span class="mf">2.</span><span class="p">)</span><span class="o">+</span><span class="nb">pow</span><span class="p">(</span><span class="n">Z1</span><span class="p">,</span><span class="mf">2.</span><span class="p">),</span><span class="mf">1.</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span>
    <span class="n">risco</span><span class="o">=</span><span class="mf">3.</span><span class="o">+</span><span class="n">Z2</span><span class="o">-</span><span class="n">math</span><span class="o">.</span><span class="n">copysign</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span><span class="n">chit_par</span><span class="p">)</span><span class="o">*</span><span class="nb">pow</span><span class="p">((</span><span class="mf">3.</span><span class="o">-</span><span class="n">Z1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mf">3.</span><span class="o">+</span><span class="n">Z1</span><span class="o">+</span><span class="mf">2.</span><span class="o">*</span><span class="n">Z2</span><span class="p">),</span><span class="mf">1.</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span>
    <span class="n">Eisco</span><span class="o">=</span><span class="nb">pow</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="mf">2.</span><span class="o">/</span><span class="p">(</span><span class="mf">3.</span><span class="o">*</span><span class="n">risco</span><span class="p">),</span><span class="mf">1.</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
    <span class="c">#Radiated energy, in unit of the initial total mass of the binary</span>
    <span class="n">Erad</span><span class="o">=</span> <span class="n">eta</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">Eisco</span><span class="p">)</span><span class="o">+</span><span class="mf">4.</span><span class="o">*</span><span class="nb">pow</span><span class="p">(</span><span class="n">eta</span><span class="p">,</span><span class="mf">2.</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mf">4.</span><span class="o">*</span><span class="n">p0</span><span class="o">+</span><span class="mf">16.</span><span class="o">*</span><span class="n">p1</span><span class="o">*</span><span class="n">chit_par</span><span class="o">*</span><span class="p">(</span><span class="n">chit_par</span><span class="o">+</span><span class="mf">1.</span><span class="p">)</span><span class="o">+</span><span class="n">Eisco</span><span class="o">-</span><span class="mf">1.</span><span class="p">)</span>
    <span class="n">Mfin</span><span class="o">=</span><span class="n">M</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span> <span class="n">Erad</span><span class="p">)</span> <span class="c"># Final mass</span>
        
    <span class="k">return</span> <span class="n">Mfin</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.finalspin">
    <p>def <span class="ident">finalspin</span>(</p><p>theta1, theta2, deltaPhi, q, S1, S2)</p>
    </div>
    

    
  
    <div class="desc"><p>Estimate the final mass of the BH renmant following a BH merger. We
implement the fitting formula to numerical relativity simulations by
Barausse Rezzolla 2009.  See also Gerosa and Sesana 2015. We return the
dimensionless spin, which is the spin in units of the (pre-merger) binary
total mass, not the spin in units of the actual BH remnant. This can be
obtained combing this function with <a href="#precession.finalmass"><code>finalmass</code></a>. Maximally
spinning BHs are returned if/whenever the fitting formula returns
dimensionless spins greater than 1. This formula has to be applied <em>close to
merger</em>, where numerical relativity simulations are available. You should do
a PN evolution to transfer binaries at r~10M.</p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>chifin=precession.finalspin(theta1,theta2,deltaPhi,q,S1,S2)
</pre></div>


<p><strong>Parameters:</strong></p>
<ul>
<li><code>theta1</code>: angle between the spin of the primary and the orbital angular momentum.</li>
<li><code>theta2</code>: angle between the spin of the secondary and the orbital angular momentum.</li>
<li><code>deltaphi</code>: angle between the projection of the two spins on the orbital plane.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>chifin</code>: dimensionless spin of the BH remnant</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.finalspin', this);">Show source &equiv;</a></p>
  <div id="source-precession.finalspin" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">finalspin</span><span class="p">(</span><span class="n">theta1</span><span class="p">,</span><span class="n">theta2</span><span class="p">,</span><span class="n">deltaPhi</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Estimate the final mass of the BH renmant following a BH merger. We</span>
<span class="sd">    implement the fitting formula to numerical relativity simulations by</span>
<span class="sd">    Barausse Rezzolla 2009.  See also Gerosa and Sesana 2015. We return the</span>
<span class="sd">    dimensionless spin, which is the spin in units of the (pre-merger) binary</span>
<span class="sd">    total mass, not the spin in units of the actual BH remnant. This can be</span>
<span class="sd">    obtained combing this function with `precession.finalmass`. Maximally</span>
<span class="sd">    spinning BHs are returned if/whenever the fitting formula returns</span>
<span class="sd">    dimensionless spins greater than 1. This formula has to be applied *close to</span>
<span class="sd">    merger*, where numerical relativity simulations are available. You should do</span>
<span class="sd">    a PN evolution to transfer binaries at r~10M.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        chifin=precession.finalspin(theta1,theta2,deltaPhi,q,S1,S2)</span>

<span class="sd">    **Parameters:**</span>

<span class="sd">    - `theta1`: angle between the spin of the primary and the orbital angular momentum.</span>
<span class="sd">    - `theta2`: angle between the spin of the secondary and the orbital angular momentum.</span>
<span class="sd">    - `deltaphi`: angle between the projection of the two spins on the orbital plane.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>

<span class="sd">    **Returns:**</span>
<span class="sd">    </span>
<span class="sd">    - `chifin`: dimensionless spin of the BH remnant</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="n">chi1</span><span class="o">=</span><span class="n">S1</span><span class="o">/</span><span class="p">(</span><span class="n">M</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span>   <span class="c"># Dimensionless spin</span>
    <span class="n">chi2</span><span class="o">=</span><span class="n">S2</span><span class="o">/</span><span class="p">(</span><span class="n">q</span><span class="o">*</span><span class="n">M</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span> <span class="c"># Dimensionless spin</span>
    <span class="n">eta</span><span class="o">=</span><span class="n">q</span><span class="o">*</span><span class="nb">pow</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">,</span><span class="o">-</span><span class="mf">2.</span><span class="p">)</span>     <span class="c"># Symmetric mass ratio</span>
    
    <span class="c"># Spins here are defined in a frame with L along z and S1 in xz</span>
    <span class="n">hatL</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">hatS1</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta1</span><span class="p">),</span><span class="mi">0</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta1</span><span class="p">)])</span>
    <span class="n">hatS2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta2</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">deltaPhi</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta2</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">deltaPhi</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta2</span><span class="p">)])</span>
    <span class="c">#Useful spin combinations. </span>
    <span class="n">Delta</span><span class="o">=</span> <span class="p">(</span><span class="n">q</span><span class="o">*</span><span class="n">chi2</span><span class="o">*</span><span class="n">hatS2</span><span class="o">-</span><span class="n">chi1</span><span class="o">*</span><span class="n">hatS1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span>
    <span class="n">Delta_par</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">Delta</span><span class="p">,</span><span class="n">hatL</span><span class="p">)</span>
    <span class="n">Delta_perp</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">Delta</span><span class="p">,</span><span class="n">hatL</span><span class="p">))</span>
    <span class="n">chit</span><span class="o">=</span> <span class="p">(</span><span class="n">q</span><span class="o">*</span><span class="n">q</span><span class="o">*</span><span class="n">chi2</span><span class="o">*</span><span class="n">hatS2</span><span class="o">+</span><span class="n">chi1</span><span class="o">*</span><span class="n">hatS1</span><span class="p">)</span><span class="o">/</span><span class="nb">pow</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">,</span><span class="mf">2.</span><span class="p">)</span>
    <span class="n">chit_par</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">chit</span><span class="p">,</span><span class="n">hatL</span><span class="p">)</span>
    <span class="n">chit_perp</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">chit</span><span class="p">,</span><span class="n">hatL</span><span class="p">))</span>
    
    <span class="c">#Final spin. Barausse Rezzolla 2009</span>
    <span class="n">t0</span><span class="o">=-</span><span class="mf">2.8904</span>
    <span class="n">t2</span><span class="o">=-</span><span class="mf">3.51712</span>
    <span class="n">t3</span><span class="o">=</span><span class="mf">2.5763</span>
    <span class="n">s4</span><span class="o">=-</span><span class="mf">0.1229</span>
    <span class="n">s5</span><span class="o">=</span><span class="mf">0.4537</span>
    <span class="n">smalll</span> <span class="o">=</span> <span class="mf">2.</span><span class="o">*</span><span class="nb">pow</span><span class="p">(</span><span class="mf">3.</span><span class="p">,</span><span class="mf">1.</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span> <span class="o">+</span> <span class="n">t2</span><span class="o">*</span><span class="n">eta</span><span class="o">+</span><span class="n">t3</span><span class="o">*</span><span class="nb">pow</span><span class="p">(</span><span class="n">eta</span><span class="p">,</span><span class="mf">2.</span><span class="p">)</span> <span class="o">+</span> <span class="n">s4</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">chit</span><span class="p">,</span><span class="n">chit</span><span class="p">)</span><span class="o">*</span><span class="nb">pow</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">,</span><span class="mf">4.</span><span class="p">)</span><span class="o">*</span><span class="nb">pow</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">q</span><span class="o">*</span><span class="n">q</span><span class="p">,</span><span class="o">-</span><span class="mf">2.</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">s5</span><span class="o">*</span><span class="n">eta</span><span class="o">+</span><span class="n">t0</span><span class="o">+</span><span class="mf">2.</span><span class="p">)</span><span class="o">*</span><span class="n">chit_par</span><span class="o">*</span><span class="nb">pow</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="nb">pow</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="o">*</span><span class="n">q</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">chifin</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span> <span class="n">chit</span><span class="o">+</span><span class="n">hatL</span><span class="o">*</span><span class="n">smalll</span><span class="o">*</span><span class="n">q</span><span class="o">/</span><span class="nb">pow</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">,</span><span class="mf">2.</span><span class="p">)</span> <span class="p">)</span>
    <span class="k">if</span> <span class="n">chifin</span><span class="o">&gt;</span><span class="mf">1.</span><span class="p">:</span> <span class="c">#Check on the final spin, as suggested by Emanuele</span>
        <span class="k">print</span> <span class="s">&quot;[finalspin] Warning: got chi&gt;1, force chi=1&quot;</span>
        <span class="n">chifin</span><span class="o">==</span><span class="mf">1.</span>
        
    <span class="k">return</span> <span class="n">chifin</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.find_morphology">
    <p>def <span class="ident">find_morphology</span>(</p><p>xi, J, q, S1, S2, r)</p>
    </div>
    

    
  
    <div class="desc"><p>Compute the precessional morphology in DeltaPhi. Returns:</p>
<ul>
<li>-1 if librating about DeltaPhi=0;</li>
<li>0 if circulating in the whole DeltaPhi range [-pi,pi];</li>
<li>+1 if librating about DeltaPhi=pi.</li>
</ul>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>morphology=precession.find_morphology(xi,J,q,S1,S2,r)
</pre></div>


<p><strong>Parameters:</strong></p>
<ul>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>J</code>: magnitude of the total angular momentum.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>r</code>: binary separation.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li>morphology: precessional morphology in DeltaPhi: -1 if librating about DeltaPhi=0; 0 if circulating; +1 if librating about DeltaPhi=pi.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.find_morphology', this);">Show source &equiv;</a></p>
  <div id="source-precession.find_morphology" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">find_morphology</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Compute the precessional morphology in DeltaPhi. Returns:</span>
<span class="sd">    </span>
<span class="sd">    - -1 if librating about DeltaPhi=0;</span>
<span class="sd">    - 0 if circulating in the whole DeltaPhi range [-pi,pi];</span>
<span class="sd">    - +1 if librating about DeltaPhi=pi.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        morphology=precession.find_morphology(xi,J,q,S1,S2,r)</span>

<span class="sd">    **Parameters:**</span>

<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `J`: magnitude of the total angular momentum.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `r`: binary separation.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - morphology: precessional morphology in DeltaPhi: -1 if librating about DeltaPhi=0; 0 if circulating; +1 if librating about DeltaPhi=pi.</span>
<span class="sd">    &#39;&#39;&#39;</span>
  
    <span class="k">if</span> <span class="n">q</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="c"># If q=1, the limits must be specified in cos(varphi)</span>
        <span class="n">Sb_min</span><span class="o">=-</span><span class="mi">1</span>
        <span class="n">Sb_max</span><span class="o">=</span><span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>    
        <span class="n">Sb_min</span><span class="p">,</span><span class="n">Sb_max</span><span class="o">=</span><span class="n">Sb_limits</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>      
    
    <span class="n">dummy</span><span class="p">,</span><span class="n">dummy</span><span class="p">,</span><span class="n">deltaphi_Sbmin</span><span class="p">,</span><span class="n">dummy</span> <span class="o">=</span> <span class="n">parametric_angles</span><span class="p">(</span><span class="n">Sb_min</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
    <span class="n">dummy</span><span class="p">,</span><span class="n">dummy</span><span class="p">,</span><span class="n">deltaphi_Sbmax</span><span class="p">,</span><span class="n">dummy</span> <span class="o">=</span> <span class="n">parametric_angles</span><span class="p">(</span><span class="n">Sb_max</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>

    <span class="c"># Both the initial and the final point in a precession cycle are &lt;pi/2. This is a libration about DeltaPhi=0</span>
    <span class="k">if</span> <span class="n">deltaphi_Sbmin</span><span class="o">&lt;</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">2.</span> <span class="ow">and</span> <span class="n">deltaphi_Sbmax</span><span class="o">&lt;</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">2.</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="mf">1.</span>
    <span class="c"># Both the initial and the final point in a precession cycle are &gt;pi/2. This is a libration about DeltaPhi=180</span>
    <span class="k">elif</span> <span class="n">deltaphi_Sbmin</span><span class="o">&gt;</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">2.</span> <span class="ow">and</span> <span class="n">deltaphi_Sbmax</span><span class="o">&gt;</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">2.</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">1.</span>
    <span class="c"># The precession orbit crosses both DeltaPhi=0 and DeltaPhi=180. This is  circulation</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">0.</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.from_the_angles">
    <p>def <span class="ident">from_the_angles</span>(</p><p>theta1, theta2, deltaphi, q, S1, S2, r)</p>
    </div>
    

    
  
    <div class="desc"><p>Convert a set of angles theta1,theta2,deltaphi into values of J,xi,S. This
function can be seen as the inverse of <a href="#precession.parametric_angles"><code>parametric_angles</code></a>. In
the equal-mass limit q=1, S doesn't parametrize the precessional motion; we
track the binary precession using varphi explicitly.</p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>xi,J,S=precession.from_the_angles(theta1,theta2,deltaphi,q,S1,S2,r)
</pre></div>


<p><strong>Parameters:</strong></p>
<ul>
<li><code>theta1</code>: angle between the spin of the primary and the orbital angular momentum.</li>
<li><code>theta2</code>: angle between the spin of the secondary and the orbital angular momentum.</li>
<li><code>deltaphi</code>: angle between the projection of the two spins on the orbital plane.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>r</code>: binary separation.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>J</code>: magnitude of the total angular momentum.</li>
<li><code>S</code>: magnitude of the total spin.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.from_the_angles', this);">Show source &equiv;</a></p>
  <div id="source-precession.from_the_angles" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">from_the_angles</span><span class="p">(</span><span class="n">theta1</span><span class="p">,</span><span class="n">theta2</span><span class="p">,</span><span class="n">deltaphi</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Convert a set of angles theta1,theta2,deltaphi into values of J,xi,S. This</span>
<span class="sd">    function can be seen as the inverse of `precession.parametric_angles`. In</span>
<span class="sd">    the equal-mass limit q=1, S doesn&#39;t parametrize the precessional motion; we</span>
<span class="sd">    track the binary precession using varphi explicitly.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        xi,J,S=precession.from_the_angles(theta1,theta2,deltaphi,q,S1,S2,r)</span>

<span class="sd">    **Parameters:**</span>

<span class="sd">    - `theta1`: angle between the spin of the primary and the orbital angular momentum.</span>
<span class="sd">    - `theta2`: angle between the spin of the secondary and the orbital angular momentum.</span>
<span class="sd">    - `deltaphi`: angle between the projection of the two spins on the orbital plane.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `r`: binary separation.</span>

<span class="sd">    **Returns:**</span>
<span class="sd">    </span>
<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `J`: magnitude of the total angular momentum.</span>
<span class="sd">    - `S`: magnitude of the total spin.   </span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">L</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
    
    <span class="k">global</span> <span class="n">flags_q1</span>
    <span class="k">if</span> <span class="n">q</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">flags_q1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="bp">False</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;[from_the_angles] Warning q=1: output here is cos(varphi), not S.&quot;</span>
            <span class="n">flags_q1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="bp">True</span> <span class="c"># Suppress future warnings</span>
        <span class="n">xi</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">/</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">S1</span> <span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta1</span><span class="p">)</span><span class="o">+</span><span class="n">S2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta2</span><span class="p">))</span>
        <span class="n">Ssq</span> <span class="o">=</span> <span class="n">S1</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">S2</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">S1</span><span class="o">*</span><span class="n">S2</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta1</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta2</span><span class="p">)</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta1</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta2</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">deltaphi</span><span class="p">))</span>
        <span class="n">J</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Ssq</span><span class="o">+</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">xi</span><span class="o">*</span><span class="n">L</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">t6</span><span class="o">=</span><span class="p">((</span><span class="n">S1</span><span class="o">+</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">Ssq</span><span class="p">)</span>
        <span class="n">t7</span><span class="o">=</span><span class="p">(</span><span class="n">Ssq</span><span class="o">-</span><span class="p">(</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>        
        <span class="n">B</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">Ssq</span><span class="o">-</span><span class="n">xi</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">4</span><span class="p">)</span><span class="o">*</span><span class="n">t6</span><span class="o">*</span><span class="n">t7</span>
        <span class="n">cosvarphi</span><span class="o">=</span> <span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">S1</span><span class="o">*</span><span class="n">Ssq</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta1</span><span class="p">)</span><span class="o">-</span><span class="n">xi</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">Ssq</span><span class="o">+</span><span class="n">S1</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S2</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">B</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">cosvarphi</span> <span class="c"># The output variable is actually cos(varphi)</span>
    
    <span class="k">else</span><span class="p">:</span>
        <span class="n">xi</span><span class="o">=</span> <span class="p">((</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">S1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta1</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="o">**-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">S2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta2</span><span class="p">))</span><span class="o">*</span><span class="n">M</span><span class="o">**-</span><span class="mi">2</span>
        <span class="n">S</span><span class="o">=</span> <span class="p">(</span><span class="n">S1</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">S2</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="mf">2.</span><span class="o">*</span><span class="n">S1</span><span class="o">*</span><span class="n">S2</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta1</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta2</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">deltaphi</span><span class="p">)</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta1</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta2</span><span class="p">)))</span><span class="o">**.</span><span class="mi">5</span>
        <span class="n">J</span><span class="o">=</span> <span class="p">(</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="mf">2.</span><span class="o">*</span><span class="n">L</span><span class="o">*</span><span class="p">(</span><span class="n">S1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta1</span><span class="p">)</span><span class="o">+</span><span class="n">S2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta2</span><span class="p">)))</span><span class="o">**.</span><span class="mi">5</span>
        <span class="k">return</span> <span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">S</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.from_the_angles_inf">
    <p>def <span class="ident">from_the_angles_inf</span>(</p><p>theta1_inf, theta2_inf, q, S1, S2)</p>
    </div>
    

    
  
    <div class="desc"><p>Find xi and kappa_inf given the asymptotic (constant) values of theta1 and
theta2.</p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>xi,kappa_inf=precession.from_the_angles_inf(theta1_inf,theta2_inf,q,S1,S2)
</pre></div>


<p><strong>Parameters:</strong></p>
<ul>
<li><code>theta1_inf</code>: asymptotic value of theta1 at large separations.</li>
<li><code>theta2_inf</code>: asymptotic value of theta2 at large separations.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>kappa_inf</code>: asymptotic value of kappa at large separations.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.from_the_angles_inf', this);">Show source &equiv;</a></p>
  <div id="source-precession.from_the_angles_inf" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">from_the_angles_inf</span><span class="p">(</span><span class="n">theta1_inf</span><span class="p">,</span><span class="n">theta2_inf</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">):</span>
    
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Find xi and kappa_inf given the asymptotic (constant) values of theta1 and</span>
<span class="sd">    theta2.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        xi,kappa_inf=precession.from_the_angles_inf(theta1_inf,theta2_inf,q,S1,S2)</span>
<span class="sd">    </span>
<span class="sd">    **Parameters:**</span>

<span class="sd">    - `theta1_inf`: asymptotic value of theta1 at large separations.</span>
<span class="sd">    - `theta2_inf`: asymptotic value of theta2 at large separations.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    </span>
<span class="sd">    **Returns:**</span>

<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `kappa_inf`: asymptotic value of kappa at large separations.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="k">if</span> <span class="n">q</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">assert</span> <span class="bp">False</span><span class="p">,</span> <span class="s">&quot;[from_the_angles_inf] Error: I&#39;m sorry, can&#39;t run for q=1. The angles theta1 and theta2 are not constant at large separations.&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">xi</span><span class="o">=</span> <span class="p">((</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">S1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta1_inf</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="o">**-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">S2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta2_inf</span><span class="p">))</span><span class="o">*</span><span class="n">M</span><span class="o">**-</span><span class="mi">2</span>
        <span class="n">kappa_inf</span><span class="o">=</span> <span class="p">(</span><span class="n">S1</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta1_inf</span><span class="p">)</span><span class="o">+</span><span class="n">S2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta2_inf</span><span class="p">))</span><span class="o">*</span><span class="n">M</span><span class="o">**-</span><span class="mi">2</span>
        <span class="k">return</span> <span class="n">xi</span><span class="p">,</span><span class="n">kappa_inf</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.ftor">
    <p>def <span class="ident">ftor</span>(</p><p>f, M_msun)</p>
    </div>
    

    
  
    <div class="desc"><p>Conversion between binary separation r (in mass unit) and emitted GW
frequency f (in Hertz). We use the Newtonian expression: f^2 = G M / (pi^2
r^3) in cgs units. Mass units: r--&gt; GMr/c^2</p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>r=precession.ftor(f,M_msun)
</pre></div>


<p><strong>Parameters:</strong></p>
<ul>
<li><code>f</code>: emitted GW frequency in Hertz.</li>
<li><code>M_msun</code>: binary total mass in solar masses.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>r</code>: binary separation.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.ftor', this);">Show source &equiv;</a></p>
  <div id="source-precession.ftor" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">ftor</span><span class="p">(</span><span class="n">f</span><span class="p">,</span><span class="n">M_msun</span><span class="p">):</span>
    
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Conversion between binary separation r (in mass unit) and emitted GW</span>
<span class="sd">    frequency f (in Hertz). We use the Newtonian expression: f^2 = G M / (pi^2</span>
<span class="sd">    r^3) in cgs units. Mass units: r--&gt; GMr/c^2</span>

<span class="sd">    **Call:**</span>

<span class="sd">        r=precession.ftor(f,M_msun)</span>

<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `f`: emitted GW frequency in Hertz.</span>
<span class="sd">    - `M_msun`: binary total mass in solar masses.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `r`: binary separation.</span>
<span class="sd">    &#39;&#39;&#39;</span>

 
    
    <span class="n">M_cgs</span><span class="o">=</span><span class="n">M_msun</span><span class="o">*</span><span class="p">(</span><span class="mf">2e33</span><span class="p">)</span>
    <span class="n">c_cgs</span><span class="o">=</span><span class="mf">2.99e10</span>
    <span class="n">G_cgs</span><span class="o">=</span><span class="mf">6.67e-8</span>
    <span class="n">r</span><span class="o">=</span><span class="nb">pow</span><span class="p">(</span><span class="nb">pow</span><span class="p">(</span><span class="n">c_cgs</span><span class="p">,</span><span class="mf">3.</span><span class="p">),</span><span class="mf">2.</span><span class="o">/</span><span class="mf">3.</span><span class="p">)</span><span class="o">*</span><span class="nb">pow</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">f</span><span class="o">*</span><span class="n">G_cgs</span><span class="o">*</span><span class="n">M_cgs</span><span class="p">,</span><span class="o">-</span><span class="mf">2.</span><span class="o">/</span><span class="mf">3.</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">r</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.get_L">
    <p>def <span class="ident">get_L</span>(</p><p>r, q)</p>
    </div>
    

    
  
    <div class="desc"><p>Return Newtonian expression for the orbital angular momentum. This function is not called explicitely within the precession module to increase efficiency.</p></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.get_L', this);">Show source &equiv;</a></p>
  <div id="source-precession.get_L" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">get_L</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">q</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Return Newtonian expression for the orbital angular momentum. This function is not called explicitely within the precession module to increase efficiency.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="n">L</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>    
    <span class="k">return</span> <span class="n">L</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.get_fixed">
    <p>def <span class="ident">get_fixed</span>(</p><p>q, chi1, chi2)</p>
    </div>
    

    
  
    <div class="desc"><p>Compute individual masses and spins, from mass ratio (q&lt;1) and
dimensionless spins (0&lt;chi&lt;1).</p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>M,m1,m2,S1,S2=precession.get_fixed(q,chi1,chi2)
</pre></div>


<p><strong>Parameters:</strong></p>
<ul>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>chi1</code>: dimensionless spin magnitude of the primary BH. Must be 0&lt;chi1&lt;1.</li>
<li><code>chi2</code>: dimensionless spin magnitude of the secondary BH. Must be 0&lt;chi2&lt;1.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>M</code>: total mass of the binary (set to 1).</li>
<li><code>m1</code>: mass of the primary BH.</li>
<li><code>m2</code>: mass of the secondary BH.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.get_fixed', this);">Show source &equiv;</a></p>
  <div id="source-precession.get_fixed" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">get_fixed</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">chi1</span><span class="p">,</span><span class="n">chi2</span><span class="p">):</span>
    
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Compute individual masses and spins, from mass ratio (q&lt;1) and</span>
<span class="sd">    dimensionless spins (0&lt;chi&lt;1).</span>

<span class="sd">    **Call:**</span>

<span class="sd">        M,m1,m2,S1,S2=precession.get_fixed(q,chi1,chi2)</span>
<span class="sd">    </span>
<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `chi1`: dimensionless spin magnitude of the primary BH. Must be 0&lt;chi1&lt;1.</span>
<span class="sd">    - `chi2`: dimensionless spin magnitude of the secondary BH. Must be 0&lt;chi2&lt;1.</span>

<span class="sd">    **Returns:**</span>
<span class="sd">    </span>
<span class="sd">    - `M`: total mass of the binary (set to 1).</span>
<span class="sd">    - `m1`: mass of the primary BH.</span>
<span class="sd">    - `m2`: mass of the secondary BH.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="k">global</span> <span class="n">M</span>
    <span class="n">m1</span><span class="o">=</span><span class="n">M</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span> <span class="c"># Primary mass</span>
    <span class="n">m2</span><span class="o">=</span><span class="n">q</span><span class="o">*</span><span class="n">M</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span> <span class="c"># Secondary mass</span>
    <span class="n">S1</span><span class="o">=</span><span class="n">chi1</span><span class="o">*</span><span class="n">m1</span><span class="o">**</span><span class="mi">2</span> <span class="c"># Primary spin magnitude</span>
    <span class="n">S2</span><span class="o">=</span><span class="n">chi2</span><span class="o">*</span><span class="n">m2</span><span class="o">**</span><span class="mi">2</span> <span class="c"># Secondary spin magnitude</span>
    <span class="k">return</span> <span class="n">M</span><span class="p">,</span><span class="n">m1</span><span class="p">,</span><span class="n">m2</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.get_varphi">
    <p>def <span class="ident">get_varphi</span>(</p><p>xi, S, J, q, S1, S2, r, sign=1)</p>
    </div>
    

    
  
    <div class="desc"><p>Compute varphi from a given xi. This can be seen as the inverse of
xi_contour. If phase==1 (default) return varphi in [0,pi], if sign==-1
return varphi in [-pi,0].</p>
<p>WARKNING: Don't run for q=1, as varphi is independent of S in this limit.</p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>varphi=precession.get_varphi(xi,S,J,q,S1,S2,r,sign=1)
</pre></div>


<p><strong>Parameters:</strong></p>
<ul>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>S</code>: magnitude of the total spin.</li>
<li><code>J</code>: magnitude of the total angular momentum.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>r</code>: binary separation.</li>
<li><code>sign</code>: if 1 return angle in [0,pi], if -1 return angle in [-pi,0].</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>varphi</code>: angle describing the rotation of S1 and S2 about S, in a frame aligned with J.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.get_varphi', this);">Show source &equiv;</a></p>
  <div id="source-precession.get_varphi" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">get_varphi</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">sign</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Compute varphi from a given xi. This can be seen as the inverse of</span>
<span class="sd">    xi_contour. If phase==1 (default) return varphi in [0,pi], if sign==-1</span>
<span class="sd">    return varphi in [-pi,0].</span>

<span class="sd">    WARKNING: Don&#39;t run for q=1, as varphi is independent of S in this limit.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        varphi=precession.get_varphi(xi,S,J,q,S1,S2,r,sign=1)</span>
<span class="sd">    </span>
<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `S`: magnitude of the total spin.</span>
<span class="sd">    - `J`: magnitude of the total angular momentum.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `r`: binary separation.</span>
<span class="sd">    - `sign`: if 1 return angle in [0,pi], if -1 return angle in [-pi,0].</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `varphi`: angle describing the rotation of S1 and S2 about S, in a frame aligned with J.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="n">q</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">assert</span> <span class="bp">False</span><span class="p">,</span> <span class="s">&quot;[get_varphi] Error: I&#39;m sorry, can&#39;t run for q=1. S is degenerate with varphi.&quot;</span>

    <span class="n">L</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
    <span class="n">t1</span><span class="o">=</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">4.</span><span class="o">*</span><span class="n">q</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">L</span><span class="p">)</span>
    <span class="n">t2</span><span class="o">=</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">t3</span><span class="o">=</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">-</span><span class="p">(</span><span class="n">S1</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">q</span><span class="p">)</span>
    <span class="n">t4</span><span class="o">=</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="p">((</span><span class="n">L</span><span class="o">+</span><span class="n">S</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
    <span class="n">t5</span><span class="o">=</span><span class="p">(</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="n">S</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>             
    <span class="n">t6</span><span class="o">=</span><span class="p">((</span><span class="n">S1</span><span class="o">+</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
    <span class="n">t7</span><span class="o">=</span><span class="p">(</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
    <span class="n">cosvarphi</span><span class="o">=</span> <span class="p">((</span><span class="n">t2</span><span class="o">*</span><span class="n">t3</span><span class="p">)</span><span class="o">-</span><span class="p">(</span><span class="n">xi</span><span class="o">/</span><span class="n">t1</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="n">t4</span><span class="o">*</span><span class="n">t5</span><span class="o">*</span><span class="n">t6</span><span class="o">*</span><span class="n">t7</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">cosvarphi</span><span class="p">)</span><span class="o">*</span><span class="n">sign</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.hybrid">
    <p>def <span class="ident">hybrid</span>(</p><p>xi_vals, kappainf_vals, r_vals, q_vals, S1_vals, S2_vals, r_t)</p>
    </div>
    

    
  
    <div class="desc"><p>Hybrid inspiral. Evolve a binary FROM INIFINITELY large separations (as
specified by kappa_inf and xi) till the threshold r_t using the
precession-averaged approach, and then from r_t to the end of the inspiral
using an orbit-averaged integration to track the precessional phase.</p>
<p>Parallelization is implemented through the python parmap module; the number
of available cores can be specified using the integer global variable
<code>precession.CPUs</code> (all available cores will be used by default). Evolve a
sequence of binaries with the different q, S1,S2, xi and kappa_inf. Save
outputs at SAME separations r_vals; r_t must also be the same for all
binaries</p>
<p>The initial condition is NOT returned by this function. Outputs are given in
terms of the angles theta1, theta2 and deltaphi as 2D arrays, where e.g
theta1_fvals[0] is the first binary (1D array at all output separations) and
theta1_fvals[0][0] is the first binary at the first output separation (this
is a scalar).</p>
<p><strong>Call:</strong>
    theta1f_vals,theta2f_vals,deltaphif_vals=precession.hybrid(xi_vals,kappainf_vals,r_vals,q_vals,S1_vals,S2_vals,r_t)</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>xi_vals</code>: projection of the effective spin along the orbital angular momentum (array).</li>
<li><code>kappainf_vals</code>: asymtotic value of kappa at large separations (array).</li>
<li><code>r_vals</code>: binary separation (array).</li>
<li><code>q_vals</code>: binary mass ratio. Must be q&lt;=1 (array).</li>
<li><code>S1_vals</code>: spin magnitude of the primary BH (array).</li>
<li><code>S2_vals</code>: spin magnitude of the secondary BH (array).</li>
<li><code>r_t</code>: transition radius between orbit- and precession-averaged approach.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>theta1f_vals</code>: solutions for theta1 (2D array).</li>
<li><code>theta2f_vals</code>: solutions for theta2 (2D array).</li>
<li><code>deltaphif_vals</code>: solutions for deltaphi (2D array).</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.hybrid', this);">Show source &equiv;</a></p>
  <div id="source-precession.hybrid" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">hybrid</span><span class="p">(</span><span class="n">xi_vals</span><span class="p">,</span><span class="n">kappainf_vals</span><span class="p">,</span><span class="n">r_vals</span><span class="p">,</span><span class="n">q_vals</span><span class="p">,</span><span class="n">S1_vals</span><span class="p">,</span><span class="n">S2_vals</span><span class="p">,</span><span class="n">r_t</span><span class="p">):</span>
 
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Hybrid inspiral. Evolve a binary FROM INIFINITELY large separations (as</span>
<span class="sd">    specified by kappa_inf and xi) till the threshold r_t using the</span>
<span class="sd">    precession-averaged approach, and then from r_t to the end of the inspiral</span>
<span class="sd">    using an orbit-averaged integration to track the precessional phase.</span>

<span class="sd">    Parallelization is implemented through the python parmap module; the number</span>
<span class="sd">    of available cores can be specified using the integer global variable</span>
<span class="sd">    `precession.CPUs` (all available cores will be used by default). Evolve a</span>
<span class="sd">    sequence of binaries with the different q, S1,S2, xi and kappa_inf. Save</span>
<span class="sd">    outputs at SAME separations r_vals; r_t must also be the same for all</span>
<span class="sd">    binaries</span>

<span class="sd">    The initial condition is NOT returned by this function. Outputs are given in</span>
<span class="sd">    terms of the angles theta1, theta2 and deltaphi as 2D arrays, where e.g</span>
<span class="sd">    theta1_fvals[0] is the first binary (1D array at all output separations) and</span>
<span class="sd">    theta1_fvals[0][0] is the first binary at the first output separation (this</span>
<span class="sd">    is a scalar).</span>

<span class="sd">    **Call:**</span>
<span class="sd">        theta1f_vals,theta2f_vals,deltaphif_vals=precession.hybrid(xi_vals,kappainf_vals,r_vals,q_vals,S1_vals,S2_vals,r_t)</span>

<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `xi_vals`: projection of the effective spin along the orbital angular momentum (array).</span>
<span class="sd">    - `kappainf_vals`: asymtotic value of kappa at large separations (array).</span>
<span class="sd">    - `r_vals`: binary separation (array).</span>
<span class="sd">    - `q_vals`: binary mass ratio. Must be q&lt;=1 (array).</span>
<span class="sd">    - `S1_vals`: spin magnitude of the primary BH (array).</span>
<span class="sd">    - `S2_vals`: spin magnitude of the secondary BH (array).</span>
<span class="sd">    - `r_t`: transition radius between orbit- and precession-averaged approach.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `theta1f_vals`: solutions for theta1 (2D array).</span>
<span class="sd">    - `theta2f_vals`: solutions for theta2 (2D array).</span>
<span class="sd">    - `deltaphif_vals`: solutions for deltaphi (2D array).</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">global</span> <span class="n">CPUs</span>

    <span class="n">single_flag</span><span class="o">=</span><span class="bp">False</span>

    <span class="k">try</span><span class="p">:</span> <span class="c">#Convert float to array if you&#39;re evolving just one binary </span>
        <span class="nb">len</span><span class="p">(</span><span class="n">q_vals</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">single_flag</span><span class="o">=</span><span class="bp">True</span>
        <span class="n">xi_vals</span><span class="o">=</span><span class="p">[</span><span class="n">xi_vals</span><span class="p">]</span>
        <span class="n">kappainf_vals</span><span class="o">=</span><span class="p">[</span><span class="n">kappainf_vals</span><span class="p">]</span>
        <span class="n">q_vals</span><span class="o">=</span><span class="p">[</span><span class="n">q_vals</span><span class="p">]</span>
        <span class="n">S1_vals</span><span class="o">=</span><span class="p">[</span><span class="n">S1_vals</span><span class="p">]</span>
        <span class="n">S2_vals</span><span class="o">=</span><span class="p">[</span><span class="n">S2_vals</span><span class="p">]</span>
    <span class="k">try</span><span class="p">:</span> <span class="c"># Set defaults</span>
        <span class="n">CPUs</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">CPUs</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">print</span> <span class="s">&quot;[hybrid] Default parallel computation&quot;</span>

    <span class="n">loopflag</span><span class="o">=</span><span class="bp">True</span>
    <span class="k">while</span> <span class="n">loopflag</span><span class="p">:</span> <span class="c"># Restart is some of the cores crashed. This happend if you run too many things on too many different machines. Nevermind, trash the file and do it again. </span>
        <span class="n">loopflag</span><span class="o">=</span><span class="bp">False</span> 

        <span class="c">#Parallelization</span>
        <span class="k">if</span> <span class="n">CPUs</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="c">#Run on all cpus on the current machine! (default option) </span>
            <span class="n">filelist</span><span class="o">=</span><span class="n">parmap</span><span class="o">.</span><span class="n">starmap</span><span class="p">(</span><span class="n">hybrid_single</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xi_vals</span><span class="p">,</span><span class="n">kappainf_vals</span><span class="p">,[</span><span class="n">r_vals</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q_vals</span><span class="p">))],</span><span class="n">q_vals</span><span class="p">,</span><span class="n">S1_vals</span><span class="p">,</span><span class="n">S2_vals</span><span class="p">,[</span><span class="n">r_t</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q_vals</span><span class="p">))]),</span><span class="n">parallel</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">CPUs</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="c">#1 cpus done by explicitely removing parallelization </span>
            <span class="n">filelist</span><span class="o">=</span><span class="n">parmap</span><span class="o">.</span><span class="n">starmap</span><span class="p">(</span><span class="n">hybrid_single</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xi_vals</span><span class="p">,</span><span class="n">kappainf_vals</span><span class="p">,[</span><span class="n">r_vals</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q_vals</span><span class="p">))],</span><span class="n">q_vals</span><span class="p">,</span><span class="n">S1_vals</span><span class="p">,</span><span class="n">S2_vals</span><span class="p">,[</span><span class="n">r_t</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q_vals</span><span class="p">))]),</span><span class="n">parallel</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span> <span class="c"># Run on a given number of CPUs</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">CPUs</span><span class="p">)</span>
            <span class="n">filelist</span><span class="o">=</span><span class="n">parmap</span><span class="o">.</span><span class="n">starmap</span><span class="p">(</span><span class="n">hybrid_single</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xi_vals</span><span class="p">,</span><span class="n">kappainf_vals</span><span class="p">,[</span><span class="n">r_vals</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q_vals</span><span class="p">))],</span><span class="n">q_vals</span><span class="p">,</span><span class="n">S1_vals</span><span class="p">,</span><span class="n">S2_vals</span><span class="p">,[</span><span class="n">r_t</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q_vals</span><span class="p">))]),</span><span class="n">pool</span><span class="o">=</span><span class="n">p</span><span class="p">)</span>

        <span class="n">theta1_fvals</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">theta2_fvals</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">deltaphi_fvals</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="nb">file</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">filelist</span><span class="p">):</span>
            <span class="k">print</span> <span class="s">&quot;[hybrid] Reading:&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="nb">file</span>
            <span class="n">numlines</span><span class="o">=</span><span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">open</span><span class="p">(</span><span class="nb">file</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">numlines</span><span class="o">!=</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">numlines</span><span class="o">!=</span><span class="nb">len</span><span class="p">(</span><span class="n">r_vals</span><span class="p">):</span> <span class="c"># Restart if core(s) crashed </span>
                <span class="k">print</span> <span class="s">&quot;[hybrid] Error on file&quot;</span><span class="p">,</span> <span class="nb">file</span><span class="p">,</span><span class="s">&quot;. Jobs are being restarted!&quot;</span>
                <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s">&quot;rm &quot;</span><span class="o">+</span><span class="nb">file</span><span class="p">)</span>
                <span class="n">loopflag</span><span class="o">=</span><span class="bp">True</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">dummy</span><span class="p">,</span><span class="n">theta1_f</span><span class="p">,</span><span class="n">theta2_f</span><span class="p">,</span><span class="n">deltaphi_f</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="nb">file</span><span class="p">,</span><span class="n">unpack</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                <span class="n">theta1_fvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">theta1_f</span><span class="p">)</span>
                <span class="n">theta2_fvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">theta2_f</span><span class="p">)</span>
                <span class="n">deltaphi_fvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">deltaphi_f</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">single_flag</span><span class="o">==</span><span class="bp">True</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">theta1_fvals</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">theta2_fvals</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">deltaphi_fvals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">theta1_fvals</span><span class="p">,</span> <span class="n">theta2_fvals</span><span class="p">,</span> <span class="n">deltaphi_fvals</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.hybrid_single">
    <p>def <span class="ident">hybrid_single</span>(</p><p>xi, kappa_inf, r_vals, q, S1, S2, r_t)</p>
    </div>
    

    
  
    <div class="desc"><p>Auxiliary function, see <code>hybrid</code>.</p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>savename=precession.hybrid_single(xi,kappa_inf,r_vals,q,S1,S2,r_t)
</pre></div>


<p><strong>Parameters:</strong></p>
<ul>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>kappa_inf</code>: asymtotic value of kappa at large separations.</li>
<li><code>r_vals</code>: binary separation (array).</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>r_t</code>: transition radius between orbit- and precession-averaged approach.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>savename</code>: checkpoint filename.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.hybrid_single', this);">Show source &equiv;</a></p>
  <div id="source-precession.hybrid_single" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">hybrid_single</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">kappa_inf</span><span class="p">,</span><span class="n">r_vals</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r_t</span><span class="p">):</span>
    
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Auxiliary function, see `hybrid`.</span>
<span class="sd"> </span>
<span class="sd">    **Call:**</span>

<span class="sd">        savename=precession.hybrid_single(xi,kappa_inf,r_vals,q,S1,S2,r_t)</span>

<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `kappa_inf`: asymtotic value of kappa at large separations.</span>
<span class="sd">    - `r_vals`: binary separation (array).</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `r_t`: transition radius between orbit- and precession-averaged approach.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `savename`: checkpoint filename.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">global</span> <span class="n">flags_q1</span>
    <span class="k">if</span> <span class="n">q</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">flags_q1</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span><span class="o">==</span><span class="bp">False</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;[hybrid] Warning q=1: required intial condition is S, not kappa_inf.&quot;</span>
            <span class="n">flags_q1</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span><span class="o">=</span><span class="bp">True</span> <span class="c"># Suppress future warnings</span>

    <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s">&quot;mkdir -p &quot;</span><span class="o">+</span><span class="n">storedir</span><span class="p">)</span> 
    <span class="n">savename</span><span class="o">=</span> <span class="n">storedir</span><span class="o">+</span><span class="s">&quot;/hybrid_&quot;</span><span class="o">+</span><span class="s">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">kappa_inf</span><span class="p">,</span><span class="nb">max</span><span class="p">(</span><span class="n">r_vals</span><span class="p">),</span><span class="nb">min</span><span class="p">(</span><span class="n">r_vals</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">r_vals</span><span class="p">),</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r_t</span><span class="p">)])</span><span class="o">+</span><span class="s">&quot;.dat&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">savename</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">&quot;[hybrid] Transferring binary. Output:&quot;</span><span class="p">,</span> <span class="n">savename</span>
        <span class="n">outfilesave</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">savename</span><span class="p">,</span><span class="s">&quot;w&quot;</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>

        <span class="c"># Split the output separations: precession-average before r_t and orbit-average after it         </span>
        <span class="n">r_vals_pa</span><span class="o">=</span><span class="p">[</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">r_vals</span> <span class="k">if</span> <span class="n">r</span><span class="o">&gt;</span><span class="n">r_t</span><span class="p">]</span>
        <span class="n">r_vals_oa</span><span class="o">=</span><span class="p">[</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">r_vals</span> <span class="k">if</span> <span class="n">r</span><span class="o">&lt;=</span><span class="n">r_t</span><span class="p">]</span> <span class="c"># Keep r_t (if present) in the orbit-average part</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">[</span><span class="n">r</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">r_vals_oa</span> <span class="k">if</span> <span class="n">r</span><span class="o">!=</span><span class="n">r_t</span><span class="p">]:</span> <span class="c"># If there&#39;s nothing but r_t in the orbit-averaged part</span>
            <span class="k">assert</span> <span class="bp">False</span><span class="p">,</span> <span class="s">&quot;[hybrid] No output required below r_t. You don&#39;t need a hybrid integration, use evolve_J_infinity instead&quot;</span>

        <span class="c"># Add the threshold at the end of the precession-average part and at the beginning of the orbit-average part</span>
        <span class="n">r_vals_pa</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r_t</span><span class="p">)</span>
        <span class="n">r_vals_oa</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">r_t</span><span class="p">)</span>  

        <span class="c"># Evolve from r=infinity to r=r_t using precession-averaged integration</span>
        <span class="n">J_vals_pa</span><span class="o">=</span><span class="n">Jofr_infinity</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">kappa_inf</span><span class="p">,</span><span class="n">r_vals_pa</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">)</span>

        <span class="c"># Store the angles theta1, theta2 and deltaphi (need S resampling at each output separation)</span>
        <span class="c"># Don&#39;t use the latest values in the arrays, because you added one value at the end earlier on</span>
        <span class="k">for</span> <span class="n">J_f</span><span class="p">,</span><span class="n">r_f</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">J_vals_pa</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">r_vals_pa</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>           
          
            <span class="n">S_f</span><span class="o">=</span><span class="n">samplingS</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">J_f</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r_f</span><span class="p">)</span>
            <span class="n">theta1_f</span><span class="p">,</span><span class="n">theta2_f</span><span class="p">,</span><span class="n">deltaphi_f</span><span class="p">,</span><span class="n">dummy</span> <span class="o">=</span> <span class="n">parametric_angles</span><span class="p">(</span><span class="n">S_f</span><span class="p">,</span><span class="n">J_f</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r_f</span><span class="p">)</span>
            <span class="n">deltaphi_f</span><span class="o">*=</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">([</span><span class="o">-</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">1.</span><span class="p">])</span>
            <span class="n">outfilesave</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">r_f</span><span class="p">)</span><span class="o">+</span><span class="s">&quot; &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">theta1_f</span><span class="p">)</span><span class="o">+</span><span class="s">&quot; &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">theta2_f</span><span class="p">)</span><span class="o">+</span><span class="s">&quot; &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">deltaphi_f</span><span class="p">)</span><span class="o">+</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>        

        <span class="c"># Last S resampling at r=r_t</span>
        <span class="n">S_t</span><span class="o">=</span><span class="n">samplingS</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">J_vals_pa</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r_t</span><span class="p">)</span>
        
        <span class="c"># Evolve from r_t to min(r_vals) using orbit-average integration</span>
        <span class="n">Lhx_vals_oa</span><span class="p">,</span><span class="n">Lhy_vals_oa</span><span class="p">,</span><span class="n">Lhz_vals_oa</span><span class="p">,</span><span class="n">S1hx_vals_oa</span><span class="p">,</span><span class="n">S1hy_vals_oa</span><span class="p">,</span><span class="n">S1hz_vals_oa</span><span class="p">,</span><span class="n">S2hx_vals_oa</span><span class="p">,</span><span class="n">S2hy_vals_oa</span><span class="p">,</span><span class="n">S2hz_vals_oa</span> <span class="o">=</span> <span class="n">orbav_integrator</span><span class="p">(</span><span class="n">J_vals_pa</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">xi</span><span class="p">,</span><span class="n">S_t</span><span class="p">,</span><span class="n">r_vals_oa</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">)</span>

        <span class="c"># Store the angles theta1, theta2 and deltaphi (S resampling not needed)</span>
        <span class="c"># Don&#39;t use the first values in the arrays, because you added one value on top earlier on</span>
        <span class="k">for</span> <span class="n">r_f</span><span class="p">,</span><span class="n">Lhx</span><span class="p">,</span><span class="n">Lhy</span><span class="p">,</span><span class="n">Lhz</span><span class="p">,</span><span class="n">S1hx</span><span class="p">,</span><span class="n">S1hy</span><span class="p">,</span><span class="n">S1hz</span><span class="p">,</span><span class="n">S2hx</span><span class="p">,</span><span class="n">S2hy</span><span class="p">,</span><span class="n">S2hz</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">r_vals_oa</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span><span class="n">Lhx_vals_oa</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span><span class="n">Lhy_vals_oa</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span><span class="n">Lhz_vals_oa</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span><span class="n">S1hx_vals_oa</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span><span class="n">S1hy_vals_oa</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span><span class="n">S1hz_vals_oa</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span><span class="n">S2hx_vals_oa</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span><span class="n">S2hy_vals_oa</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span><span class="n">S2hz_vals_oa</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
            <span class="n">L_f</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r_f</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
            <span class="n">S_f</span><span class="o">=</span><span class="p">((</span><span class="n">S1</span><span class="o">*</span><span class="n">S1hx</span><span class="o">+</span><span class="n">S2</span><span class="o">*</span><span class="n">S2hx</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">S1</span><span class="o">*</span><span class="n">S1hy</span><span class="o">+</span><span class="n">S2</span><span class="o">*</span><span class="n">S2hy</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">S1</span><span class="o">*</span><span class="n">S1hz</span><span class="o">+</span><span class="n">S2</span><span class="o">*</span><span class="n">S2hz</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="p">)</span><span class="o">**</span><span class="mf">0.5</span>
            <span class="n">J_f</span><span class="o">=</span><span class="p">((</span><span class="n">L_f</span><span class="o">*</span><span class="n">Lhx</span><span class="o">+</span><span class="n">S1</span><span class="o">*</span><span class="n">S1hx</span><span class="o">+</span><span class="n">S2</span><span class="o">*</span><span class="n">S2hx</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">L_f</span><span class="o">*</span><span class="n">Lhy</span><span class="o">+</span><span class="n">S1</span><span class="o">*</span><span class="n">S1hy</span><span class="o">+</span><span class="n">S2</span><span class="o">*</span><span class="n">S2hy</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">L_f</span><span class="o">*</span><span class="n">Lhz</span><span class="o">+</span><span class="n">S1</span><span class="o">*</span><span class="n">S1hz</span><span class="o">+</span><span class="n">S2</span><span class="o">*</span><span class="n">S2hz</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="p">)</span><span class="o">**</span><span class="mf">0.5</span>
            <span class="n">xi_f</span><span class="o">=</span><span class="p">((</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">S1</span><span class="o">*</span><span class="p">(</span><span class="n">Lhx</span><span class="o">*</span><span class="n">S1hx</span><span class="o">+</span><span class="n">Lhy</span><span class="o">*</span><span class="n">S1hy</span><span class="o">+</span><span class="n">Lhz</span><span class="o">*</span><span class="n">S1hz</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="o">**-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">S2</span><span class="o">*</span><span class="p">(</span><span class="n">Lhx</span><span class="o">*</span><span class="n">S2hx</span><span class="o">+</span><span class="n">Lhy</span><span class="o">*</span><span class="n">S2hy</span><span class="o">+</span><span class="n">Lhz</span><span class="o">*</span><span class="n">S2hz</span><span class="p">))</span><span class="o">*</span><span class="n">M</span><span class="o">**-</span><span class="mi">2</span>
            <span class="k">if</span> <span class="n">q</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="c"># You need to compute varphi, not S</span>
                <span class="n">A1</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">J_f</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">L_f</span><span class="o">-</span><span class="n">S_f</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">A2</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">L_f</span><span class="o">+</span><span class="n">S_f</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">J_f</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">A3</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">S_f</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">A4</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">S1</span><span class="o">+</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S_f</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>  
                <span class="n">cosvarphi</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">J_f</span><span class="o">*</span><span class="n">S_f</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">S1hz</span><span class="o">*</span><span class="n">S1</span><span class="o">-</span><span class="p">(</span><span class="n">S_f</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">S1</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">J_f</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L_f</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">S_f</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="n">A1</span><span class="o">*</span><span class="n">A2</span><span class="o">*</span><span class="n">A3</span><span class="o">*</span><span class="n">A4</span><span class="p">)</span>
                <span class="n">S_f</span><span class="o">=</span><span class="n">cosvarphi</span> 
            
            <span class="n">theta1_f</span><span class="p">,</span><span class="n">theta2_f</span><span class="p">,</span><span class="n">deltaphi_f</span><span class="p">,</span><span class="n">dummy</span><span class="o">=</span> <span class="n">parametric_angles</span><span class="p">(</span><span class="n">S_f</span><span class="p">,</span><span class="n">J_f</span><span class="p">,</span><span class="n">xi_f</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r_f</span><span class="p">)</span>
            <span class="c"># Track the precessional phase to set the sign of DeltaPhi. In symbols, the sign of DeltaPhi must be the sign of</span>
            <span class="c">#L dot [ ( S1 - (S1 dot L) dot L ) cross ( S2 - (S2 dot L) dot L ) ]</span>
            <span class="n">S1px</span><span class="o">=</span><span class="p">(</span><span class="n">S1hx</span><span class="o">-</span><span class="n">theta1_f</span><span class="o">*</span><span class="n">Lhx</span><span class="p">)</span>
            <span class="n">S1py</span><span class="o">=</span><span class="p">(</span><span class="n">S1hy</span><span class="o">-</span><span class="n">theta1_f</span><span class="o">*</span><span class="n">Lhy</span><span class="p">)</span>
            <span class="n">S1pz</span><span class="o">=</span><span class="p">(</span><span class="n">S1hz</span><span class="o">-</span><span class="n">theta1_f</span><span class="o">*</span><span class="n">Lhz</span><span class="p">)</span>
            <span class="n">S2px</span><span class="o">=</span><span class="p">(</span><span class="n">S2hx</span><span class="o">-</span><span class="n">theta2_f</span><span class="o">*</span><span class="n">Lhx</span><span class="p">)</span>
            <span class="n">S2py</span><span class="o">=</span><span class="p">(</span><span class="n">S2hy</span><span class="o">-</span><span class="n">theta2_f</span><span class="o">*</span><span class="n">Lhy</span><span class="p">)</span>
            <span class="n">S2pz</span><span class="o">=</span><span class="p">(</span><span class="n">S2hz</span><span class="o">-</span><span class="n">theta2_f</span><span class="o">*</span><span class="n">Lhz</span><span class="p">)</span>
            <span class="n">proj</span><span class="o">=</span><span class="n">Lhx</span><span class="o">*</span><span class="p">(</span><span class="n">S1py</span><span class="o">*</span><span class="n">S2pz</span><span class="o">-</span><span class="n">S1pz</span><span class="o">*</span><span class="n">S2py</span><span class="p">)</span> <span class="o">+</span> <span class="n">Lhy</span><span class="o">*</span><span class="p">(</span><span class="n">S1pz</span><span class="o">*</span><span class="n">S2px</span><span class="o">-</span><span class="n">S1px</span><span class="o">*</span><span class="n">S2pz</span><span class="p">)</span> <span class="o">+</span> <span class="n">Lhz</span><span class="o">*</span><span class="p">(</span><span class="n">S1px</span><span class="o">*</span><span class="n">S2py</span><span class="o">-</span><span class="n">S1py</span><span class="o">*</span><span class="n">S2px</span><span class="p">)</span>
            <span class="n">deltaphi_f</span><span class="o">*=</span><span class="n">math</span><span class="o">.</span><span class="n">copysign</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="n">proj</span><span class="p">)</span>
            
            <span class="n">outfilesave</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">r_f</span><span class="p">)</span><span class="o">+</span><span class="s">&quot; &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">theta1_f</span><span class="p">)</span><span class="o">+</span><span class="s">&quot; &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">theta2_f</span><span class="p">)</span><span class="o">+</span><span class="s">&quot; &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">deltaphi_f</span><span class="p">)</span><span class="o">+</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
        <span class="n">outfilesave</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        
    <span class="k">return</span> <span class="n">savename</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.kappa_backwards">
    <p>def <span class="ident">kappa_backwards</span>(</p><p>xi, J, r, q, S1, S2)</p>
    </div>
    

    
  
    <div class="desc"><p>Single integration of the dJ/dL equation to perfom precession-averaged
inspiral. Input/output are provided in J and r, but the internal integrator
uses kappa and u (see <a href="#precession.dkappadu"><code>dkappadu</code></a>). Integration is performed using
scipy's <code>odeint</code>.</p>
<p>This function integrates from some finite separation TO INFINITE separation
(u=0) only.</p>
<p>The initial binary is specified at the input separation r through J and xi
(S not needed). The binary is evolved backwards to r=infinity (u=0) and the
asymptotic value kappa_inf is returned. If q=1, kappa_inf is degenerate with
xi: the constant value of S is returned instead.</p>
<p>We recommend to use this function through the wrapper
<a href="#precession.evolve_J_backwards"><code>evolve_J_backwards</code></a> provided.</p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>kappa_inf=precession.kappa_backwards(xi,J,r,q,S1,S2)
</pre></div>


<p><strong>Parameters:</strong></p>
<ul>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>J</code>: magnitude of the total angular momentum.</li>
<li><code>r</code>: binary separation.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>kappa_inf</code>: asymptotic value of kappa at large separations.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.kappa_backwards', this);">Show source &equiv;</a></p>
  <div id="source-precession.kappa_backwards" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">kappa_backwards</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Single integration of the dJ/dL equation to perfom precession-averaged</span>
<span class="sd">    inspiral. Input/output are provided in J and r, but the internal integrator</span>
<span class="sd">    uses kappa and u (see `precession.dkappadu`). Integration is performed using</span>
<span class="sd">    scipy&#39;s `odeint`.</span>

<span class="sd">    This function integrates from some finite separation TO INFINITE separation</span>
<span class="sd">    (u=0) only.</span>

<span class="sd">    The initial binary is specified at the input separation r through J and xi</span>
<span class="sd">    (S not needed). The binary is evolved backwards to r=infinity (u=0) and the</span>
<span class="sd">    asymptotic value kappa_inf is returned. If q=1, kappa_inf is degenerate with</span>
<span class="sd">    xi: the constant value of S is returned instead.</span>

<span class="sd">    We recommend to use this function through the wrapper</span>
<span class="sd">    `precession.evolve_J_backwards` provided.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        kappa_inf=precession.kappa_backwards(xi,J,r,q,S1,S2)</span>

<span class="sd">    **Parameters:**</span>

<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `J`: magnitude of the total angular momentum.</span>
<span class="sd">    - `r`: binary separation.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `kappa_inf`: asymptotic value of kappa at large separations.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">L</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>

    <span class="k">global</span> <span class="n">flags_q1</span>
    <span class="k">if</span> <span class="n">q</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">flags_q1</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span><span class="o">==</span><span class="bp">False</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;[kappa_backwards] Warning q=1: sensible output is S, not kappa_inf.&quot;</span>
            <span class="n">flags_q1</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span><span class="o">=</span><span class="bp">True</span> <span class="c"># Suppress future warnings</span>
        <span class="n">S</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">xi</span><span class="o">*</span><span class="n">L</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">S</span>
    
    <span class="k">else</span><span class="p">:</span>
        <span class="n">u</span><span class="o">=</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">L</span><span class="p">)</span>
        <span class="n">kappa</span><span class="o">=</span> <span class="p">(</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">L</span><span class="p">)</span>
        <span class="n">u_vals</span><span class="o">=</span><span class="p">[</span><span class="n">u</span><span class="p">,</span><span class="mf">0.</span><span class="p">]</span><span class="c"># Add final condition, r=inifinty u=0</span>
        <span class="c"># Numerical integration to u=0    </span>
        <span class="n">res</span> <span class="o">=</span><span class="n">integrate</span><span class="o">.</span><span class="n">odeint</span><span class="p">(</span><span class="n">dkappadu</span><span class="p">,</span> <span class="n">kappa</span><span class="p">,</span> <span class="n">u_vals</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">),</span> <span class="n">mxstep</span><span class="o">=</span><span class="mi">50000</span><span class="p">,</span> <span class="n">full_output</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">printmessg</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="c">#,tcrit=sing)</span>
        <span class="n">kappa_inf</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">res</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">kappa_inf</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.kappa_backwards_checkpoint">
    <p>def <span class="ident">kappa_backwards_checkpoint</span>(</p><p>xi, J, r, q, S1, S2)</p>
    </div>
    

    
  
    <div class="desc"><p>Auxiliary function, see <a href="#precession.evolve_J_backwards"><code>evolve_J_backwards</code></a>.</p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>savename=precession.kappa_backwards_checkpoint(xi,J,r,q,S1,S2)
</pre></div>


<p><strong>Parameters:</strong></p>
<ul>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>J</code>: magnitude of the total angular momentum.</li>
<li><code>r</code>: binary separation.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>savename</code>: checkpoint filename.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.kappa_backwards_checkpoint', this);">Show source &equiv;</a></p>
  <div id="source-precession.kappa_backwards_checkpoint" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">kappa_backwards_checkpoint</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Auxiliary function, see `precession.evolve_J_backwards`.</span>
<span class="sd"> </span>
<span class="sd">    **Call:**</span>

<span class="sd">        savename=precession.kappa_backwards_checkpoint(xi,J,r,q,S1,S2)</span>

<span class="sd">    **Parameters:**</span>

<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `J`: magnitude of the total angular momentum.</span>
<span class="sd">    - `r`: binary separation.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `savename`: checkpoint filename.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s">&quot;mkdir -p &quot;</span><span class="o">+</span><span class="n">storedir</span><span class="p">)</span> 
    <span class="n">savename</span><span class="o">=</span> <span class="n">storedir</span><span class="o">+</span><span class="s">&quot;/evback&quot;</span><span class="o">+</span><span class="s">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">)])</span><span class="o">+</span><span class="s">&quot;.dat&quot;</span>
        
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">savename</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">&quot;[evolve_J_backwards] Transferring binary. Output:&quot;</span><span class="p">,</span> <span class="n">savename</span>
        <span class="n">outfilesave</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">savename</span><span class="p">,</span><span class="s">&quot;w&quot;</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
       
        <span class="n">kappa_inf</span><span class="o">=</span><span class="n">kappa_backwards</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">)</span>
        <span class="n">outfilesave</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">kappa_inf</span><span class="p">))</span>
        <span class="n">outfilesave</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="c">#else:</span>
    <span class="c">#    print &quot;[evolve_J_infinity] Skipping. Output:&quot;, savename</span>
    
    <span class="k">return</span> <span class="n">savename</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.kappainf_allowed">
    <p>def <span class="ident">kappainf_allowed</span>(</p><p>xi, q, S1, S2)</p>
    </div>
    

    
  
    <div class="desc"><p>Limits on kappa_inf for a given value of xi, obtained forcing
-1&lt;cos(theta_i)&lt;1.</p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>kappainf_low,kappainf_up=precession.kappainf_allowed(xi,q,S1,S2)
</pre></div>


<p><strong>Parameters:</strong></p>
<ul>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>kappainf_low</code>: minimum allowed value of kappa_inf, given the input parameters.</li>
<li><code>kappainf_up</code>: maximum allowed value of kappa_inf, given the input parameters.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.kappainf_allowed', this);">Show source &equiv;</a></p>
  <div id="source-precession.kappainf_allowed" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">kappainf_allowed</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Limits on kappa_inf for a given value of xi, obtained forcing</span>
<span class="sd">    -1&lt;cos(theta_i)&lt;1.</span>
<span class="sd"> </span>
<span class="sd">    **Call:**</span>

<span class="sd">        kappainf_low,kappainf_up=precession.kappainf_allowed(xi,q,S1,S2)</span>
<span class="sd">    </span>
<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `kappainf_low`: minimum allowed value of kappa_inf, given the input parameters.</span>
<span class="sd">    - `kappainf_up`: maximum allowed value of kappa_inf, given the input parameters.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="n">kappainf_low</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span> <span class="p">(</span><span class="n">xi</span> <span class="o">-</span> <span class="p">(</span><span class="n">q</span><span class="o">**-</span><span class="mi">1</span><span class="o">-</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">S2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">q</span><span class="p">)</span> <span class="p">,</span> <span class="p">(</span><span class="n">xi</span> <span class="o">-</span> <span class="p">(</span><span class="n">q</span><span class="o">**-</span><span class="mi">1</span><span class="o">-</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">S1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">q</span><span class="o">**-</span><span class="mi">1</span><span class="p">)</span> <span class="p">)</span>
    <span class="n">kappainf_up</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span> <span class="p">(</span><span class="n">xi</span> <span class="o">+</span> <span class="p">(</span><span class="n">q</span><span class="o">**-</span><span class="mi">1</span><span class="o">-</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">S2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">q</span><span class="p">)</span> <span class="p">,</span> <span class="p">(</span><span class="n">xi</span> <span class="o">+</span> <span class="p">(</span><span class="n">q</span><span class="o">**-</span><span class="mi">1</span><span class="o">-</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">S1</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">q</span><span class="o">**-</span><span class="mi">1</span><span class="p">)</span> <span class="p">)</span>
    <span class="k">return</span> <span class="n">kappainf_low</span><span class="p">,</span><span class="n">kappainf_up</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.kappainf_lim">
    <p>def <span class="ident">kappainf_lim</span>(</p><p>S1, S2)</p>
    </div>
    

    
  
    <div class="desc"><p>Absolute limits in kappa_inf (asymptotic value of kappa). At large
separations, kappa is the projection of the total spin along L.</p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>kappainf_min,kappainf_max=precession.kappainf_lim(S1,S2)
</pre></div>


<p><strong>Parameters:</strong></p>
<ul>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>kappainf_min</code>: minimum value of kappa at infinitely large separations.</li>
<li><code>kappainf_max</code>: maximum value of kappa at infinitely large separations.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.kappainf_lim', this);">Show source &equiv;</a></p>
  <div id="source-precession.kappainf_lim" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">kappainf_lim</span><span class="p">(</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">):</span>
    
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Absolute limits in kappa_inf (asymptotic value of kappa). At large</span>
<span class="sd">    separations, kappa is the projection of the total spin along L.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        kappainf_min,kappainf_max=precession.kappainf_lim(S1,S2)</span>
<span class="sd">     </span>
<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `kappainf_min`: minimum value of kappa at infinitely large separations.</span>
<span class="sd">    - `kappainf_max`: maximum value of kappa at infinitely large separations.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="k">return</span> <span class="o">-</span><span class="p">(</span><span class="n">S1</span><span class="o">+</span><span class="n">S2</span><span class="p">),</span> <span class="n">S1</span><span class="o">+</span><span class="n">S2</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.make_temp">
    <p>def <span class="ident">make_temp</span>(</p><p>)</p>
    </div>
    

    
  
    <div class="desc"><p>Make an empty directory to store checkpoints. Calling this function is
typically not necessary, because the checkpoint directory is created when
needed.</p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>precession.make_temp()
</pre></div></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.make_temp', this);">Show source &equiv;</a></p>
  <div id="source-precession.make_temp" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">make_temp</span><span class="p">():</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Make an empty directory to store checkpoints. Calling this function is</span>
<span class="sd">    typically not necessary, because the checkpoint directory is created when</span>
<span class="sd">    needed.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        precession.make_temp()</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="k">global</span> <span class="n">storedir</span>
    <span class="k">print</span> <span class="s">&quot;[make_temp] Creating temp directory: &quot;</span><span class="o">+</span><span class="n">storedir</span>
    <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s">&quot;mkdir -p &quot;</span><span class="o">+</span><span class="n">storedir</span><span class="p">)</span> 
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.orbav_eqs">
    <p>def <span class="ident">orbav_eqs</span>(</p><p>allvars, v, q, S1, S2, eta, m1, m2, chi1, chi2)</p>
    </div>
    

    
  
    <div class="desc"><p>Right-hand side of the orbit-averaged PN equations: d[allvars]/dv=RHS, where
allvars is an array with the cartesian components of the unit vectors L, S1
and S2. This function is only the actual system of equations, not the ODE
solver.</p>
<p>Equations are the ones reported in Gerosa et al. <a href="http://journals.aps.org/prd/abstract/10.1103/PhysRevD.87.104028">Phys.Rev. D87 (2013) 10,
104028</a>;
see references therein. In particular, the quadrupole-monopole term computed
by Racine is included. The results presented in Gerosa et al. 2013 actually
use additional unpublished terms, that are not listed in the published
equations and are NOT included here. Radiation reaction is included up to
3.5PN.</p>
<p>The internal quadrupole_formula flag switches off all PN corrections in
radiation reaction.</p>
<p>The integration is carried over in the orbital velocity v (equivalent to the
separation), not in time. If an expression for v(t) is needed, the code can
be easiliy modified to return time as well.</p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>allders=precession.orbav_eqs(allvars,v,q,S1,S2,eta,m1,m2,chi1,chi2)
</pre></div>


<p><strong>Parameters:</strong>
- <code>allvars</code>: array of lenght 9 cointaining the initial condition for numerical integration for the components of the unit vectors L, S1 and S2.
- <code>v</code>: orbital velocity.
- <code>q</code>: binary mass ratio. Must be q&lt;=1.
- <code>S1</code>: spin magnitude of the primary BH.
- <code>S2</code>: spin magnitude of the secondary BH.
- <code>eta</code>: symmetric mass ratio.
- <code>m1</code>: mass of the primary BH.
- <code>m2</code>: mass of the secondary BH.
- <code>chi1</code>: dimensionless spin magnitude of the primary BH. Must be 0&lt;=chi1&lt;=1
- <code>chi2</code>: dimensionless spin magnitude of the secondary BH. Must be 0&lt;=chi2&lt;=1</p>
<p><strong>Returns:</strong></p>
<ul>
<li><code>allders</code>: array of lenght 9 cointaining the derivatives of allvars with respect to the orbital velocity v.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.orbav_eqs', this);">Show source &equiv;</a></p>
  <div id="source-precession.orbav_eqs" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">orbav_eqs</span><span class="p">(</span><span class="n">allvars</span><span class="p">,</span><span class="n">v</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">eta</span><span class="p">,</span><span class="n">m1</span><span class="p">,</span><span class="n">m2</span><span class="p">,</span><span class="n">chi1</span><span class="p">,</span><span class="n">chi2</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Right-hand side of the orbit-averaged PN equations: d[allvars]/dv=RHS, where</span>
<span class="sd">    allvars is an array with the cartesian components of the unit vectors L, S1</span>
<span class="sd">    and S2. This function is only the actual system of equations, not the ODE</span>
<span class="sd">    solver.</span>

<span class="sd">    Equations are the ones reported in Gerosa et al. [Phys.Rev. D87 (2013) 10,</span>
<span class="sd">    104028](http://journals.aps.org/prd/abstract/10.1103/PhysRevD.87.104028);</span>
<span class="sd">    see references therein. In particular, the quadrupole-monopole term computed</span>
<span class="sd">    by Racine is included. The results presented in Gerosa et al. 2013 actually</span>
<span class="sd">    use additional unpublished terms, that are not listed in the published</span>
<span class="sd">    equations and are NOT included here. Radiation reaction is included up to</span>
<span class="sd">    3.5PN.</span>

<span class="sd">    The internal quadrupole_formula flag switches off all PN corrections in</span>
<span class="sd">    radiation reaction.</span>

<span class="sd">    The integration is carried over in the orbital velocity v (equivalent to the</span>
<span class="sd">    separation), not in time. If an expression for v(t) is needed, the code can</span>
<span class="sd">    be easiliy modified to return time as well.</span>
<span class="sd"> </span>
<span class="sd">    **Call:**</span>

<span class="sd">        allders=precession.orbav_eqs(allvars,v,q,S1,S2,eta,m1,m2,chi1,chi2)</span>

<span class="sd">    **Parameters:**</span>
<span class="sd">    - `allvars`: array of lenght 9 cointaining the initial condition for numerical integration for the components of the unit vectors L, S1 and S2.</span>
<span class="sd">    - `v`: orbital velocity.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `eta`: symmetric mass ratio.</span>
<span class="sd">    - `m1`: mass of the primary BH.</span>
<span class="sd">    - `m2`: mass of the secondary BH.</span>
<span class="sd">    - `chi1`: dimensionless spin magnitude of the primary BH. Must be 0&lt;=chi1&lt;=1</span>
<span class="sd">    - `chi2`: dimensionless spin magnitude of the secondary BH. Must be 0&lt;=chi2&lt;=1</span>
<span class="sd">    </span>
<span class="sd">    **Returns:**</span>

<span class="sd">    - `allders`: array of lenght 9 cointaining the derivatives of allvars with respect to the orbital velocity v.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="c"># Read variables in</span>
    <span class="n">Lhx</span><span class="o">=</span><span class="n">allvars</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">Lhy</span><span class="o">=</span><span class="n">allvars</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">Lhz</span><span class="o">=</span><span class="n">allvars</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">S1hx</span><span class="o">=</span><span class="n">allvars</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">S1hy</span><span class="o">=</span><span class="n">allvars</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
    <span class="n">S1hz</span><span class="o">=</span><span class="n">allvars</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
    <span class="n">S2hx</span><span class="o">=</span><span class="n">allvars</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>
    <span class="n">S2hy</span><span class="o">=</span><span class="n">allvars</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span>
    <span class="n">S2hz</span><span class="o">=</span><span class="n">allvars</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span>
    <span class="c">#t=allvars[9] # Uncomment if v(t) is needed</span>

    <span class="c"># Useful variables</span>
    <span class="n">ct1</span><span class="o">=</span><span class="p">(</span><span class="n">Lhx</span><span class="o">*</span><span class="n">S1hx</span><span class="o">+</span><span class="n">Lhy</span><span class="o">*</span><span class="n">S1hy</span><span class="o">+</span><span class="n">Lhz</span><span class="o">*</span><span class="n">S1hz</span><span class="p">)</span>
    <span class="n">ct2</span><span class="o">=</span><span class="p">(</span><span class="n">Lhx</span><span class="o">*</span><span class="n">S2hx</span><span class="o">+</span><span class="n">Lhy</span><span class="o">*</span><span class="n">S2hy</span><span class="o">+</span><span class="n">Lhz</span><span class="o">*</span><span class="n">S2hz</span><span class="p">)</span>
    <span class="n">ct12</span><span class="o">=</span><span class="p">(</span><span class="n">S1hx</span><span class="o">*</span><span class="n">S2hx</span><span class="o">+</span><span class="n">S1hy</span><span class="o">*</span><span class="n">S2hy</span><span class="o">+</span><span class="n">S1hz</span><span class="o">*</span><span class="n">S2hz</span><span class="p">)</span>

    <span class="c"># Spin precession for S1</span>
    <span class="n">Omega1x</span><span class="o">=</span> <span class="n">eta</span><span class="o">*</span><span class="n">v</span><span class="o">**</span><span class="mi">5</span><span class="o">*</span><span class="p">(</span><span class="mf">2.</span><span class="o">+</span><span class="mf">3.</span><span class="o">*</span><span class="n">q</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span><span class="o">*</span><span class="n">Lhx</span><span class="o">/</span><span class="n">M</span>  \
            <span class="o">+</span> <span class="n">v</span><span class="o">**</span><span class="mi">6</span><span class="o">*</span><span class="p">(</span><span class="n">S2</span><span class="o">*</span><span class="n">S2hx</span><span class="o">-</span><span class="mf">3.</span><span class="o">*</span><span class="n">S2</span><span class="o">*</span><span class="n">ct2</span><span class="o">*</span><span class="n">Lhx</span><span class="o">-</span><span class="mf">3.</span><span class="o">*</span><span class="n">q</span><span class="o">*</span><span class="n">S1</span><span class="o">*</span><span class="n">ct1</span><span class="o">*</span><span class="n">Lhx</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">Omega1y</span><span class="o">=</span> <span class="n">eta</span><span class="o">*</span><span class="n">v</span><span class="o">**</span><span class="mi">5</span><span class="o">*</span><span class="p">(</span><span class="mf">2.</span><span class="o">+</span><span class="mf">3.</span><span class="o">*</span><span class="n">q</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span><span class="o">*</span><span class="n">Lhy</span><span class="o">/</span><span class="n">M</span>  \
            <span class="o">+</span> <span class="n">v</span><span class="o">**</span><span class="mi">6</span><span class="o">*</span><span class="p">(</span><span class="n">S2</span><span class="o">*</span><span class="n">S2hy</span><span class="o">-</span><span class="mf">3.</span><span class="o">*</span><span class="n">S2</span><span class="o">*</span><span class="n">ct2</span><span class="o">*</span><span class="n">Lhy</span><span class="o">-</span><span class="mf">3.</span><span class="o">*</span><span class="n">q</span><span class="o">*</span><span class="n">S1</span><span class="o">*</span><span class="n">ct1</span><span class="o">*</span><span class="n">Lhy</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">Omega1z</span><span class="o">=</span> <span class="n">eta</span><span class="o">*</span><span class="n">v</span><span class="o">**</span><span class="mi">5</span><span class="o">*</span><span class="p">(</span><span class="mf">2.</span><span class="o">+</span><span class="mf">3.</span><span class="o">*</span><span class="n">q</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span><span class="o">*</span><span class="n">Lhz</span><span class="o">/</span><span class="n">M</span>  \
            <span class="o">+</span> <span class="n">v</span><span class="o">**</span><span class="mi">6</span><span class="o">*</span><span class="p">(</span><span class="n">S2</span><span class="o">*</span><span class="n">S2hz</span><span class="o">-</span><span class="mf">3.</span><span class="o">*</span><span class="n">S2</span><span class="o">*</span><span class="n">ct2</span><span class="o">*</span><span class="n">Lhz</span><span class="o">-</span><span class="mf">3.</span><span class="o">*</span><span class="n">q</span><span class="o">*</span><span class="n">S1</span><span class="o">*</span><span class="n">ct1</span><span class="o">*</span><span class="n">Lhz</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>

    <span class="n">dS1hxdt</span><span class="o">=</span> <span class="n">Omega1y</span><span class="o">*</span><span class="n">S1hz</span> <span class="o">-</span> <span class="n">Omega1z</span><span class="o">*</span><span class="n">S1hy</span>
    <span class="n">dS1hydt</span><span class="o">=</span> <span class="n">Omega1z</span><span class="o">*</span><span class="n">S1hx</span> <span class="o">-</span> <span class="n">Omega1x</span><span class="o">*</span><span class="n">S1hz</span>
    <span class="n">dS1hzdt</span><span class="o">=</span> <span class="n">Omega1x</span><span class="o">*</span><span class="n">S1hy</span> <span class="o">-</span> <span class="n">Omega1y</span><span class="o">*</span><span class="n">S1hx</span>

    <span class="c"># Spin precession for S2</span>
    <span class="n">Omega2x</span><span class="o">=</span> <span class="n">eta</span><span class="o">*</span><span class="n">v</span><span class="o">**</span><span class="mi">5</span><span class="o">*</span><span class="p">(</span><span class="mf">2.</span><span class="o">+</span><span class="mf">3.</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">q</span><span class="p">))</span><span class="o">*</span><span class="n">Lhx</span><span class="o">/</span><span class="n">M</span>  \
            <span class="o">+</span> <span class="n">v</span><span class="o">**</span><span class="mi">6</span><span class="o">*</span><span class="p">(</span><span class="n">S1</span><span class="o">*</span><span class="n">S1hx</span><span class="o">-</span><span class="mf">3.</span><span class="o">*</span><span class="n">S1</span><span class="o">*</span><span class="n">ct1</span><span class="o">*</span><span class="n">Lhx</span><span class="o">-</span><span class="mf">3.</span><span class="o">*</span><span class="n">S2</span><span class="o">*</span><span class="n">ct2</span><span class="o">*</span><span class="n">Lhx</span><span class="o">/</span><span class="n">q</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">Omega2y</span><span class="o">=</span> <span class="n">eta</span><span class="o">*</span><span class="n">v</span><span class="o">**</span><span class="mi">5</span><span class="o">*</span><span class="p">(</span><span class="mf">2.</span><span class="o">+</span><span class="mf">3.</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">q</span><span class="p">))</span><span class="o">*</span><span class="n">Lhy</span><span class="o">/</span><span class="n">M</span>  \
            <span class="o">+</span> <span class="n">v</span><span class="o">**</span><span class="mi">6</span><span class="o">*</span><span class="p">(</span><span class="n">S1</span><span class="o">*</span><span class="n">S1hy</span><span class="o">-</span><span class="mf">3.</span><span class="o">*</span><span class="n">S1</span><span class="o">*</span><span class="n">ct1</span><span class="o">*</span><span class="n">Lhy</span><span class="o">-</span><span class="mf">3.</span><span class="o">*</span><span class="n">S2</span><span class="o">*</span><span class="n">ct2</span><span class="o">*</span><span class="n">Lhy</span><span class="o">/</span><span class="n">q</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">Omega2z</span><span class="o">=</span> <span class="n">eta</span><span class="o">*</span><span class="n">v</span><span class="o">**</span><span class="mi">5</span><span class="o">*</span><span class="p">(</span><span class="mf">2.</span><span class="o">+</span><span class="mf">3.</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">q</span><span class="p">))</span><span class="o">*</span><span class="n">Lhz</span><span class="o">/</span><span class="n">M</span>  \
            <span class="o">+</span> <span class="n">v</span><span class="o">**</span><span class="mi">6</span><span class="o">*</span><span class="p">(</span><span class="n">S1</span><span class="o">*</span><span class="n">S1hz</span><span class="o">-</span><span class="mf">3.</span><span class="o">*</span><span class="n">S1</span><span class="o">*</span><span class="n">ct1</span><span class="o">*</span><span class="n">Lhz</span><span class="o">-</span><span class="mf">3.</span><span class="o">*</span><span class="n">S2</span><span class="o">*</span><span class="n">ct2</span><span class="o">*</span><span class="n">Lhz</span><span class="o">/</span><span class="n">q</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>

    <span class="n">dS2hxdt</span><span class="o">=</span> <span class="n">Omega2y</span><span class="o">*</span><span class="n">S2hz</span> <span class="o">-</span> <span class="n">Omega2z</span><span class="o">*</span><span class="n">S2hy</span>
    <span class="n">dS2hydt</span><span class="o">=</span> <span class="n">Omega2z</span><span class="o">*</span><span class="n">S2hx</span> <span class="o">-</span> <span class="n">Omega2x</span><span class="o">*</span><span class="n">S2hz</span>
    <span class="n">dS2hzdt</span><span class="o">=</span> <span class="n">Omega2x</span><span class="o">*</span><span class="n">S2hy</span> <span class="o">-</span> <span class="n">Omega2y</span><span class="o">*</span><span class="n">S2hx</span>

    <span class="c"># Conservation of angular momentum</span>
    <span class="n">dLhxdt</span><span class="o">=</span> <span class="o">-</span><span class="mf">1.</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="p">(</span><span class="n">S1</span><span class="o">*</span><span class="n">dS1hxdt</span><span class="o">+</span><span class="n">S2</span><span class="o">*</span><span class="n">dS2hxdt</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">eta</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">dLhydt</span><span class="o">=</span> <span class="o">-</span><span class="mf">1.</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="p">(</span><span class="n">S1</span><span class="o">*</span><span class="n">dS1hydt</span><span class="o">+</span><span class="n">S2</span><span class="o">*</span><span class="n">dS2hydt</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">eta</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">dLhzdt</span><span class="o">=</span> <span class="o">-</span><span class="mf">1.</span><span class="o">*</span><span class="n">v</span><span class="o">*</span><span class="p">(</span><span class="n">S1</span><span class="o">*</span><span class="n">dS1hzdt</span><span class="o">+</span><span class="n">S2</span><span class="o">*</span><span class="n">dS2hzdt</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">eta</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

    <span class="c"># Radiation reaction</span>
    <span class="n">quadrupole_formula</span><span class="o">=</span><span class="bp">False</span>
    <span class="k">if</span> <span class="n">quadrupole_formula</span><span class="p">:</span>
        <span class="n">dvdt</span><span class="o">=</span> <span class="p">(</span><span class="mf">32.</span><span class="o">*</span><span class="n">eta</span><span class="o">*</span><span class="n">v</span><span class="o">**</span><span class="mi">9</span><span class="o">/</span><span class="p">(</span><span class="mf">5.</span><span class="o">*</span><span class="n">M</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dvdt</span><span class="o">=</span> <span class="p">(</span><span class="mf">32.</span><span class="o">*</span><span class="n">eta</span><span class="o">*</span><span class="n">v</span><span class="o">**</span><span class="mi">9</span><span class="o">/</span><span class="p">(</span><span class="mf">5.</span><span class="o">*</span><span class="n">M</span><span class="p">))</span><span class="o">*</span> <span class="p">(</span> <span class="mf">1.</span>                               \
            <span class="o">-</span> <span class="n">v</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span> <span class="p">(</span><span class="mf">743.</span><span class="o">+</span><span class="mf">924.</span><span class="o">*</span><span class="n">eta</span><span class="p">)</span><span class="o">/</span><span class="mf">336.</span>                                \
            <span class="o">+</span> <span class="n">v</span><span class="o">**</span><span class="mi">3</span><span class="o">*</span> <span class="p">(</span><span class="mf">4.</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>                                           \
                     <span class="o">-</span> <span class="n">chi1</span><span class="o">*</span><span class="n">ct1</span><span class="o">*</span><span class="p">(</span><span class="mf">113.</span><span class="o">*</span><span class="n">m1</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="mf">12.</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mf">25.</span><span class="o">*</span><span class="n">eta</span><span class="o">/</span><span class="mf">4.</span> <span class="p">)</span>   \
                     <span class="o">-</span> <span class="n">chi2</span><span class="o">*</span><span class="n">ct2</span><span class="o">*</span><span class="p">(</span><span class="mf">113.</span><span class="o">*</span><span class="n">m2</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="mf">12.</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mf">25.</span><span class="o">*</span><span class="n">eta</span><span class="o">/</span><span class="mf">4.</span> <span class="p">))</span>  \
            <span class="o">+</span> <span class="n">v</span><span class="o">**</span><span class="mi">4</span><span class="o">*</span> <span class="p">(</span><span class="mf">34103.</span><span class="o">/</span><span class="mf">18144.</span> <span class="o">+</span> <span class="mf">13661.</span><span class="o">*</span><span class="n">eta</span><span class="o">/</span><span class="mf">2016.</span> <span class="o">+</span> <span class="mf">59.</span><span class="o">*</span><span class="n">eta</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mf">18.</span>  \
                     <span class="o">+</span> <span class="n">eta</span><span class="o">*</span><span class="n">chi1</span><span class="o">*</span><span class="n">chi2</span><span class="o">*</span> <span class="p">(</span><span class="mf">721.</span><span class="o">*</span><span class="n">ct1</span><span class="o">*</span><span class="n">ct2</span> <span class="o">-</span> <span class="mf">247.</span><span class="o">*</span><span class="n">ct12</span><span class="p">)</span> <span class="o">/</span><span class="mf">48.</span>   \
                     <span class="o">+</span> <span class="p">((</span><span class="n">m1</span><span class="o">*</span><span class="n">chi1</span><span class="o">/</span><span class="n">M</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mf">719.</span><span class="o">*</span><span class="n">ct1</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="mf">233.</span><span class="p">))</span><span class="o">/</span><span class="mf">96.</span>        \
                     <span class="o">+</span> <span class="p">((</span><span class="n">m2</span><span class="o">*</span><span class="n">chi2</span><span class="o">/</span><span class="n">M</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mf">719.</span><span class="o">*</span><span class="n">ct2</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="mf">233.</span><span class="p">))</span><span class="o">/</span><span class="mf">96.</span><span class="p">)</span>       \
            <span class="o">-</span> <span class="n">v</span><span class="o">**</span><span class="mi">5</span><span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="mf">4159.</span><span class="o">+</span><span class="mf">15876.</span><span class="o">*</span><span class="n">eta</span><span class="p">)</span><span class="o">/</span><span class="mf">672.</span>                       \
            <span class="o">+</span> <span class="n">v</span><span class="o">**</span><span class="mi">6</span><span class="o">*</span> <span class="p">(</span><span class="mf">16447322263.</span><span class="o">/</span><span class="mf">139708800.</span> <span class="o">+</span> <span class="mf">16.</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mf">3.</span>          \
                     <span class="o">-</span><span class="mf">1712.</span><span class="o">*</span><span class="p">(</span><span class="mf">0.5772156649</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">4.</span><span class="o">*</span><span class="n">v</span><span class="p">))</span><span class="o">/</span><span class="mf">105.</span>            \
                     <span class="o">+</span><span class="p">(</span><span class="mf">451.</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mf">48.</span> <span class="o">-</span> <span class="mf">56198689.</span><span class="o">/</span><span class="mf">217728.</span><span class="p">)</span><span class="o">*</span><span class="n">eta</span>       \
                     <span class="o">+</span><span class="mf">541.</span><span class="o">*</span><span class="n">eta</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mf">896.</span> <span class="o">-</span> <span class="mi">5605</span><span class="o">*</span><span class="n">eta</span><span class="o">**</span><span class="mi">3</span><span class="o">/</span><span class="mf">2592.</span><span class="p">)</span>             \
            <span class="o">+</span> <span class="n">v</span><span class="o">**</span><span class="mi">7</span><span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span> <span class="o">-</span><span class="mf">4415.</span><span class="o">/</span><span class="mf">4032.</span> <span class="o">+</span> <span class="mf">358675.</span><span class="o">*</span><span class="n">eta</span><span class="o">/</span><span class="mf">6048.</span>            \
                     <span class="o">+</span> <span class="mf">91495.</span><span class="o">*</span><span class="n">eta</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="mf">1512.</span><span class="p">)</span>                             \
            <span class="p">)</span>

    <span class="c"># Integrate in v, not in time</span>
    <span class="n">dtdv</span><span class="o">=</span><span class="mf">1.</span><span class="o">/</span><span class="n">dvdt</span>
    <span class="n">dLhxdv</span><span class="o">=</span><span class="n">dLhxdt</span><span class="o">*</span><span class="n">dtdv</span>
    <span class="n">dLhydv</span><span class="o">=</span><span class="n">dLhydt</span><span class="o">*</span><span class="n">dtdv</span>
    <span class="n">dLhzdv</span><span class="o">=</span><span class="n">dLhzdt</span><span class="o">*</span><span class="n">dtdv</span>
    <span class="n">dS1hxdv</span><span class="o">=</span><span class="n">dS1hxdt</span><span class="o">*</span><span class="n">dtdv</span>
    <span class="n">dS1hydv</span><span class="o">=</span><span class="n">dS1hydt</span><span class="o">*</span><span class="n">dtdv</span>
    <span class="n">dS1hzdv</span><span class="o">=</span><span class="n">dS1hzdt</span><span class="o">*</span><span class="n">dtdv</span>
    <span class="n">dS2hxdv</span><span class="o">=</span><span class="n">dS2hxdt</span><span class="o">*</span><span class="n">dtdv</span>
    <span class="n">dS2hydv</span><span class="o">=</span><span class="n">dS2hydt</span><span class="o">*</span><span class="n">dtdv</span>
    <span class="n">dS2hzdv</span><span class="o">=</span><span class="n">dS2hzdt</span><span class="o">*</span><span class="n">dtdv</span>
    
    <span class="c"># Uncomment if v(t) is needed</span>
    <span class="c">#return dLhxdv, dLhydv, dLhzdv, dS1hxdv, dS1hydv, dS1hzdv, dS2hxdv, dS2hydv, dS2hzdv , dtdv</span>
    
    <span class="k">return</span> <span class="n">dLhxdv</span><span class="p">,</span> <span class="n">dLhydv</span><span class="p">,</span> <span class="n">dLhzdv</span><span class="p">,</span> <span class="n">dS1hxdv</span><span class="p">,</span> <span class="n">dS1hydv</span><span class="p">,</span> <span class="n">dS1hzdv</span><span class="p">,</span> <span class="n">dS2hxdv</span><span class="p">,</span> <span class="n">dS2hydv</span><span class="p">,</span> <span class="n">dS2hzdv</span> 
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.orbav_integrator">
    <p>def <span class="ident">orbav_integrator</span>(</p><p>J, xi, S, r_vals, q, S1, S2)</p>
    </div>
    

    
  
    <div class="desc"><p>Single orbit-averaged integration. Integrate the system of ODEs specified in
<a href="#precession.orbav_eqs"><code>orbav_eqs</code></a>. The initial configuration (at r_vals[0]) is
specified through J, xi and S. The components of the unit vectors L, S1 and
S2 are returned at the output separations specified by r_vals. The initial
values of J and S must be compatible with the initial separation r_vals[0],
otherwise an error is raised. Integration is performed in a reference frame
in which the z axis is along J and L lies in the x-z plane at the initial
separation. Equations are integrated in v (orbital velocity) but outputs are
converted to r (separation).</p>
<p>Of course, this can only integrate to/from FINITE separations.</p>
<p>Bear in mind that orbit-averaged integrations are tpically possible from
r&lt;10000; integrations from larger separations take a very long time and can
occasionally crash. If q=1, the initial binary configuration is specified
through cos(varphi), not S.</p>
<p>We recommend to use one of the wrappers <a href="#precession.orbit_averaged"><code>orbit_averaged</code></a> and
<a href="#precession.orbit_angles"><code>orbit_angles</code></a> provided.</p>
<p><strong>Call:</strong>
    Lhx_fvals,Lhy_fvals,Lhz_fvals,S1hx_fvals,S1hy_fvals,S1hz_fvals,S2hx_fvals,S2hy_fvals,S2hz_fvals=precession.orbav_integrator(J,xi,S,r_vals,q,S1,S2)</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>J</code>: magnitude of the total angular momentum.</li>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>S</code>: magnitude of the total spin.</li>
<li><code>r_vals</code>: binary separation (array).</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>Lhx_vals</code>: x component of the unit vector L/|L|.</li>
<li><code>Lhy_vals</code>: y component of the unit vector L/|L|.</li>
<li><code>Lhz_vals</code>: z component of the unit vector L/|L|.</li>
<li><code>S1hx_vals</code>: x component of the unit vector S1/|S1|.</li>
<li><code>S1hy_vals</code>: y component of the unit vector S1/|S1|.</li>
<li><code>S1hz_vals</code>: z component of the unit vector S1/|S1|.</li>
<li><code>S2hx_vals</code>: x component of the unit vector S2/|S2|.</li>
<li><code>S2hy_vals</code>: y component of the unit vector S2/|S2|.</li>
<li><code>S2hz_vals</code>: z component of the unit vector S2/|S2|.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.orbav_integrator', this);">Show source &equiv;</a></p>
  <div id="source-precession.orbav_integrator" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">orbav_integrator</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">r_vals</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">):</span>
    
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Single orbit-averaged integration. Integrate the system of ODEs specified in</span>
<span class="sd">    `precession.orbav_eqs`. The initial configuration (at r_vals[0]) is</span>
<span class="sd">    specified through J, xi and S. The components of the unit vectors L, S1 and</span>
<span class="sd">    S2 are returned at the output separations specified by r_vals. The initial</span>
<span class="sd">    values of J and S must be compatible with the initial separation r_vals[0],</span>
<span class="sd">    otherwise an error is raised. Integration is performed in a reference frame</span>
<span class="sd">    in which the z axis is along J and L lies in the x-z plane at the initial</span>
<span class="sd">    separation. Equations are integrated in v (orbital velocity) but outputs are</span>
<span class="sd">    converted to r (separation).</span>

<span class="sd">    Of course, this can only integrate to/from FINITE separations.</span>

<span class="sd">    Bear in mind that orbit-averaged integrations are tpically possible from</span>
<span class="sd">    r&lt;10000; integrations from larger separations take a very long time and can</span>
<span class="sd">    occasionally crash. If q=1, the initial binary configuration is specified</span>
<span class="sd">    through cos(varphi), not S.</span>

<span class="sd">    We recommend to use one of the wrappers `precession.orbit_averaged` and</span>
<span class="sd">    `precession.orbit_angles` provided.</span>
<span class="sd"> </span>
<span class="sd">    **Call:**</span>
<span class="sd">        Lhx_fvals,Lhy_fvals,Lhz_fvals,S1hx_fvals,S1hy_fvals,S1hz_fvals,S2hx_fvals,S2hy_fvals,S2hz_fvals=precession.orbav_integrator(J,xi,S,r_vals,q,S1,S2)</span>

<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `J`: magnitude of the total angular momentum.</span>
<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `S`: magnitude of the total spin.</span>
<span class="sd">    - `r_vals`: binary separation (array).</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `Lhx_vals`: x component of the unit vector L/|L|.</span>
<span class="sd">    - `Lhy_vals`: y component of the unit vector L/|L|.</span>
<span class="sd">    - `Lhz_vals`: z component of the unit vector L/|L|.</span>
<span class="sd">    - `S1hx_vals`: x component of the unit vector S1/|S1|.</span>
<span class="sd">    - `S1hy_vals`: y component of the unit vector S1/|S1|.</span>
<span class="sd">    - `S1hz_vals`: z component of the unit vector S1/|S1|.</span>
<span class="sd">    - `S2hx_vals`: x component of the unit vector S2/|S2|.</span>
<span class="sd">    - `S2hy_vals`: y component of the unit vector S2/|S2|.</span>
<span class="sd">    - `S2hz_vals`: z component of the unit vector S2/|S2|.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="c"># Get initial condition in a cartesian frame. Use the frame aligned to J at the initial separation</span>
    <span class="k">global</span> <span class="n">flags_q1</span>
    <span class="k">if</span> <span class="n">q</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">flags_q1</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span><span class="o">==</span><span class="bp">False</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;[orbav_integrator] Warning q=1: input here is cos(varphi), not S.&quot;</span>
            <span class="n">flags_q1</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span><span class="o">=</span><span class="bp">True</span>
    
    <span class="n">L_vals</span><span class="o">=</span><span class="p">[(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">comp</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span> <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">r_vals</span><span class="p">]</span>
    <span class="n">v_vals</span><span class="o">=</span><span class="p">[(</span><span class="n">M</span><span class="o">/</span><span class="n">comp</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span> <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">r_vals</span><span class="p">]</span>
    <span class="n">Jvec</span><span class="p">,</span><span class="n">Lvec</span><span class="p">,</span><span class="n">S1vec</span><span class="p">,</span><span class="n">S2vec</span><span class="p">,</span><span class="n">dummy</span><span class="o">=</span><span class="n">Jframe_projection</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r_vals</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    
    <span class="n">Lh_initial</span><span class="o">=</span><span class="p">[</span><span class="n">comp</span><span class="o">/</span><span class="n">L_vals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">Lvec</span><span class="p">]</span>  
    <span class="n">S1h_initial</span><span class="o">=</span><span class="p">[</span><span class="n">comp</span><span class="o">/</span><span class="n">S1</span> <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">S1vec</span><span class="p">]</span>
    <span class="n">S2h_initial</span><span class="o">=</span><span class="p">[</span><span class="n">comp</span><span class="o">/</span><span class="n">S2</span> <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">S2vec</span><span class="p">]</span>
    
    <span class="c">#t_initial=0 # Uncomment if v(t) is needed</span>
    <span class="n">allvars_initial</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">Lh_initial</span><span class="p">)</span><span class="o">+</span><span class="nb">list</span><span class="p">(</span><span class="n">S1h_initial</span><span class="p">)</span><span class="o">+</span><span class="nb">list</span><span class="p">(</span><span class="n">S2h_initial</span><span class="p">)</span> <span class="c">#+list([t_initial])</span>

    <span class="c">#Compute these numbers only once</span>
    <span class="n">eta</span><span class="o">=</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> 
    <span class="n">m1</span><span class="o">=</span><span class="n">M</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span>
    <span class="n">m2</span><span class="o">=</span><span class="n">q</span><span class="o">*</span><span class="n">M</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span> 
    <span class="n">chi1</span><span class="o">=</span><span class="n">S1</span><span class="o">/</span><span class="n">m1</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">chi2</span><span class="o">=</span><span class="n">S2</span><span class="o">/</span><span class="n">m2</span><span class="o">**</span><span class="mi">2</span>

    <span class="c"># Actual integration</span>
    <span class="n">res</span> <span class="o">=</span><span class="n">integrate</span><span class="o">.</span><span class="n">odeint</span><span class="p">(</span><span class="n">orbav_eqs</span><span class="p">,</span> <span class="n">allvars_initial</span><span class="p">,</span> <span class="n">v_vals</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">eta</span><span class="p">,</span><span class="n">m1</span><span class="p">,</span><span class="n">m2</span><span class="p">,</span><span class="n">chi1</span><span class="p">,</span><span class="n">chi2</span><span class="p">),</span> <span class="n">mxstep</span><span class="o">=</span><span class="mi">5000000</span><span class="p">,</span> <span class="n">full_output</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">printmessg</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">rtol</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">,</span><span class="n">atol</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">)</span><span class="c">#,tcrit=sing)</span>

    <span class="c"># Unzip output</span>
    <span class="n">traxres</span><span class="o">=</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">res</span><span class="p">)</span>
    <span class="n">Lhx_fvals</span><span class="o">=</span><span class="n">traxres</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">Lhy_fvals</span><span class="o">=</span><span class="n">traxres</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">Lhz_fvals</span><span class="o">=</span><span class="n">traxres</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">S1hx_fvals</span><span class="o">=</span><span class="n">traxres</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">S1hy_fvals</span><span class="o">=</span><span class="n">traxres</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
    <span class="n">S1hz_fvals</span><span class="o">=</span><span class="n">traxres</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span>
    <span class="n">S2hx_fvals</span><span class="o">=</span><span class="n">traxres</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span>
    <span class="n">S2hy_fvals</span><span class="o">=</span><span class="n">traxres</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span>
    <span class="n">S2hz_fvals</span><span class="o">=</span><span class="n">traxres</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span>
    <span class="c">#t_fvals=traxres[9] # Uncomment if v(t) is needed</span>
    
    <span class="k">return</span> <span class="n">Lhx_fvals</span><span class="p">,</span><span class="n">Lhy_fvals</span><span class="p">,</span><span class="n">Lhz_fvals</span><span class="p">,</span><span class="n">S1hx_fvals</span><span class="p">,</span><span class="n">S1hy_fvals</span><span class="p">,</span><span class="n">S1hz_fvals</span><span class="p">,</span><span class="n">S2hx_fvals</span><span class="p">,</span><span class="n">S2hy_fvals</span><span class="p">,</span><span class="n">S2hz_fvals</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.orbit_angles">
    <p>def <span class="ident">orbit_angles</span>(</p><p>theta1_vals, theta2_vals, deltaphi_vals, r_vals, q_vals, S1_vals, S2_vals)</p>
    </div>
    

    
  
    <div class="desc"><p>Wrapper of <a href="#precession.orbav_integrator"><code>orbav_integrator</code></a> to enable parallelization through
the python parmap module; the number of available cores can be specified
using the integer global variable <code>precession.CPUs</code> (all available cores
will be used by default). Input/outputs are given in terms of the angles
theta1, theta2 and deltaphi. Evolve a sequence of binaries with the
different q, S1, S2 and initial values for the angles; save outputs at SAME
separations r_vals. Output is a 2D array, where e.g. theta1_vals[0] is the
first binary (1D array at all output separations) and theta1_vals[0][0] is
the first binary at the first output separation (this is a scalar).</p>
<p>Checkpointing is implemented: results are stored in <a href="#precession.storedir"><code>storedir</code></a>.</p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>theta1f_vals,theta2f_vals,deltaphif_vals=precession.orbit_angles(theta1i_vals,theta2i_vals,deltaphii_vals,r_vals,q_vals,S1_vals,S2_vals)
</pre></div>


<p><strong>Parameters:</strong></p>
<ul>
<li><code>theta1i_vals</code>: initial condition for theta1 (array).</li>
<li><code>theta2i_vals</code>: initial condition for theta2 (array).</li>
<li><code>deltaphii_vals</code>: initial condition for deltaphi (array).</li>
<li><code>r_vals</code>: binary separation (array).</li>
<li><code>q_vals</code>: binary mass ratio. Must be q&lt;=1 (array).</li>
<li><code>S1_vals</code>: spin magnitude of the primary BH (array).</li>
<li><code>S2_vals</code>: spin magnitude of the secondary BH (array).</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>theta1f_vals</code>: solutions for theta1 (2D array).</li>
<li><code>theta2f_vals</code>: solutions for theta2 (2D array).</li>
<li><code>deltaphif_vals</code>: solutions for deltaphi (2D array).</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.orbit_angles', this);">Show source &equiv;</a></p>
  <div id="source-precession.orbit_angles" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">orbit_angles</span><span class="p">(</span><span class="n">theta1_vals</span><span class="p">,</span><span class="n">theta2_vals</span><span class="p">,</span><span class="n">deltaphi_vals</span><span class="p">,</span><span class="n">r_vals</span><span class="p">,</span><span class="n">q_vals</span><span class="p">,</span><span class="n">S1_vals</span><span class="p">,</span><span class="n">S2_vals</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Wrapper of `precession.orbav_integrator` to enable parallelization through</span>
<span class="sd">    the python parmap module; the number of available cores can be specified</span>
<span class="sd">    using the integer global variable `precession.CPUs` (all available cores</span>
<span class="sd">    will be used by default). Input/outputs are given in terms of the angles</span>
<span class="sd">    theta1, theta2 and deltaphi. Evolve a sequence of binaries with the</span>
<span class="sd">    different q, S1, S2 and initial values for the angles; save outputs at SAME</span>
<span class="sd">    separations r_vals. Output is a 2D array, where e.g. theta1_vals[0] is the</span>
<span class="sd">    first binary (1D array at all output separations) and theta1_vals[0][0] is</span>
<span class="sd">    the first binary at the first output separation (this is a scalar).</span>

<span class="sd">    Checkpointing is implemented: results are stored in `precession.storedir`.</span>
<span class="sd"> </span>
<span class="sd">    **Call:**</span>

<span class="sd">        theta1f_vals,theta2f_vals,deltaphif_vals=precession.orbit_angles(theta1i_vals,theta2i_vals,deltaphii_vals,r_vals,q_vals,S1_vals,S2_vals)</span>
<span class="sd">         </span>
<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `theta1i_vals`: initial condition for theta1 (array).</span>
<span class="sd">    - `theta2i_vals`: initial condition for theta2 (array).</span>
<span class="sd">    - `deltaphii_vals`: initial condition for deltaphi (array).</span>
<span class="sd">    - `r_vals`: binary separation (array).</span>
<span class="sd">    - `q_vals`: binary mass ratio. Must be q&lt;=1 (array).</span>
<span class="sd">    - `S1_vals`: spin magnitude of the primary BH (array).</span>
<span class="sd">    - `S2_vals`: spin magnitude of the secondary BH (array).</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `theta1f_vals`: solutions for theta1 (2D array).</span>
<span class="sd">    - `theta2f_vals`: solutions for theta2 (2D array).</span>
<span class="sd">    - `deltaphif_vals`: solutions for deltaphi (2D array).</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">global</span> <span class="n">CPUs</span>
    <span class="n">flag</span><span class="o">=</span><span class="bp">False</span>

    <span class="k">try</span><span class="p">:</span> <span class="c">#Convert float to array, if you&#39;re evolving just one binary</span>
        <span class="nb">len</span><span class="p">(</span><span class="n">theta1_vals</span><span class="p">)</span>
        <span class="nb">len</span><span class="p">(</span><span class="n">theta1_vals</span><span class="p">)</span>
        <span class="nb">len</span><span class="p">(</span><span class="n">deltaphi_vals</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">flag</span><span class="o">=</span><span class="bp">True</span>
        <span class="n">theta1_vals</span><span class="o">=</span><span class="p">[</span><span class="n">theta1_vals</span><span class="p">]</span>
        <span class="n">theta2_vals</span><span class="o">=</span><span class="p">[</span><span class="n">theta2_vals</span><span class="p">]</span>
        <span class="n">deltaphi_vals</span><span class="o">=</span><span class="p">[</span><span class="n">deltaphi_vals</span><span class="p">]</span>
        <span class="n">q_vals</span><span class="o">=</span><span class="p">[</span><span class="n">q_vals</span><span class="p">]</span>
        <span class="n">S1_vals</span><span class="o">=</span><span class="p">[</span><span class="n">S1_vals</span><span class="p">]</span>
        <span class="n">S2_vals</span><span class="o">=</span><span class="p">[</span><span class="n">S2_vals</span><span class="p">]</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">CPUs</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">CPUs</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">print</span> <span class="s">&quot;[orbit_angles] Default parallel computation&quot;</span>

    <span class="n">loopflag</span><span class="o">=</span><span class="bp">True</span>
    <span class="k">while</span> <span class="n">loopflag</span><span class="p">:</span> <span class="c"># Restart is some of the cores crashed. This happend if you run too many things on too many different machines. Nevermind, trash the file and do it again.</span>
        <span class="n">loopflag</span><span class="o">=</span><span class="bp">False</span>

        <span class="c">#Parallelization... python is cool indeed</span>
        <span class="k">if</span> <span class="n">CPUs</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="c">#Run on all cpus on the current machine! (default option)</span>
            <span class="n">filelist</span><span class="o">=</span><span class="n">parmap</span><span class="o">.</span><span class="n">starmap</span><span class="p">(</span><span class="n">orbit_angles_single</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">theta1_vals</span><span class="p">,</span><span class="n">theta2_vals</span><span class="p">,</span><span class="n">deltaphi_vals</span><span class="p">,[</span><span class="n">r_vals</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q_vals</span><span class="p">))],</span><span class="n">q_vals</span><span class="p">,</span><span class="n">S1_vals</span><span class="p">,</span><span class="n">S2_vals</span><span class="p">),</span><span class="n">parallel</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> 
        <span class="k">elif</span> <span class="n">CPUs</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="c">#1 cpus done by explicitely removing parallelization</span>
            <span class="n">filelist</span><span class="o">=</span><span class="n">parmap</span><span class="o">.</span><span class="n">starmap</span><span class="p">(</span><span class="n">orbit_angles_single</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">theta1_vals</span><span class="p">,</span><span class="n">theta2_vals</span><span class="p">,</span><span class="n">deltaphi_vals</span><span class="p">,[</span><span class="n">r_vals</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q_vals</span><span class="p">))],</span><span class="n">q_vals</span><span class="p">,</span><span class="n">S1_vals</span><span class="p">,</span><span class="n">S2_vals</span><span class="p">),</span><span class="n">parallel</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> 
        <span class="k">else</span><span class="p">:</span> <span class="c"># Run on a given number of CPUs        </span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">CPUs</span><span class="p">)</span>
            <span class="n">filelist</span><span class="o">=</span><span class="n">parmap</span><span class="o">.</span><span class="n">starmap</span><span class="p">(</span><span class="n">orbit_angles_single</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">theta1_vals</span><span class="p">,</span><span class="n">theta2_vals</span><span class="p">,</span><span class="n">deltaphi_vals</span><span class="p">,[</span><span class="n">r_vals</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q_vals</span><span class="p">))],</span><span class="n">q_vals</span><span class="p">,</span><span class="n">S1_vals</span><span class="p">,</span><span class="n">S2_vals</span><span class="p">),</span><span class="n">pool</span><span class="o">=</span><span class="n">p</span><span class="p">)</span> 

        <span class="n">theta1_fvals</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">theta2_fvals</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">deltaphi_fvals</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="nb">file</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">filelist</span><span class="p">):</span>
            <span class="k">print</span> <span class="s">&quot;[orbit_angles] Reading:&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="nb">file</span>
            <span class="n">numlines</span><span class="o">=</span><span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">open</span><span class="p">(</span><span class="nb">file</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">numlines</span><span class="o">!=</span><span class="mi">0</span> <span class="ow">and</span> <span class="n">numlines</span><span class="o">!=</span><span class="nb">len</span><span class="p">(</span><span class="n">r_vals</span><span class="p">):</span> <span class="c"># Restar if core(s) crashed</span>
                <span class="k">print</span> <span class="s">&quot;[orbit_angles] Error on file&quot;</span><span class="p">,</span> <span class="nb">file</span><span class="p">,</span><span class="s">&quot;. Jobs are being restarting!!!&quot;</span>
                <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s">&quot;rm &quot;</span><span class="o">+</span><span class="nb">file</span><span class="p">)</span> 
                <span class="n">loopflag</span><span class="o">=</span><span class="bp">True</span>
 
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dummy</span><span class="p">,</span><span class="n">theta1_f</span><span class="p">,</span><span class="n">theta2_f</span><span class="p">,</span><span class="n">deltaphi_f</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="nb">file</span><span class="p">,</span><span class="n">unpack</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                <span class="n">theta1_fvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">theta1_f</span><span class="p">)</span>
                <span class="n">theta2_fvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">theta2_f</span><span class="p">)</span>
                <span class="n">deltaphi_fvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">deltaphi_f</span><span class="p">)</span>        
    <span class="k">if</span> <span class="n">flag</span><span class="o">==</span><span class="bp">True</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">theta1_fvals</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">theta2_fvals</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">deltaphi_fvals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">theta1_fvals</span><span class="p">,</span> <span class="n">theta2_fvals</span><span class="p">,</span> <span class="n">deltaphi_fvals</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.orbit_angles_single">
    <p>def <span class="ident">orbit_angles_single</span>(</p><p>theta1_i, theta2_i, deltaphi_i, r_vals, q, S1, S2)</p>
    </div>
    

    
  
    <div class="desc"><p>Auxiliary function, see <a href="#precession.orbit_angles"><code>orbit_angles</code></a>.</p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>savename=precession.orbit_angles_single(theta1_i,theta2_i,deltaphi_i,r_vals,q,S1,S2)
</pre></div>


<p><strong>Parameters:</strong></p>
<ul>
<li><code>theta1_i</code>: initial condition for theta1.</li>
<li><code>theta2_i</code>: initial condition for theta2</li>
<li><code>deltaphi_i</code>: initial condition for deltaphi.</li>
<li><code>r_vals</code>: binary separation (array).</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>savename</code>: checkpoint filename.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.orbit_angles_single', this);">Show source &equiv;</a></p>
  <div id="source-precession.orbit_angles_single" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">orbit_angles_single</span><span class="p">(</span><span class="n">theta1_i</span><span class="p">,</span><span class="n">theta2_i</span><span class="p">,</span><span class="n">deltaphi_i</span><span class="p">,</span><span class="n">r_vals</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Auxiliary function, see `precession.orbit_angles`.</span>
<span class="sd"> </span>
<span class="sd">    **Call:**</span>

<span class="sd">        savename=precession.orbit_angles_single(theta1_i,theta2_i,deltaphi_i,r_vals,q,S1,S2)</span>

<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `theta1_i`: initial condition for theta1.</span>
<span class="sd">    - `theta2_i`: initial condition for theta2</span>
<span class="sd">    - `deltaphi_i`: initial condition for deltaphi.</span>
<span class="sd">    - `r_vals`: binary separation (array).</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `savename`: checkpoint filename.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s">&quot;mkdir -p &quot;</span><span class="o">+</span><span class="n">storedir</span><span class="p">)</span> 
    <span class="n">savename</span><span class="o">=</span> <span class="n">storedir</span><span class="o">+</span><span class="s">&quot;/orbang_&quot;</span><span class="o">+</span><span class="s">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">(</span><span class="n">theta1_i</span><span class="p">,</span><span class="n">theta2_i</span><span class="p">,</span><span class="n">deltaphi_i</span><span class="p">,</span><span class="nb">max</span><span class="p">(</span><span class="n">r_vals</span><span class="p">),</span><span class="nb">min</span><span class="p">(</span><span class="n">r_vals</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">r_vals</span><span class="p">),</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">)])</span><span class="o">+</span><span class="s">&quot;.dat&quot;</span>
        
    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">savename</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">&quot;[orbit_angles] Transferring binary. Output:&quot;</span><span class="p">,</span> <span class="n">savename</span>
        <span class="n">outfilesave</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">savename</span><span class="p">,</span><span class="s">&quot;w&quot;</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
       
        <span class="c"># Step 1. Get xi and J for each intial angle. Keep S now</span>
        <span class="n">xi_i</span><span class="p">,</span><span class="n">J_i</span><span class="p">,</span><span class="n">S_i</span><span class="o">=</span> <span class="n">from_the_angles</span><span class="p">(</span><span class="n">theta1_i</span><span class="p">,</span><span class="n">theta2_i</span><span class="p">,</span><span class="n">deltaphi_i</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r_vals</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> 
        <span class="c"># Note that S_i is actually cos(varphi_i) when q=1. </span>
        
        <span class="c"># Step 2. Evolve ODE system</span>
        <span class="n">Lhx_fvals</span><span class="p">,</span><span class="n">Lhy_fvals</span><span class="p">,</span><span class="n">Lhz_fvals</span><span class="p">,</span><span class="n">S1hx_fvals</span><span class="p">,</span><span class="n">S1hy_fvals</span><span class="p">,</span><span class="n">S1hz_fvals</span><span class="p">,</span><span class="n">S2hx_fvals</span><span class="p">,</span><span class="n">S2hy_fvals</span><span class="p">,</span><span class="n">S2hz_fvals</span> <span class="o">=</span> <span class="n">orbav_integrator</span><span class="p">(</span><span class="n">J_i</span><span class="p">,</span><span class="n">xi_i</span><span class="p">,</span><span class="n">S_i</span><span class="p">,</span><span class="n">r_vals</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">)</span>
        
        <span class="k">for</span> <span class="n">r_f</span><span class="p">,</span><span class="n">Lhx</span><span class="p">,</span><span class="n">Lhy</span><span class="p">,</span><span class="n">Lhz</span><span class="p">,</span><span class="n">S1hx</span><span class="p">,</span><span class="n">S1hy</span><span class="p">,</span><span class="n">S1hz</span><span class="p">,</span><span class="n">S2hx</span><span class="p">,</span><span class="n">S2hy</span><span class="p">,</span><span class="n">S2hz</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">r_vals</span><span class="p">,</span><span class="n">Lhx_fvals</span><span class="p">,</span><span class="n">Lhy_fvals</span><span class="p">,</span><span class="n">Lhz_fvals</span><span class="p">,</span><span class="n">S1hx_fvals</span><span class="p">,</span><span class="n">S1hy_fvals</span><span class="p">,</span><span class="n">S1hz_fvals</span><span class="p">,</span><span class="n">S2hx_fvals</span><span class="p">,</span><span class="n">S2hy_fvals</span><span class="p">,</span><span class="n">S2hz_fvals</span><span class="p">):</span>        
            
            <span class="n">L_f</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r_f</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
            <span class="n">S_f</span><span class="o">=</span> <span class="p">((</span><span class="n">S1</span><span class="o">*</span><span class="n">S1hx</span><span class="o">+</span><span class="n">S2</span><span class="o">*</span><span class="n">S2hx</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">S1</span><span class="o">*</span><span class="n">S1hy</span><span class="o">+</span><span class="n">S2</span><span class="o">*</span><span class="n">S2hy</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">S1</span><span class="o">*</span><span class="n">S1hz</span><span class="o">+</span><span class="n">S2</span><span class="o">*</span><span class="n">S2hz</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="p">)</span><span class="o">**</span><span class="mf">0.5</span>
            <span class="n">J_f</span><span class="o">=</span> <span class="p">((</span><span class="n">L_f</span><span class="o">*</span><span class="n">Lhx</span><span class="o">+</span><span class="n">S1</span><span class="o">*</span><span class="n">S1hx</span><span class="o">+</span><span class="n">S2</span><span class="o">*</span><span class="n">S2hx</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">L_f</span><span class="o">*</span><span class="n">Lhy</span><span class="o">+</span><span class="n">S1</span><span class="o">*</span><span class="n">S1hy</span><span class="o">+</span><span class="n">S2</span><span class="o">*</span><span class="n">S2hy</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">L_f</span><span class="o">*</span><span class="n">Lhz</span><span class="o">+</span><span class="n">S1</span><span class="o">*</span><span class="n">S1hz</span><span class="o">+</span><span class="n">S2</span><span class="o">*</span><span class="n">S2hz</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="p">)</span><span class="o">**</span><span class="mf">0.5</span> 
            <span class="n">xi_f</span><span class="o">=</span> <span class="p">((</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">S1</span><span class="o">*</span><span class="p">(</span><span class="n">Lhx</span><span class="o">*</span><span class="n">S1hx</span><span class="o">+</span><span class="n">Lhy</span><span class="o">*</span><span class="n">S1hy</span><span class="o">+</span><span class="n">Lhz</span><span class="o">*</span><span class="n">S1hz</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="o">**-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">S2</span><span class="o">*</span><span class="p">(</span><span class="n">Lhx</span><span class="o">*</span><span class="n">S2hx</span><span class="o">+</span><span class="n">Lhy</span><span class="o">*</span><span class="n">S2hy</span><span class="o">+</span><span class="n">Lhz</span><span class="o">*</span><span class="n">S2hz</span><span class="p">))</span><span class="o">*</span><span class="n">M</span><span class="o">**-</span><span class="mi">2</span>
            <span class="k">if</span> <span class="n">q</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">A1</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">J_f</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">L_f</span><span class="o">-</span><span class="n">S_f</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">A2</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">L_f</span><span class="o">+</span><span class="n">S_f</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">J_f</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">A3</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">S_f</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">A4</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">S1</span><span class="o">+</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S_f</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>  
                <span class="n">cosvarphi</span> <span class="o">=</span> <span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">J_f</span><span class="o">*</span><span class="n">S_f</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">S1hz</span><span class="o">*</span><span class="n">S1</span><span class="o">-</span><span class="p">(</span><span class="n">S_f</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">S1</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">J_f</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L_f</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">S_f</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="n">A1</span><span class="o">*</span><span class="n">A2</span><span class="o">*</span><span class="n">A3</span><span class="o">*</span><span class="n">A4</span><span class="p">)</span>
                <span class="n">S_f</span><span class="o">=</span><span class="n">cosvarphi</span>

            <span class="c"># Step 3. Back to theta1, theta2, deltaphi</span>
            <span class="n">theta1_f</span><span class="p">,</span><span class="n">theta2_f</span><span class="p">,</span><span class="n">deltaphi_f</span><span class="p">,</span><span class="n">dummy</span><span class="o">=</span> <span class="n">parametric_angles</span><span class="p">(</span><span class="n">S_f</span><span class="p">,</span><span class="n">J_f</span><span class="p">,</span><span class="n">xi_f</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r_f</span><span class="p">)</span>
            
            <span class="c"># Step 4. Track the precessional phase to set the sign of DeltaPhi. In symbols, the sign of DeltaPhi must be the sign of</span>
            <span class="c">#L dot [ ( S1 - (S1 dot L) dot L ) cross ( S2 - (S2 dot L) dot L ) ]</span>
            <span class="n">S1px</span><span class="o">=</span><span class="p">(</span><span class="n">S1hx</span><span class="o">-</span><span class="n">theta1_f</span><span class="o">*</span><span class="n">Lhx</span><span class="p">)</span>
            <span class="n">S1py</span><span class="o">=</span><span class="p">(</span><span class="n">S1hy</span><span class="o">-</span><span class="n">theta1_f</span><span class="o">*</span><span class="n">Lhy</span><span class="p">)</span>
            <span class="n">S1pz</span><span class="o">=</span><span class="p">(</span><span class="n">S1hz</span><span class="o">-</span><span class="n">theta1_f</span><span class="o">*</span><span class="n">Lhz</span><span class="p">)</span>
            <span class="n">S2px</span><span class="o">=</span><span class="p">(</span><span class="n">S2hx</span><span class="o">-</span><span class="n">theta2_f</span><span class="o">*</span><span class="n">Lhx</span><span class="p">)</span>
            <span class="n">S2py</span><span class="o">=</span><span class="p">(</span><span class="n">S2hy</span><span class="o">-</span><span class="n">theta2_f</span><span class="o">*</span><span class="n">Lhy</span><span class="p">)</span>
            <span class="n">S2pz</span><span class="o">=</span><span class="p">(</span><span class="n">S2hz</span><span class="o">-</span><span class="n">theta2_f</span><span class="o">*</span><span class="n">Lhz</span><span class="p">)</span>
            <span class="n">proj</span><span class="o">=</span><span class="n">Lhx</span><span class="o">*</span><span class="p">(</span><span class="n">S1py</span><span class="o">*</span><span class="n">S2pz</span><span class="o">-</span><span class="n">S1pz</span><span class="o">*</span><span class="n">S2py</span><span class="p">)</span> <span class="o">+</span> <span class="n">Lhy</span><span class="o">*</span><span class="p">(</span><span class="n">S1pz</span><span class="o">*</span><span class="n">S2px</span><span class="o">-</span><span class="n">S1px</span><span class="o">*</span><span class="n">S2pz</span><span class="p">)</span> <span class="o">+</span> <span class="n">Lhz</span><span class="o">*</span><span class="p">(</span><span class="n">S1px</span><span class="o">*</span><span class="n">S2py</span><span class="o">-</span><span class="n">S1py</span><span class="o">*</span><span class="n">S2px</span><span class="p">)</span>
            <span class="n">deltaphi_f</span><span class="o">*=</span><span class="n">math</span><span class="o">.</span><span class="n">copysign</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="n">proj</span><span class="p">)</span>

            <span class="c"># Step 4. Store data            </span>
            <span class="n">outfilesave</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">r_f</span><span class="p">)</span><span class="o">+</span><span class="s">&quot; &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">theta1_f</span><span class="p">)</span><span class="o">+</span><span class="s">&quot; &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">theta2_f</span><span class="p">)</span><span class="o">+</span><span class="s">&quot; &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">deltaphi_f</span><span class="p">)</span><span class="o">+</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
        <span class="n">outfilesave</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="c">#else:</span>
    <span class="c">#    print &quot;[evolve_angles] Skipping. Output:&quot;, savename</span>
    
    <span class="k">return</span> <span class="n">savename</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.orbit_averaged">
    <p>def <span class="ident">orbit_averaged</span>(</p><p>J_vals, xi_vals, S_vals, r_vals, q_vals, S1_vals, S2_vals)</p>
    </div>
    

    
  
    <div class="desc"><p>Wrapper of <a href="#precession.orbav_integrator"><code>orbav_integrator</code></a> to enable parallelization through
the python parmap module; the number of available cores can be specified
using the integer global variable <code>precession.CPUs</code> (all available cores
will be used by default). Input/outputs are given in terms of J, xi and S.
Evolve a sequence of binaries with the different q, S1,S2, xi and initial
values of J and S; save outputs at the SAME separations r_vals. The initial
configuration must be compatible with r_vals[0]. Output is a 2D array, where
e.g. J_vals[0] is the first binary (1D array at all output separations) and
J_vals[0][0] is the first binary at the first output separation (this is a
scalar).</p>
<p>Checkpointing is implemented: results are stored in <a href="#precession.storedir"><code>storedir</code></a>.</p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>Jf_vals,xif_vals,Sf_vals=precession.orbit_averaged(J_vals,xi_vals,S_vals,r_vals,q,S1,S2)
</pre></div>


<p><strong>Parameters:</strong></p>
<ul>
<li><code>Ji_vals</code>: initial condition for J (array).</li>
<li><code>xii_vals</code>: initial condition for xi (array).</li>
<li><code>Si_vals</code>: initial condition for S (array).</li>
<li><code>r_vals</code>: binary separation (array).</li>
<li><code>q_vals</code>: binary mass ratio. Must be q&lt;=1 (array).</li>
<li><code>S1_vals</code>: spin magnitude of the primary BH (array).</li>
<li><code>S2_vals</code>: spin magnitude of the secondary BH (array).</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>Jf_vals</code>: solutions for J (2D array).</li>
<li><code>xif_vals</code>: solutions for xi (2D array).</li>
<li><code>Sf_vals</code>: solutions for S (2D array).</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.orbit_averaged', this);">Show source &equiv;</a></p>
  <div id="source-precession.orbit_averaged" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">orbit_averaged</span><span class="p">(</span><span class="n">J_vals</span><span class="p">,</span><span class="n">xi_vals</span><span class="p">,</span><span class="n">S_vals</span><span class="p">,</span><span class="n">r_vals</span><span class="p">,</span><span class="n">q_vals</span><span class="p">,</span><span class="n">S1_vals</span><span class="p">,</span><span class="n">S2_vals</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Wrapper of `precession.orbav_integrator` to enable parallelization through</span>
<span class="sd">    the python parmap module; the number of available cores can be specified</span>
<span class="sd">    using the integer global variable `precession.CPUs` (all available cores</span>
<span class="sd">    will be used by default). Input/outputs are given in terms of J, xi and S.</span>
<span class="sd">    Evolve a sequence of binaries with the different q, S1,S2, xi and initial</span>
<span class="sd">    values of J and S; save outputs at the SAME separations r_vals. The initial</span>
<span class="sd">    configuration must be compatible with r_vals[0]. Output is a 2D array, where</span>
<span class="sd">    e.g. J_vals[0] is the first binary (1D array at all output separations) and</span>
<span class="sd">    J_vals[0][0] is the first binary at the first output separation (this is a</span>
<span class="sd">    scalar).</span>

<span class="sd">    Checkpointing is implemented: results are stored in `precession.storedir`.</span>
<span class="sd"> </span>
<span class="sd">    **Call:**</span>

<span class="sd">        Jf_vals,xif_vals,Sf_vals=precession.orbit_averaged(J_vals,xi_vals,S_vals,r_vals,q,S1,S2)</span>

<span class="sd">    **Parameters:**</span>

<span class="sd">    - `Ji_vals`: initial condition for J (array).</span>
<span class="sd">    - `xii_vals`: initial condition for xi (array).</span>
<span class="sd">    - `Si_vals`: initial condition for S (array).</span>
<span class="sd">    - `r_vals`: binary separation (array).</span>
<span class="sd">    - `q_vals`: binary mass ratio. Must be q&lt;=1 (array).</span>
<span class="sd">    - `S1_vals`: spin magnitude of the primary BH (array).</span>
<span class="sd">    - `S2_vals`: spin magnitude of the secondary BH (array).</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `Jf_vals`: solutions for J (2D array).</span>
<span class="sd">    - `xif_vals`: solutions for xi (2D array).</span>
<span class="sd">    - `Sf_vals`: solutions for S (2D array).</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="k">global</span> <span class="n">CPUs</span>
    
    <span class="n">single_flag</span><span class="o">=</span><span class="bp">False</span>
    <span class="k">try</span><span class="p">:</span> <span class="c">#Convert float to array if you&#39;re evolving just one binary</span>
        <span class="nb">len</span><span class="p">(</span><span class="n">q_vals</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">J_vals</span><span class="o">=</span><span class="p">[</span><span class="n">J_vals</span><span class="p">]</span>
        <span class="n">xi_vals</span><span class="o">=</span><span class="p">[</span><span class="n">xi_vals</span><span class="p">]</span>
        <span class="n">S_vals</span><span class="o">=</span><span class="p">[</span><span class="n">S_vals</span><span class="p">]</span>
        <span class="n">q_vals</span><span class="o">=</span><span class="p">[</span><span class="n">q_vals</span><span class="p">]</span>
        <span class="n">S1_vals</span><span class="o">=</span><span class="p">[</span><span class="n">S1_vals</span><span class="p">]</span>
        <span class="n">S2_vals</span><span class="o">=</span><span class="p">[</span><span class="n">S2_vals</span><span class="p">]</span>
        <span class="n">single_flag</span><span class="o">=</span><span class="bp">True</span>
    <span class="k">try</span><span class="p">:</span> <span class="c"># Set default</span>
        <span class="n">CPUs</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">CPUs</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">print</span> <span class="s">&quot;[orbit_averaged] Default parallel computation&quot;</span>
    
    <span class="c"># Parallelization</span>
    <span class="k">if</span> <span class="n">CPUs</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="c"># Run on all cpus on the current machine! (default option)</span>
        <span class="n">filelist</span><span class="o">=</span><span class="n">parmap</span><span class="o">.</span><span class="n">starmap</span><span class="p">(</span><span class="n">orbit_averaged_single</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">J_vals</span><span class="p">,</span><span class="n">xi_vals</span><span class="p">,</span><span class="n">S_vals</span><span class="p">,[</span><span class="n">r_vals</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q_vals</span><span class="p">))],</span><span class="n">q_vals</span><span class="p">,</span><span class="n">S1_vals</span><span class="p">,</span><span class="n">S2_vals</span><span class="p">),</span><span class="n">parallel</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> 
    <span class="k">elif</span> <span class="n">CPUs</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="c"># 1 cpus done by explicitely removing parallelization</span>
        <span class="n">filelist</span><span class="o">=</span><span class="n">parmap</span><span class="o">.</span><span class="n">starmap</span><span class="p">(</span><span class="n">orbit_averaged_single</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">J_vals</span><span class="p">,</span><span class="n">xi_vals</span><span class="p">,</span><span class="n">S_vals</span><span class="p">,[</span><span class="n">r_vals</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q_vals</span><span class="p">))],</span><span class="n">q_vals</span><span class="p">,</span><span class="n">S1_vals</span><span class="p">,</span><span class="n">S2_vals</span><span class="p">),</span><span class="n">parallel</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> 
    <span class="k">else</span><span class="p">:</span> <span class="c"># Run on a given number of CPUs        </span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">CPUs</span><span class="p">)</span>
        <span class="n">filelist</span><span class="o">=</span><span class="n">parmap</span><span class="o">.</span><span class="n">starmap</span><span class="p">(</span><span class="n">orbit_averaged_single</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">J_vals</span><span class="p">,</span><span class="n">xi_vals</span><span class="p">,</span><span class="n">S_vals</span><span class="p">,[</span><span class="n">r_vals</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q_vals</span><span class="p">))],</span><span class="n">q_vals</span><span class="p">,</span><span class="n">S1_vals</span><span class="p">,</span><span class="n">S2_vals</span><span class="p">),</span><span class="n">pool</span><span class="o">=</span><span class="n">p</span><span class="p">)</span> 

    <span class="n">J_fvals</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">S_fvals</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">xi_vals</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="nb">file</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">filelist</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">&quot;[orbit_averaged] Reading:&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="nb">file</span>
        <span class="n">dummy</span><span class="p">,</span><span class="n">J_f</span><span class="p">,</span><span class="n">xi_f</span><span class="p">,</span><span class="n">S_f</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="nb">file</span><span class="p">,</span><span class="n">unpack</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">J_fvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">J_f</span><span class="p">)</span>
        <span class="n">xi_vals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xi_f</span><span class="p">)</span>
        <span class="n">S_fvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">S_f</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">single_flag</span><span class="o">==</span><span class="bp">True</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">J_fvals</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">xi_vals</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">S_fvals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">J_fvals</span><span class="p">,</span> <span class="n">xi_vals</span><span class="p">,</span> <span class="n">S_fvals</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.orbit_averaged_single">
    <p>def <span class="ident">orbit_averaged_single</span>(</p><p>J, xi, S, r_vals, q, S1, S2)</p>
    </div>
    

    
  
    <div class="desc"><p>Auxiliary function, see <a href="#precession.orbit_averaged"><code>orbit_averaged</code></a>.</p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>savename=precession.orbit_averaged_single(J,xi,S,r_vals,q,S1,S2)
</pre></div>


<p><strong>Parameters:</strong></p>
<ul>
<li><code>J</code>: magnitude of the total angular momentum.</li>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>S</code>: magnitude of the total spin.</li>
<li><code>r_vals</code>: binary separation (array).</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>savename</code>: checkpoint filename.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.orbit_averaged_single', this);">Show source &equiv;</a></p>
  <div id="source-precession.orbit_averaged_single" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">orbit_averaged_single</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">r_vals</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Auxiliary function, see `precession.orbit_averaged`.</span>
<span class="sd"> </span>
<span class="sd">    **Call:**</span>

<span class="sd">        savename=precession.orbit_averaged_single(J,xi,S,r_vals,q,S1,S2)</span>

<span class="sd">    **Parameters:**</span>

<span class="sd">    - `J`: magnitude of the total angular momentum.</span>
<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `S`: magnitude of the total spin.</span>
<span class="sd">    - `r_vals`: binary separation (array).</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `savename`: checkpoint filename.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="k">global</span> <span class="n">flags_q1</span> 
    <span class="k">if</span> <span class="n">q</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">flags_q1</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span><span class="o">==</span><span class="bp">False</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;[orbit_averaged] Warning q=1: Input/output for S is actually cos(varphi)&quot;</span>       
            <span class="n">flags_q1</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span><span class="o">=</span><span class="bp">True</span>
    
    <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s">&quot;mkdir -p &quot;</span><span class="o">+</span><span class="n">storedir</span><span class="p">)</span> 
    <span class="n">savename</span><span class="o">=</span> <span class="n">storedir</span><span class="o">+</span><span class="s">&quot;/orbav_&quot;</span><span class="o">+</span><span class="s">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="nb">max</span><span class="p">(</span><span class="n">r_vals</span><span class="p">),</span><span class="nb">min</span><span class="p">(</span><span class="n">r_vals</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">r_vals</span><span class="p">),</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">)])</span><span class="o">+</span><span class="s">&quot;.dat&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">savename</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">&quot;[orbit_averaged] Transferring binary. Output:&quot;</span><span class="p">,</span> <span class="n">savename</span>
        <span class="n">outfilesave</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">savename</span><span class="p">,</span><span class="s">&quot;w&quot;</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">Lhx_fvals</span><span class="p">,</span><span class="n">Lhy_fvals</span><span class="p">,</span><span class="n">Lhz_fvals</span><span class="p">,</span><span class="n">S1hx_fvals</span><span class="p">,</span><span class="n">S1hy_fvals</span><span class="p">,</span><span class="n">S1hz_fvals</span><span class="p">,</span><span class="n">S2hx_fvals</span><span class="p">,</span><span class="n">S2hy_fvals</span><span class="p">,</span><span class="n">S2hz_fvals</span> <span class="o">=</span> <span class="n">orbav_integrator</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">r_vals</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">r_f</span><span class="p">,</span><span class="n">Lhx</span><span class="p">,</span><span class="n">Lhy</span><span class="p">,</span><span class="n">Lhz</span><span class="p">,</span><span class="n">S1hx</span><span class="p">,</span><span class="n">S1hy</span><span class="p">,</span><span class="n">S1hz</span><span class="p">,</span><span class="n">S2hx</span><span class="p">,</span><span class="n">S2hy</span><span class="p">,</span><span class="n">S2hz</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">r_vals</span><span class="p">,</span><span class="n">Lhx_fvals</span><span class="p">,</span><span class="n">Lhy_fvals</span><span class="p">,</span><span class="n">Lhz_fvals</span><span class="p">,</span><span class="n">S1hx_fvals</span><span class="p">,</span><span class="n">S1hy_fvals</span><span class="p">,</span><span class="n">S1hz_fvals</span><span class="p">,</span><span class="n">S2hx_fvals</span><span class="p">,</span><span class="n">S2hy_fvals</span><span class="p">,</span><span class="n">S2hz_fvals</span><span class="p">):</span>        
            
            <span class="n">L_f</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r_f</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
            <span class="n">J_f</span><span class="o">=</span> <span class="p">((</span><span class="n">L_f</span><span class="o">*</span><span class="n">Lhx</span><span class="o">+</span><span class="n">S1</span><span class="o">*</span><span class="n">S1hx</span><span class="o">+</span><span class="n">S2</span><span class="o">*</span><span class="n">S2hx</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">L_f</span><span class="o">*</span><span class="n">Lhy</span><span class="o">+</span><span class="n">S1</span><span class="o">*</span><span class="n">S1hy</span><span class="o">+</span><span class="n">S2</span><span class="o">*</span><span class="n">S2hy</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">L_f</span><span class="o">*</span><span class="n">Lhz</span><span class="o">+</span><span class="n">S1</span><span class="o">*</span><span class="n">S1hz</span><span class="o">+</span><span class="n">S2</span><span class="o">*</span><span class="n">S2hz</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="p">)</span><span class="o">**</span><span class="mf">0.5</span> 
            <span class="n">xi_f</span><span class="o">=</span> <span class="p">((</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">S1</span><span class="o">*</span><span class="p">(</span><span class="n">Lhx</span><span class="o">*</span><span class="n">S1hx</span><span class="o">+</span><span class="n">Lhy</span><span class="o">*</span><span class="n">S1hy</span><span class="o">+</span><span class="n">Lhz</span><span class="o">*</span><span class="n">S1hz</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="o">**-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">S2</span><span class="o">*</span><span class="p">(</span><span class="n">Lhx</span><span class="o">*</span><span class="n">S2hx</span><span class="o">+</span><span class="n">Lhy</span><span class="o">*</span><span class="n">S2hy</span><span class="o">+</span><span class="n">Lhz</span><span class="o">*</span><span class="n">S2hz</span><span class="p">))</span><span class="o">*</span><span class="n">M</span><span class="o">**-</span><span class="mi">2</span>
            <span class="n">S_f</span><span class="o">=</span> <span class="p">((</span><span class="n">S1</span><span class="o">*</span><span class="n">S1hx</span><span class="o">+</span><span class="n">S2</span><span class="o">*</span><span class="n">S2hx</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">S1</span><span class="o">*</span><span class="n">S1hy</span><span class="o">+</span><span class="n">S2</span><span class="o">*</span><span class="n">S2hy</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">S1</span><span class="o">*</span><span class="n">S1hz</span><span class="o">+</span><span class="n">S2</span><span class="o">*</span><span class="n">S2hz</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="p">)</span><span class="o">**</span><span class="mf">0.5</span>
            
            <span class="k">if</span> <span class="n">q</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">A1</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">J_f</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">L_f</span><span class="o">-</span><span class="n">S_f</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">A2</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">L_f</span><span class="o">+</span><span class="n">S_f</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">J_f</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">A3</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">S_f</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">A4</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">S1</span><span class="o">+</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S_f</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> 
                <span class="n">cosvarphi</span> <span class="o">=</span> <span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">J_f</span><span class="o">*</span><span class="n">S_f</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">S1hz</span><span class="o">*</span><span class="n">S1</span><span class="o">-</span><span class="p">(</span><span class="n">S_f</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">S1</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">J_f</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L_f</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">S_f</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="n">A1</span><span class="o">*</span><span class="n">A2</span><span class="o">*</span><span class="n">A3</span><span class="o">*</span><span class="n">A4</span><span class="p">)</span>
                <span class="n">S_f</span><span class="o">=</span><span class="n">cosvarphi</span>
                
            <span class="n">outfilesave</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">r_f</span><span class="p">)</span><span class="o">+</span><span class="s">&quot; &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">J_f</span><span class="p">)</span><span class="o">+</span><span class="s">&quot; &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">xi_f</span><span class="p">)</span><span class="o">+</span><span class="s">&quot; &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">S_f</span><span class="p">)</span><span class="o">+</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
        <span class="n">outfilesave</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="c">#else:</span>
    <span class="c">#    print &quot;[evolve_J_infinity] Skipping. Output:&quot;, savename</span>
    
    <span class="k">return</span> <span class="n">savename</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.orbit_vectors">
    <p>def <span class="ident">orbit_vectors</span>(</p><p>J_vals, xi_vals, S_vals, r_vals, q_vals, S1_vals, S2_vals)</p>
    </div>
    

    
  
    <div class="desc"><p>Wrapper of <a href="#precession.orbav_integrator"><code>orbav_integrator</code></a> to enable parallelization through
the python parmap module; the number of available cores can be specified
using the integer global variable <code>precession.CPUs</code> (all available cores
will be used by default). Input are given in terms of J, xi and S; outputs
are projected on a reference frame such that Jx=Jy=Ly=0 at the initial
separation (cf. <a href="#precession.Jframe_projection"><code>Jframe_projection</code></a>). Vectors, not unit vectros!,
are returned. Evolve a sequence of binaries with the different q, S1, S2, xi
and initial values of J and S; save outputs at SAME separations r_vals. The
initial configuration must be compatible with r_vals[0]. Output is a 2D
array, where e.g. J_vals[0] is the first binary (1D array at all output
separations) and J_vals[0][0] is the first binary at the first output
separation (this is a scalar).</p>
<p>Checkpointing is implemented: results are stored in <a href="#precession.storedir"><code>storedir</code></a>.</p>
<p><strong>Call:</strong>
    Lx_fvals,Ly_fvals,Lz_fvals,S1x_fvals,S1y_fvals,S1z_fvals,S2x_fvals,S2y_fvals,S2z_fvals=precession.orbit_vectors(J_vals,xi_vals,S_vals,r_vals,S1_vals,S2_vals)</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>Ji_vals</code>: initial condition for J (array).</li>
<li><code>xii_vals</code>: initial condition for xi (array).</li>
<li><code>Si_vals</code>: initial condition for S (array).</li>
<li><code>r_vals</code>: binary separation (array).</li>
<li><code>q_vals</code>: binary mass ratio. Must be q&lt;=1 (array).</li>
<li><code>S1_vals</code>: spin magnitude of the primary BH (array).</li>
<li><code>S2_vals</code>: spin magnitude of the secondary BH (array).</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>Lx_fvals</code>: x component of the vector L.</li>
<li><code>Ly_fvals</code>: y component of the vector L.</li>
<li><code>Lz_fvals</code>: z component of the vector L.</li>
<li><code>S1x_fvals</code>: x component of the vector S1.</li>
<li><code>S1y_fvals</code>: y component of the vector S1.</li>
<li><code>S1z_fvals</code>: z component of the vector S1.</li>
<li><code>S2x_fvals</code>: x component of the vector S2.</li>
<li><code>S2y_fvals</code>: y component of the vector S2.</li>
<li><code>S2z_fvals</code>: z component of the vector S2.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.orbit_vectors', this);">Show source &equiv;</a></p>
  <div id="source-precession.orbit_vectors" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">orbit_vectors</span><span class="p">(</span><span class="n">J_vals</span><span class="p">,</span><span class="n">xi_vals</span><span class="p">,</span><span class="n">S_vals</span><span class="p">,</span><span class="n">r_vals</span><span class="p">,</span><span class="n">q_vals</span><span class="p">,</span><span class="n">S1_vals</span><span class="p">,</span><span class="n">S2_vals</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Wrapper of `precession.orbav_integrator` to enable parallelization through</span>
<span class="sd">    the python parmap module; the number of available cores can be specified</span>
<span class="sd">    using the integer global variable `precession.CPUs` (all available cores</span>
<span class="sd">    will be used by default). Input are given in terms of J, xi and S; outputs</span>
<span class="sd">    are projected on a reference frame such that Jx=Jy=Ly=0 at the initial</span>
<span class="sd">    separation (cf. `precession.Jframe_projection`). Vectors, not unit vectros!,</span>
<span class="sd">    are returned. Evolve a sequence of binaries with the different q, S1, S2, xi</span>
<span class="sd">    and initial values of J and S; save outputs at SAME separations r_vals. The</span>
<span class="sd">    initial configuration must be compatible with r_vals[0]. Output is a 2D</span>
<span class="sd">    array, where e.g. J_vals[0] is the first binary (1D array at all output</span>
<span class="sd">    separations) and J_vals[0][0] is the first binary at the first output</span>
<span class="sd">    separation (this is a scalar).</span>

<span class="sd">    Checkpointing is implemented: results are stored in `precession.storedir`.</span>
<span class="sd"> </span>
<span class="sd">    **Call:**</span>
<span class="sd">        Lx_fvals,Ly_fvals,Lz_fvals,S1x_fvals,S1y_fvals,S1z_fvals,S2x_fvals,S2y_fvals,S2z_fvals=precession.orbit_vectors(J_vals,xi_vals,S_vals,r_vals,S1_vals,S2_vals)</span>

<span class="sd">    **Parameters:**</span>

<span class="sd">    - `Ji_vals`: initial condition for J (array).</span>
<span class="sd">    - `xii_vals`: initial condition for xi (array).</span>
<span class="sd">    - `Si_vals`: initial condition for S (array).</span>
<span class="sd">    - `r_vals`: binary separation (array).</span>
<span class="sd">    - `q_vals`: binary mass ratio. Must be q&lt;=1 (array).</span>
<span class="sd">    - `S1_vals`: spin magnitude of the primary BH (array).</span>
<span class="sd">    - `S2_vals`: spin magnitude of the secondary BH (array).</span>

<span class="sd">    **Returns:**</span>
<span class="sd">    </span>
<span class="sd">    - `Lx_fvals`: x component of the vector L.</span>
<span class="sd">    - `Ly_fvals`: y component of the vector L.</span>
<span class="sd">    - `Lz_fvals`: z component of the vector L.</span>
<span class="sd">    - `S1x_fvals`: x component of the vector S1.</span>
<span class="sd">    - `S1y_fvals`: y component of the vector S1.</span>
<span class="sd">    - `S1z_fvals`: z component of the vector S1.</span>
<span class="sd">    - `S2x_fvals`: x component of the vector S2.</span>
<span class="sd">    - `S2y_fvals`: y component of the vector S2.</span>
<span class="sd">    - `S2z_fvals`: z component of the vector S2.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="k">global</span> <span class="n">CPUs</span>
    
    <span class="n">single_flag</span><span class="o">=</span><span class="bp">False</span>
    <span class="k">try</span><span class="p">:</span> <span class="c">#Convert float to array if you&#39;re evolving just one binary</span>
        <span class="nb">len</span><span class="p">(</span><span class="n">q_vals</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">J_vals</span><span class="o">=</span><span class="p">[</span><span class="n">J_vals</span><span class="p">]</span>
        <span class="n">xi_vals</span><span class="o">=</span><span class="p">[</span><span class="n">xi_vals</span><span class="p">]</span>
        <span class="n">S_vals</span><span class="o">=</span><span class="p">[</span><span class="n">S_vals</span><span class="p">]</span>
        <span class="n">q_vals</span><span class="o">=</span><span class="p">[</span><span class="n">q_vals</span><span class="p">]</span>
        <span class="n">S1_vals</span><span class="o">=</span><span class="p">[</span><span class="n">S1_vals</span><span class="p">]</span>
        <span class="n">S2_vals</span><span class="o">=</span><span class="p">[</span><span class="n">S2_vals</span><span class="p">]</span>
        <span class="n">single_flag</span><span class="o">=</span><span class="bp">True</span>
    <span class="k">try</span><span class="p">:</span> <span class="c"># Set default</span>
        <span class="n">CPUs</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">CPUs</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">print</span> <span class="s">&quot;[orbit_vectors] Default parallel computation&quot;</span>
    
    <span class="c"># Parallelization</span>
    <span class="k">if</span> <span class="n">CPUs</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="c"># Run on all cpus on the current machine! (default option)</span>
        <span class="n">filelist</span><span class="o">=</span><span class="n">parmap</span><span class="o">.</span><span class="n">starmap</span><span class="p">(</span><span class="n">orbit_vectors_single</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">J_vals</span><span class="p">,</span><span class="n">xi_vals</span><span class="p">,</span><span class="n">S_vals</span><span class="p">,[</span><span class="n">r_vals</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q_vals</span><span class="p">))],</span><span class="n">q_vals</span><span class="p">,</span><span class="n">S1_vals</span><span class="p">,</span><span class="n">S2_vals</span><span class="p">),</span><span class="n">parallel</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> 
    <span class="k">elif</span> <span class="n">CPUs</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="c"># 1 cpus done by explicitely removing parallelization</span>
        <span class="n">filelist</span><span class="o">=</span><span class="n">parmap</span><span class="o">.</span><span class="n">starmap</span><span class="p">(</span><span class="n">orbit_vectors_single</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">J_vals</span><span class="p">,</span><span class="n">xi_vals</span><span class="p">,</span><span class="n">S_vals</span><span class="p">,[</span><span class="n">r_vals</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q_vals</span><span class="p">))],</span><span class="n">q_vals</span><span class="p">,</span><span class="n">S1_vals</span><span class="p">,</span><span class="n">S2_vals</span><span class="p">),</span><span class="n">parallel</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> 
    <span class="k">else</span><span class="p">:</span> <span class="c"># Run on a given number of CPUs        </span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">multiprocessing</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">CPUs</span><span class="p">)</span>
        <span class="n">filelist</span><span class="o">=</span><span class="n">parmap</span><span class="o">.</span><span class="n">starmap</span><span class="p">(</span><span class="n">orbit_vectors_single</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">J_vals</span><span class="p">,</span><span class="n">xi_vals</span><span class="p">,</span><span class="n">S_vals</span><span class="p">,[</span><span class="n">r_vals</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">q_vals</span><span class="p">))],</span><span class="n">q_vals</span><span class="p">,</span><span class="n">S1_vals</span><span class="p">,</span><span class="n">S2_vals</span><span class="p">),</span><span class="n">pool</span><span class="o">=</span><span class="n">p</span><span class="p">)</span> 

    <span class="n">Lx_fvals</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">Ly_fvals</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">Lz_fvals</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">S1x_fvals</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">S1y_fvals</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">S1z_fvals</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">S2x_fvals</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">S2y_fvals</span><span class="o">=</span><span class="p">[]</span>
    <span class="n">S2z_fvals</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="nb">file</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">filelist</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">&quot;[orbit_vectors] Reading:&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="nb">file</span>
        <span class="n">dummy</span><span class="p">,</span><span class="n">Lx</span><span class="p">,</span><span class="n">Ly</span><span class="p">,</span><span class="n">Lz</span><span class="p">,</span><span class="n">S1x</span><span class="p">,</span><span class="n">S1y</span><span class="p">,</span><span class="n">S1z</span><span class="p">,</span><span class="n">S2x</span><span class="p">,</span><span class="n">S2y</span><span class="p">,</span><span class="n">S2z</span><span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="nb">file</span><span class="p">,</span><span class="n">unpack</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">Lx_fvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Lx</span><span class="p">)</span>
        <span class="n">Ly_fvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Ly</span><span class="p">)</span>
        <span class="n">Lz_fvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Lz</span><span class="p">)</span>
        <span class="n">S1x_fvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">S1x</span><span class="p">)</span>
        <span class="n">S1y_fvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">S1y</span><span class="p">)</span>
        <span class="n">S1z_fvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">S1z</span><span class="p">)</span>
        <span class="n">S2x_fvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">S2x</span><span class="p">)</span>
        <span class="n">S2y_fvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">S2y</span><span class="p">)</span>
        <span class="n">S2z_fvals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">S2z</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">single_flag</span><span class="o">==</span><span class="bp">True</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Lx_fvals</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Ly_fvals</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Lz_fvals</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">S1x_fvals</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">S1y_fvals</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">S1z_fvals</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">S2x_fvals</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">S2y_fvals</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">S2z_fvals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>        
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Lx_fvals</span><span class="p">,</span> <span class="n">Ly_fvals</span><span class="p">,</span> <span class="n">Lz_fvals</span><span class="p">,</span> <span class="n">S1x_fvals</span><span class="p">,</span> <span class="n">S1y_fvals</span><span class="p">,</span> <span class="n">S1z_fvals</span><span class="p">,</span> <span class="n">S2x_fvals</span><span class="p">,</span> <span class="n">S2y_fvals</span><span class="p">,</span> <span class="n">S2z_fvals</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.orbit_vectors_single">
    <p>def <span class="ident">orbit_vectors_single</span>(</p><p>J, xi, S, r_vals, q, S1, S2)</p>
    </div>
    

    
  
    <div class="desc"><p>Auxiliary function, see <code>precession.orbit_vector</code>.</p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>savename=precession.orbit_vectors_single(J,xi,S,r_vals,q,S1,S2)
</pre></div>


<p><strong>Parameters:</strong></p>
<ul>
<li><code>J</code>: magnitude of the total angular momentum.</li>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>S</code>: magnitude of the total spin.</li>
<li><code>r_vals</code>: binary separation (array).</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>savename</code>: checkpoint filename.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.orbit_vectors_single', this);">Show source &equiv;</a></p>
  <div id="source-precession.orbit_vectors_single" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">orbit_vectors_single</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">r_vals</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Auxiliary function, see `precession.orbit_vector`.</span>
<span class="sd"> </span>
<span class="sd">    **Call:**</span>

<span class="sd">        savename=precession.orbit_vectors_single(J,xi,S,r_vals,q,S1,S2)</span>

<span class="sd">    **Parameters:**</span>

<span class="sd">    - `J`: magnitude of the total angular momentum.</span>
<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `S`: magnitude of the total spin.</span>
<span class="sd">    - `r_vals`: binary separation (array).</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `savename`: checkpoint filename.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="n">os</span><span class="o">.</span><span class="n">system</span><span class="p">(</span><span class="s">&quot;mkdir -p &quot;</span><span class="o">+</span><span class="n">storedir</span><span class="p">)</span> 
    <span class="n">savename</span><span class="o">=</span> <span class="n">storedir</span><span class="o">+</span><span class="s">&quot;/orbvec_&quot;</span><span class="o">+</span><span class="s">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="nb">max</span><span class="p">(</span><span class="n">r_vals</span><span class="p">),</span><span class="nb">min</span><span class="p">(</span><span class="n">r_vals</span><span class="p">),</span><span class="nb">len</span><span class="p">(</span><span class="n">r_vals</span><span class="p">),</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">)])</span><span class="o">+</span><span class="s">&quot;.dat&quot;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">savename</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">&quot;[orbit_vectors] Transferring binary. Output:&quot;</span><span class="p">,</span> <span class="n">savename</span>
        <span class="n">outfilesave</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">savename</span><span class="p">,</span><span class="s">&quot;w&quot;</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
       
        <span class="n">Lhx_fvals</span><span class="p">,</span><span class="n">Lhy_fvals</span><span class="p">,</span><span class="n">Lhz_fvals</span><span class="p">,</span><span class="n">S1hx_fvals</span><span class="p">,</span><span class="n">S1hy_fvals</span><span class="p">,</span><span class="n">S1hz_fvals</span><span class="p">,</span><span class="n">S2hx_fvals</span><span class="p">,</span><span class="n">S2hy_fvals</span><span class="p">,</span><span class="n">S2hz_fvals</span> <span class="o">=</span> <span class="n">orbav_integrator</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">r_vals</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">r_f</span><span class="p">,</span><span class="n">Lhx</span><span class="p">,</span><span class="n">Lhy</span><span class="p">,</span><span class="n">Lhz</span><span class="p">,</span><span class="n">S1hx</span><span class="p">,</span><span class="n">S1hy</span><span class="p">,</span><span class="n">S1hz</span><span class="p">,</span><span class="n">S2hx</span><span class="p">,</span><span class="n">S2hy</span><span class="p">,</span><span class="n">S2hz</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">r_vals</span><span class="p">,</span><span class="n">Lhx_fvals</span><span class="p">,</span><span class="n">Lhy_fvals</span><span class="p">,</span><span class="n">Lhz_fvals</span><span class="p">,</span><span class="n">S1hx_fvals</span><span class="p">,</span><span class="n">S1hy_fvals</span><span class="p">,</span><span class="n">S1hz_fvals</span><span class="p">,</span><span class="n">S2hx_fvals</span><span class="p">,</span><span class="n">S2hy_fvals</span><span class="p">,</span><span class="n">S2hz_fvals</span><span class="p">):</span>                   
            <span class="n">L_f</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r_f</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
            <span class="n">outfilesave</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">r_f</span><span class="p">)</span><span class="o">+</span><span class="s">&quot; &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">Lhx</span><span class="o">*</span><span class="n">L_f</span><span class="p">)</span><span class="o">+</span><span class="s">&quot; &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">Lhy</span><span class="o">*</span><span class="n">L_f</span><span class="p">)</span><span class="o">+</span><span class="s">&quot; &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">Lhz</span><span class="o">*</span><span class="n">L_f</span><span class="p">)</span><span class="o">+</span><span class="s">&quot; &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">S1hx</span><span class="o">*</span><span class="n">S1</span><span class="p">)</span><span class="o">+</span><span class="s">&quot; &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">S1hy</span><span class="o">*</span><span class="n">S1</span><span class="p">)</span><span class="o">+</span><span class="s">&quot; &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">S1hz</span><span class="o">*</span><span class="n">S1</span><span class="p">)</span><span class="o">+</span><span class="s">&quot; &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">S2hx</span><span class="o">*</span><span class="n">S2</span><span class="p">)</span><span class="o">+</span><span class="s">&quot; &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">S2hy</span><span class="o">*</span><span class="n">S2</span><span class="p">)</span><span class="o">+</span><span class="s">&quot; &quot;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">S2hz</span><span class="o">*</span><span class="n">S2</span><span class="p">)</span><span class="o">+</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">)</span>
        <span class="n">outfilesave</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="c">#else:</span>
    <span class="c">#    print &quot;[evolve_J_infinity] Skipping. Output:&quot;, savename</span>
    
    <span class="k">return</span> <span class="n">savename</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.parametric_angles">
    <p>def <span class="ident">parametric_angles</span>(</p><p>S, J, xi, q, S1, S2, r)</p>
    </div>
    

    
  
    <div class="desc"><p>Compute the angles theta1,theta2,deltaphi and theta12, given S, J and xi.
Roundoff errors are fixed forcing cosines to be in [-1,1]. The thetas are
polar angles in [0,pi]. Deltaphi is an azimuthal angle, in principle lies in
[-pi,pi]. Here we assumed DeltaPhi to be in [0,pi] as returned by arcccos:
one may need to add a sign, depending on the actual application of this
function (see e.g. <a href="#precession.orbit_angles"><code>orbit_angles</code></a> below). This function can be
seen as the inverse of <a href="#precession.from_the_angles"><code>from_the_angles</code></a>. In the equal-mass limit
q=1, S doesn't parametrize the precessional motion; we track the binary
precession using varphi explicitly.</p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>theta1,theta2,deltaphi,theta12=precession.parametric_angles(S,J,xi,q,S1,S2,r)
</pre></div>


<p><strong>Parameters:</strong></p>
<ul>
<li><code>S</code>: magnitude of the total spin.   </li>
<li><code>J</code>: magnitude of the total angular momentum.</li>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>r</code>: binary separation.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>theta1</code>: angle between the spin of the primary and the orbital angular momentum.</li>
<li><code>theta2</code>: angle between the spin of the secondary and the orbital angular momentum.</li>
<li><code>deltaphi</code>: angle between the projection of the two spins on the orbital plane.</li>
<li><code>theta12</code>: angle between the two spins.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.parametric_angles', this);">Show source &equiv;</a></p>
  <div id="source-precession.parametric_angles" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">parametric_angles</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">):</span>
    
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Compute the angles theta1,theta2,deltaphi and theta12, given S, J and xi.</span>
<span class="sd">    Roundoff errors are fixed forcing cosines to be in [-1,1]. The thetas are</span>
<span class="sd">    polar angles in [0,pi]. Deltaphi is an azimuthal angle, in principle lies in</span>
<span class="sd">    [-pi,pi]. Here we assumed DeltaPhi to be in [0,pi] as returned by arcccos:</span>
<span class="sd">    one may need to add a sign, depending on the actual application of this</span>
<span class="sd">    function (see e.g. `precession.orbit_angles` below). This function can be</span>
<span class="sd">    seen as the inverse of `precession.from_the_angles`. In the equal-mass limit</span>
<span class="sd">    q=1, S doesn&#39;t parametrize the precessional motion; we track the binary</span>
<span class="sd">    precession using varphi explicitly.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        theta1,theta2,deltaphi,theta12=precession.parametric_angles(S,J,xi,q,S1,S2,r)</span>

<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `S`: magnitude of the total spin.   </span>
<span class="sd">    - `J`: magnitude of the total angular momentum.</span>
<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `r`: binary separation.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `theta1`: angle between the spin of the primary and the orbital angular momentum.</span>
<span class="sd">    - `theta2`: angle between the spin of the secondary and the orbital angular momentum.</span>
<span class="sd">    - `deltaphi`: angle between the projection of the two spins on the orbital plane.</span>
<span class="sd">    - `theta12`: angle between the two spins.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="n">L</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>

    <span class="k">global</span> <span class="n">flags_q1</span>    
    <span class="k">if</span> <span class="n">q</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">flags_q1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="bp">False</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;[parametric_angles] Warning q=1: input here is cos(varphi), not S.&quot;</span>
            <span class="n">flags_q1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="bp">True</span> <span class="c"># Suppress future warnings</span>
        <span class="n">cosvarphi</span><span class="o">=</span><span class="n">S</span> <span class="c"># The input variable is actually cos(varphi)</span>
        <span class="n">S</span><span class="o">=</span><span class="p">(</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">xi</span><span class="o">*</span><span class="n">L</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
        <span class="n">t4</span><span class="o">=</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="n">S</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">t5</span><span class="o">=</span><span class="p">(</span><span class="n">L</span><span class="o">+</span><span class="n">S</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">t6</span><span class="o">=</span><span class="p">(</span><span class="n">S1</span><span class="o">+</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">t7</span><span class="o">=</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>        
        <span class="n">B</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">t4</span><span class="o">*</span><span class="n">t5</span><span class="o">*</span><span class="n">t6</span><span class="o">*</span><span class="n">t7</span><span class="p">)</span>
        <span class="n">costheta1</span><span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">S1</span><span class="o">*</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">L</span><span class="p">))</span><span class="o">*</span><span class="p">((</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">S1</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">B</span><span class="p">)</span><span class="o">*</span><span class="n">cosvarphi</span><span class="p">)</span>
        <span class="n">costheta2</span><span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">S2</span><span class="o">*</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">L</span><span class="p">))</span><span class="o">*</span><span class="p">((</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">S2</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S1</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">B</span><span class="p">)</span><span class="o">*</span><span class="n">cosvarphi</span><span class="p">)</span>
    
    <span class="k">else</span><span class="p">:</span>
        <span class="n">costheta1</span><span class="o">=</span> <span class="p">(</span> <span class="p">((</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="n">L</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">q</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">xi</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span> <span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">S1</span><span class="p">)</span>
        <span class="n">costheta2</span><span class="o">=</span> <span class="p">(</span> <span class="p">((</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="n">q</span><span class="o">/</span><span class="n">L</span><span class="p">))</span> <span class="o">+</span> <span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">q</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">xi</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span> <span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">S2</span><span class="p">)</span>

    <span class="c"># Force all cosines in [-1,1].</span>
    <span class="n">costheta1</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="nb">min</span><span class="p">(</span><span class="n">costheta1</span><span class="p">,</span><span class="mf">1.</span><span class="p">))</span>
    <span class="n">theta1</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">costheta1</span><span class="p">)</span>
    <span class="n">costheta2</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="nb">min</span><span class="p">(</span><span class="n">costheta2</span><span class="p">,</span><span class="mf">1.</span><span class="p">))</span>
    <span class="n">theta2</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">costheta2</span><span class="p">)</span>
    <span class="n">costheta12</span><span class="o">=</span><span class="p">(</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S1</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">S1</span><span class="o">*</span><span class="n">S2</span><span class="p">)</span>
    <span class="n">costheta12</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="nb">min</span><span class="p">(</span><span class="n">costheta12</span><span class="p">,</span><span class="mf">1.</span><span class="p">))</span>
    <span class="n">theta12</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">costheta12</span><span class="p">)</span>
    <span class="n">cosdeltaphi</span><span class="o">=</span> <span class="p">(</span><span class="n">costheta12</span> <span class="o">-</span> <span class="n">costheta1</span><span class="o">*</span><span class="n">costheta2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta1</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta2</span><span class="p">))</span>    
    <span class="n">cosdeltaphi</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="nb">min</span><span class="p">(</span><span class="n">cosdeltaphi</span><span class="p">,</span><span class="mf">1.</span><span class="p">))</span>
    <span class="n">deltaphi</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">cosdeltaphi</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">theta1</span><span class="p">,</span><span class="n">theta2</span><span class="p">,</span><span class="n">deltaphi</span><span class="p">,</span><span class="n">theta12</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.phase_checker">
    <p>def <span class="ident">phase_checker</span>(</p><p>q, S1, S2, r, verbose=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Computes the number of different morphologies you MAY have for a given
geometrical configuration (i.e. given the lengths of the vectors L, S1 and
S2). These are just geometrical constraints: the actual number of allowed
morphologies depends on J, as returned by <a href="#precession.phase_xi"><code>phase_xi</code></a>, but it
can't be out of what returned by this function. This function is basically a
sanity check for <a href="#precession.phase_xi"><code>phase_xi</code></a>.</p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>phases_vals=precession.phase_checker(q,S1,S2,r,verbose=False)
</pre></div>


<p><strong>Parameters:</strong></p>
<ul>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>r</code>: binary separation.</li>
<li><code>verbose</code>: if True print additional information.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li>phases_vals: number of coexisting morphologies: 1 if only the DeltaPhi~pi phase is present; 2 if two DeltaPhi~pi phases and a circulating phase are present; 3 if a librating DeltaPhi~0, a circulating, and a DeltaPhi~pi phase al all present (array).</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.phase_checker', this);">Show source &equiv;</a></p>
  <div id="source-precession.phase_checker" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">phase_checker</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Computes the number of different morphologies you MAY have for a given</span>
<span class="sd">    geometrical configuration (i.e. given the lengths of the vectors L, S1 and</span>
<span class="sd">    S2). These are just geometrical constraints: the actual number of allowed</span>
<span class="sd">    morphologies depends on J, as returned by `precession.phase_xi`, but it</span>
<span class="sd">    can&#39;t be out of what returned by this function. This function is basically a</span>
<span class="sd">    sanity check for `precession.phase_xi`.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        phases_vals=precession.phase_checker(q,S1,S2,r,verbose=False)</span>
<span class="sd">    </span>
<span class="sd">    **Parameters:**</span>

<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `r`: binary separation.</span>
<span class="sd">    - `verbose`: if True print additional information.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - phases_vals: number of coexisting morphologies: 1 if only the DeltaPhi~pi phase is present; 2 if two DeltaPhi~pi phases and a circulating phase are present; 3 if a librating DeltaPhi~0, a circulating, and a DeltaPhi~pi phase al all present (array).</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">L</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
    
    <span class="k">if</span> <span class="n">L</span> <span class="o">&gt;</span> <span class="n">S1</span> <span class="o">+</span> <span class="n">S2</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;L &gt; S1 + S2 : 3&quot;</span>
        <span class="n">phases</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    
    <span class="k">elif</span> <span class="p">(</span><span class="n">S1</span> <span class="o">+</span> <span class="n">S2</span> <span class="o">&gt;</span> <span class="n">L</span> <span class="ow">and</span> <span class="n">L</span> <span class="o">&gt;</span> <span class="nb">max</span><span class="p">(</span><span class="n">S1</span><span class="p">,</span> <span class="n">S2</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;S1 + S2 &gt; L &gt; max(S1, S2) : 3,1&quot;</span>
        <span class="n">phases</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">elif</span> <span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">L</span> <span class="ow">and</span>  <span class="n">L</span><span class="o">&gt;</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;max(S1,S2) &gt; L &gt; |S1-S2| : 3,2,1&quot;</span>
        <span class="n">phases</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span>
    
    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">L</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;|S1 - S2| &gt; L : 3,2&quot;</span>
        <span class="n">phases</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">assert</span> <span class="bp">False</span><span class="p">,</span> <span class="s">&quot;[phase_checker] Error. You should never be here!&quot;</span>        
        
    <span class="k">return</span> <span class="n">phases</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.phase_xi">
    <p>def <span class="ident">phase_xi</span>(</p><p>J, q, S1, S2, r)</p>
    </div>
    

    
  
    <div class="desc"><p>Return an integer number, phases, specifying the number of precessional
morphologies that can coexist for a given value of J. Returns:</p>
<ul>
<li>1 if only the DeltaPhi~pi phase is present;</li>
<li>2 if two DeltaPhi~pi phases
and a circulating phase are present;</li>
<li>3 if a librating DeltaPhi~0, a
circulating, and a DeltaPhi~pi phase al all present.</li>
</ul>
<p>The latter is <em>standard</em> case studied in <a href="http://journals.aps.org/prl/abstract/10.1103/PhysRevLett.114.081103">our first
PRL</a>.
Additionally, return the values of xi that, for given J, separate the
binaries with different morphologies. If there are no transitions (i.e.
phase=1), the transition values of xi are returned as Nones. If transitions
cannot be found for numerical reasons, assume they coincides with the
extrema of xi (see <a href="#precession.xi_allowed"><code>xi_allowed</code></a>). The output of this function can
be tested with <a href="#precession.phase_checker"><code>phase_checker</code></a>.</p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>phase,xi_transit_low,xi_transit_up=precession.phase_xi(J,q,S1,S2,r)
</pre></div>


<p><strong>Parameters:</strong></p>
<ul>
<li><code>J</code>: magnitude of the total angular momentum.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>r</code>: binary separation.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li>phase: number of coexisting morphologies: 1 if only the DeltaPhi~pi phase is present; 2 if two DeltaPhi~pi phases and a circulating phase are present; 3 if a librating DeltaPhi~0, a circulating, and a DeltaPhi~pi phase al all present.</li>
<li>xi_transit_low: value of xi marking the transition between the low and the middle phase</li>
<li>xi_transit_up: value of xi marking the transition between the upper and the middle phase</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.phase_xi', this);">Show source &equiv;</a></p>
  <div id="source-precession.phase_xi" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">phase_xi</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">):</span> 

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Return an integer number, phases, specifying the number of precessional</span>
<span class="sd">    morphologies that can coexist for a given value of J. Returns:</span>

<span class="sd">    - 1 if only the DeltaPhi~pi phase is present;</span>
<span class="sd">    - 2 if two DeltaPhi~pi phases</span>
<span class="sd">    and a circulating phase are present;</span>
<span class="sd">    - 3 if a librating DeltaPhi~0, a</span>
<span class="sd">    circulating, and a DeltaPhi~pi phase al all present.</span>

<span class="sd">    The latter is *standard* case studied in [our first</span>
<span class="sd">    PRL](http://journals.aps.org/prl/abstract/10.1103/PhysRevLett.114.081103).</span>
<span class="sd">    Additionally, return the values of xi that, for given J, separate the</span>
<span class="sd">    binaries with different morphologies. If there are no transitions (i.e.</span>
<span class="sd">    phase=1), the transition values of xi are returned as Nones. If transitions</span>
<span class="sd">    cannot be found for numerical reasons, assume they coincides with the</span>
<span class="sd">    extrema of xi (see `precession.xi_allowed`). The output of this function can</span>
<span class="sd">    be tested with `precession.phase_checker`.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        phase,xi_transit_low,xi_transit_up=precession.phase_xi(J,q,S1,S2,r)</span>
<span class="sd">    </span>
<span class="sd">    **Parameters:**</span>

<span class="sd">    - `J`: magnitude of the total angular momentum.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `r`: binary separation.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - phase: number of coexisting morphologies: 1 if only the DeltaPhi~pi phase is present; 2 if two DeltaPhi~pi phases and a circulating phase are present; 3 if a librating DeltaPhi~0, a circulating, and a DeltaPhi~pi phase al all present.</span>
<span class="sd">    - xi_transit_low: value of xi marking the transition between the low and the middle phase</span>
<span class="sd">    - xi_transit_up: value of xi marking the transition between the upper and the middle phase</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">xi_min</span><span class="p">,</span><span class="n">xi_max</span><span class="o">=</span><span class="n">xi_allowed</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
    <span class="n">L</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
    
    <span class="c"># The following should be equivalent to apply find_morphology at xi_min and xi_max but it turns out to be more stable to numerical noise because it doesn&#39;t rely on Sb_limits</span>
    <span class="n">St_min</span><span class="p">,</span><span class="n">St_max</span><span class="o">=</span><span class="n">St_limits</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
    <span class="n">morph_ximin</span><span class="o">=</span><span class="n">find_morphology</span><span class="p">(</span><span class="n">xi_plus</span><span class="p">(</span><span class="n">St_max</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">),</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
    <span class="n">morph_ximax</span><span class="o">=</span><span class="n">find_morphology</span><span class="p">(</span><span class="n">xi_plus</span><span class="p">(</span><span class="n">St_min</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">),</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
    
    
    <span class="c"># The morphology at xi_max must be librating about pi. The morphology at xi_min can&#39;t be circulating.  Check if, because of degeneracies and numerical issues, a different morphology is be detected... </span>
    <span class="k">if</span> <span class="n">morph_ximax</span><span class="o">!=</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">morph_ximin</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&quot;[phase_xi] I think this should never ever happen. morph_ximax=&quot;</span><span class="p">,</span><span class="n">morph_ximax</span><span class="p">,</span><span class="s">&quot; morph_ximin=&quot;</span><span class="p">,</span><span class="n">morph_ximin</span>
        <span class="k">if</span> <span class="n">morph_ximin</span><span class="o">==-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">phase</span><span class="o">=</span><span class="mf">3.</span>
            <span class="n">xi_transit_up</span><span class="o">=</span><span class="n">xi_plus</span><span class="p">(</span><span class="n">St_min</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span><span class="o">+</span><span class="mf">1e-9</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">xi_transit_low</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="k">lambda</span> <span class="n">xi</span><span class="p">:</span> <span class="p">(</span><span class="n">find_morphology</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span> <span class="o">+</span><span class="mf">0.5</span><span class="p">),</span> <span class="n">xi_min</span><span class="p">,</span><span class="n">xi_transit_up</span><span class="o">-</span><span class="mf">1e-5</span><span class="p">,</span> <span class="n">xtol</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">xi_transit_low</span><span class="o">=</span><span class="n">xi_min</span>

            <span class="k">return</span> <span class="n">phase</span><span class="p">,</span><span class="n">xi_transit_low</span><span class="p">,</span><span class="n">xi_transit_up</span>
        
    <span class="k">if</span> <span class="n">morph_ximin</span><span class="o">==-</span><span class="mi">1</span><span class="p">:</span> 

        <span class="n">phase</span><span class="o">=</span><span class="mf">3.</span> <span class="c"># This is a three-phase case: Deltaphi~pi close to xi_max, Deltaphi~0 at xi_min and a circulating phase in between</span>

        <span class="c">#Find transition Librating 180 - Circulating. Shift the find_morphology output, such that the zero is between the two phases</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">xi_transit_up</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="k">lambda</span> <span class="n">xi</span><span class="p">:</span> <span class="p">(</span><span class="n">find_morphology</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">),</span> <span class="n">xi_min</span><span class="p">,</span><span class="n">xi_max</span><span class="p">,</span> <span class="n">xtol</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">xi_transit_up</span><span class="o">=</span><span class="n">xi_max</span>
            
        <span class="c">#Find transition Librating 0 - Circulating. Shift the find_morphology output, such that the zero is between the two phases</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">xi_transit_low</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="k">lambda</span> <span class="n">xi</span><span class="p">:</span> <span class="p">(</span><span class="n">find_morphology</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span> <span class="o">+</span><span class="mf">0.5</span><span class="p">),</span> <span class="n">xi_min</span><span class="p">,</span><span class="n">xi_max</span><span class="p">,</span> <span class="n">xtol</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">xi_transit_low</span><span class="o">=</span><span class="n">xi_min</span>
            
        <span class="c">#xi_transit_low,xi_transit_up=sorted([xi_transit_0,xi_transit_180])</span>

    <span class="k">elif</span> <span class="n">morph_ximin</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>  <span class="c"># This is either a two-phase or a single-phase case.</span>
        <span class="c"># Here we need to bracket the interval to find two roots. Two possible bracketing points are checked: the values of S for which</span>
            <span class="c"># [first try] cos(theta1)=1 and cos(theta2)= -1 </span>
            <span class="c"># [second try] cos(theta1)=-1 and cos(theta2)= 1 </span>
        <span class="c"># Either one of the two choice typically gives the correct results for all the cases we tried; we cannot exclude the presence of pathological sets of parameters where both choices fail.</span>

        <span class="k">for</span> <span class="n">xi_bracket</span> <span class="ow">in</span> <span class="p">[</span> <span class="o">-</span><span class="mf">1.</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">S1</span><span class="o">+</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="mf">1.</span><span class="o">/</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">S2</span> <span class="p">,</span> <span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">S1</span><span class="o">-</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="mf">1.</span><span class="o">/</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">S2</span> <span class="p">]:</span>
            <span class="k">if</span> <span class="n">xi_bracket</span><span class="o">&gt;</span><span class="n">xi_max</span> <span class="ow">or</span> <span class="n">xi_bracket</span><span class="o">&lt;</span><span class="n">xi_min</span><span class="p">:</span>
                <span class="n">phase</span><span class="o">=</span><span class="mf">1.</span> <span class="c"># Either the bracketing is wrong or this is a single-phase case</span>
                <span class="n">xi_transit_low</span><span class="o">=</span><span class="n">xi_min</span>
                <span class="n">xi_transit_up</span><span class="o">=</span><span class="n">xi_max</span>
            <span class="k">elif</span> <span class="n">find_morphology</span><span class="p">(</span><span class="n">xi_bracket</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">phase</span><span class="o">=</span><span class="mf">2.</span> <span class="c"># You found a good bracketing point. This must be a two-phase case             </span>
            
                <span class="c">#Find the first transition Librating 180 - Circulating at lower xi. Shift the find_morphology output, such that the zero is between the two phase</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">xi_transit_low</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="k">lambda</span> <span class="n">xi</span><span class="p">:</span> <span class="p">(</span><span class="n">find_morphology</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">),</span> <span class="n">xi_min</span><span class="p">,</span><span class="n">xi_bracket</span><span class="p">,</span> <span class="n">xtol</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="n">xi_transit_low</span><span class="o">=</span><span class="n">xi_min</span>
   
                <span class="c">#Find the other transition Librating 180 - Circulating at larger xi. Shift the find_morphology output, such that the zero is between the two phase</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">xi_transit_up</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="k">lambda</span> <span class="n">xi</span><span class="p">:</span>  <span class="p">(</span><span class="n">find_morphology</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">),</span> <span class="n">xi_bracket</span><span class="p">,</span><span class="n">xi_max</span><span class="p">,</span> <span class="n">xtol</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="n">xi_transit_up</span><span class="o">=</span><span class="n">xi_max</span>
             
                <span class="k">break</span> <span class="c"># One bracketing point is enough. Get out if you found the solution</span>
            
            <span class="k">else</span><span class="p">:</span>
                <span class="n">phase</span><span class="o">=</span><span class="mf">1.</span>  <span class="c"># Either the bracketing is wrong or this is a single-phase case</span>
                <span class="n">xi_transit_low</span><span class="o">=</span><span class="n">xi_min</span>
                <span class="n">xi_transit_up</span><span class="o">=</span><span class="n">xi_max</span>
                          
    <span class="k">if</span> <span class="n">phase</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">phase_checker</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">):</span>
        <span class="k">print</span> <span class="s">&quot;[phase_xi] Warning: detected phases not allowed by geometry!&quot;</span>

    <span class="k">return</span> <span class="n">phase</span><span class="p">,</span> <span class="n">xi_transit_low</span><span class="p">,</span><span class="n">xi_transit_up</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.precession_period">
    <p>def <span class="ident">precession_period</span>(</p><p>xi, J, q, S1, S2, r)</p>
    </div>
    

    
  
    <div class="desc"><p>Find the period of S, i.e. the precessional timescale. This is
<a href="#precession.t_of_S"><code>t_of_S</code></a> integrated from Sb_min to Sb_max times 2.</p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>tau=precession.precession_period(xi,J,q,S1,S2,r)
</pre></div>


<p><strong>Parameters:</strong></p>
<ul>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>J</code>: magnitude of the total angular momentum.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>r</code>: binary separation.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>tau</code>: precessional period (in total mass units).</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.precession_period', this);">Show source &equiv;</a></p>
  <div id="source-precession.precession_period" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">precession_period</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">):</span>
    
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Find the period of S, i.e. the precessional timescale. This is</span>
<span class="sd">    `precession.t_of_S` integrated from Sb_min to Sb_max times 2.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        tau=precession.precession_period(xi,J,q,S1,S2,r)</span>
<span class="sd">    </span>
<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `J`: magnitude of the total angular momentum.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `r`: binary separation.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `tau`: precessional period (in total mass units).</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="k">if</span> <span class="n">q</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="c"># If q=1, the limits must be specified in cos(varphi)</span>
       <span class="n">Sb_min</span><span class="o">=-</span><span class="mi">1</span>
       <span class="n">Sb_max</span><span class="o">=</span><span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Sb_min</span><span class="p">,</span><span class="n">Sb_max</span><span class="o">=</span><span class="n">Sb_limits</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
    
    <span class="n">halfperiod</span> <span class="o">=</span> <span class="n">t_of_S</span><span class="p">(</span><span class="n">Sb_min</span><span class="p">,</span><span class="n">Sb_max</span><span class="p">,</span><span class="n">Sb_min</span><span class="p">,</span><span class="n">Sb_max</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
    <span class="c">#abs because here you don&#39;t care about the &lt;sign&gt; issue in dS/dt here</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">halfperiod</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.region_selection">
    <p>def <span class="ident">region_selection</span>(</p><p>varphi, S, J, q, S1, S2, r)</p>
    </div>
    

    
  
    <div class="desc"><p>Get the morphology in the varphi plane. See <a href="#precession.find_morphology"><code>find_morphology</code></a>.</p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>morphology=precession.region_selection(varphi,S,J,q,S1,S2,r)
</pre></div>


<p><strong>Parameters:</strong></p>
<ul>
<li><code>varphi</code>: angle describing the rotation of S1 and S2 about S, in a frame aligned with J.</li>
<li><code>S</code>: magnitude of the total spin.</li>
<li><code>J</code>: magnitude of the total angular momentum.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>r</code>: binary separation.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li>morphology: precessional morphology in DeltaPhi: -1 if librating about DeltaPhi=0; 0 if circulating; +1 if librating about DeltaPhi=pi.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.region_selection', this);">Show source &equiv;</a></p>
  <div id="source-precession.region_selection" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">region_selection</span><span class="p">(</span><span class="n">varphi</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Get the morphology in the varphi plane. See `precession.find_morphology`.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        morphology=precession.region_selection(varphi,S,J,q,S1,S2,r)</span>

<span class="sd">    **Parameters:**</span>

<span class="sd">    - `varphi`: angle describing the rotation of S1 and S2 about S, in a frame aligned with J.</span>
<span class="sd">    - `S`: magnitude of the total spin.</span>
<span class="sd">    - `J`: magnitude of the total angular momentum.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `r`: binary separation.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - morphology: precessional morphology in DeltaPhi: -1 if librating about DeltaPhi=0; 0 if circulating; +1 if librating about DeltaPhi=pi.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="n">xi</span><span class="o">=</span><span class="n">xi_contour</span><span class="p">(</span><span class="n">varphi</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">find_morphology</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.resonant_finder">
    <p>def <span class="ident">resonant_finder</span>(</p><p>xi, q, S1, S2, r, more=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Find the spin-orbit resonances, for given xi, as extrema of the allowed
region in the parameter space. Two resonances are present for DeltaPhi=0 and
DeltaPhi=pi. They maximize (0) and minimize (pi) J for fixed xi. This is an
alternative (and more powerful) approach to solving the Schnittman equation,
given in Eq.(35) of <a href="http://journals.aps.org/prd/abstract/10.1103/PhysRevD.70.
124020">PRD
70,124020(2004)</a>.</p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>theta1_dp0,theta2_dp0,theta1_dp180,theta2_dp180=precession.resonant_finder(xi,q,S1,S2,r,more=False)

J_dp0,S_dp0,theta1_dp0,theta2_dp0,J_dp180,S_dp180,theta1_dp180,theta2_dp180=precession.resonant_finder(xi,q,S1,S2,r,more=True)
</pre></div>


<p><strong>Parameters:</strong></p>
<ul>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>r</code>: binary separation.</li>
<li><code>more</code>: if <code>True</code> returns additional quantities.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li>J_dp0: (optional) value of J for the DeltaPhi=0 resonance.</li>
<li>S_dp0: (optional) value of S for the DeltaPhi=0 resonance.</li>
<li>theta1_dp0: value of theta1 for the DeltaPhi=0 resonance.</li>
<li>theta2_dp0: value of theta2 for the DeltaPhi=pi resonance.</li>
<li>J_dp180: (optional) value of J for the DeltaPhi=pi resonance.</li>
<li>S_dp180: (optional) value of S for the DeltaPhi=pi resonance.</li>
<li>theta1_dp180: value of theta1 for the DeltaPhi=pi resonance.</li>
<li>theta2_dp180: value of theta2 for the DeltaPhi=pi resonance.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.resonant_finder', this);">Show source &equiv;</a></p>
  <div id="source-precession.resonant_finder" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">resonant_finder</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">,</span> <span class="n">more</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Find the spin-orbit resonances, for given xi, as extrema of the allowed</span>
<span class="sd">    region in the parameter space. Two resonances are present for DeltaPhi=0 and</span>
<span class="sd">    DeltaPhi=pi. They maximize (0) and minimize (pi) J for fixed xi. This is an</span>
<span class="sd">    alternative (and more powerful) approach to solving the Schnittman equation,</span>
<span class="sd">    given in Eq.(35) of [PRD</span>
<span class="sd">    70,124020(2004)](http://journals.aps.org/prd/abstract/10.1103/PhysRevD.70.</span>
<span class="sd">    124020).</span>
<span class="sd">    </span>
<span class="sd">    **Call:**</span>

<span class="sd">        theta1_dp0,theta2_dp0,theta1_dp180,theta2_dp180=precession.resonant_finder(xi,q,S1,S2,r,more=False)</span>

<span class="sd">        J_dp0,S_dp0,theta1_dp0,theta2_dp0,J_dp180,S_dp180,theta1_dp180,theta2_dp180=precession.resonant_finder(xi,q,S1,S2,r,more=True)</span>

<span class="sd">    **Parameters:**</span>

<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `r`: binary separation.</span>
<span class="sd">    - `more`: if `True` returns additional quantities.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - J_dp0: (optional) value of J for the DeltaPhi=0 resonance.</span>
<span class="sd">    - S_dp0: (optional) value of S for the DeltaPhi=0 resonance.</span>
<span class="sd">    - theta1_dp0: value of theta1 for the DeltaPhi=0 resonance.</span>
<span class="sd">    - theta2_dp0: value of theta2 for the DeltaPhi=pi resonance.</span>
<span class="sd">    - J_dp180: (optional) value of J for the DeltaPhi=pi resonance.</span>
<span class="sd">    - S_dp180: (optional) value of S for the DeltaPhi=pi resonance.</span>
<span class="sd">    - theta1_dp180: value of theta1 for the DeltaPhi=pi resonance.</span>
<span class="sd">    - theta2_dp180: value of theta2 for the DeltaPhi=pi resonance. </span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="n">Jmin</span><span class="p">,</span><span class="n">Jmax</span><span class="o">=</span><span class="n">J_lim</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>    
    <span class="n">L</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>    
    
    <span class="c">#DeltaPhi=0 resonance.</span>
    <span class="n">J_dp0</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="k">lambda</span> <span class="n">J</span><span class="p">:</span> <span class="n">xi_allowed</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span><span class="n">xi</span> <span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">),</span> <span class="n">Jmax</span><span class="p">,</span><span class="n">xtol</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">q</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> 
        <span class="c"># Find S. St_max</span>
        <span class="n">S_dp0</span><span class="o">=</span><span class="n">St_limits</span><span class="p">(</span><span class="n">J_dp0</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="c"># Find angles</span>
        <span class="n">theta1_dp0</span><span class="p">,</span><span class="n">theta2_dp0</span><span class="p">,</span><span class="n">deltaphi_dp0</span><span class="p">,</span><span class="n">dummy</span> <span class="o">=</span> <span class="n">parametric_angles</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">J_dp0</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>   
                
    <span class="k">else</span><span class="p">:</span>
        <span class="c"># Find S. Minimum of effective potential       </span>
        <span class="n">dummy</span><span class="p">,</span><span class="n">dummy</span><span class="p">,</span><span class="n">S_dp0</span><span class="p">,</span><span class="n">dummy</span><span class="o">=</span> <span class="n">xi_allowed</span><span class="p">(</span><span class="n">J_dp0</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">more</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="c"># Find angles</span>
        <span class="n">theta1_dp0</span><span class="p">,</span><span class="n">theta2_dp0</span><span class="p">,</span><span class="n">deltaphi_dp0</span><span class="p">,</span><span class="n">dummy</span> <span class="o">=</span> <span class="n">parametric_angles</span><span class="p">(</span><span class="n">S_dp0</span><span class="p">,</span><span class="n">J_dp0</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>

    <span class="c">#DeltaPhi=180 resonance.</span>
    <span class="n">xi_Jmin</span><span class="p">,</span><span class="n">xi_Jmax</span><span class="o">=</span> <span class="n">xi_at_Jlim</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
            
    <span class="k">if</span> <span class="n">xi</span><span class="o">&gt;</span><span class="n">xi_Jmin</span><span class="p">:</span>
        <span class="c"># Find J. Solution always on xi_max, between Jmin and Jmax</span>
        <span class="n">J_dp180</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="k">lambda</span> <span class="n">J</span><span class="p">:</span> <span class="n">xi_allowed</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span><span class="n">xi</span> <span class="p">,</span> <span class="n">Jmin</span><span class="p">,</span> <span class="n">Jmax</span><span class="p">,</span><span class="n">xtol</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">q</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="c"># Find S. St_min</span>
            <span class="n">S_dp180</span><span class="o">=</span><span class="n">St_limits</span><span class="p">(</span><span class="n">J_dp180</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c"># Find angles</span>
            <span class="n">theta1_dp180</span><span class="p">,</span><span class="n">theta2_dp180</span><span class="p">,</span><span class="n">deltaphi_dp0</span><span class="p">,</span><span class="n">dummy</span> <span class="o">=</span> <span class="n">parametric_angles</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">J_dp180</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>   
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># Find S. Maximum of effective potential</span>
            <span class="n">dummy</span><span class="p">,</span><span class="n">dummy</span><span class="p">,</span><span class="n">dummy</span><span class="p">,</span><span class="n">S_dp180</span><span class="o">=</span> <span class="n">xi_allowed</span><span class="p">(</span><span class="n">J_dp180</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">more</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="c"># Find angles</span>
            <span class="n">theta1_dp180</span><span class="p">,</span><span class="n">theta2_dp180</span><span class="p">,</span><span class="n">deltaphi_dp180</span><span class="p">,</span><span class="n">dummy</span> <span class="o">=</span> <span class="n">parametric_angles</span><span class="p">(</span><span class="n">S_dp180</span><span class="p">,</span><span class="n">J_dp180</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c"># Find J. Solution still on xi_min, between Jmin and L-S1-S2. You&#39;re not here if Jmin=L-S1-S2, because xi_Jmin is the lower allowed value for xi in that case.</span>
        <span class="n">J_dp180</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="k">lambda</span> <span class="n">J</span><span class="p">:</span> <span class="n">xi_allowed</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span><span class="n">xi</span> <span class="p">,</span><span class="n">Jmin</span><span class="p">,</span> <span class="nb">abs</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">),</span><span class="n">xtol</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">q</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="c"># Find S. St_max</span>
            <span class="n">S_dp180</span><span class="o">=</span><span class="n">St_limits</span><span class="p">(</span><span class="n">J_dp180</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
            <span class="c"># Find angles</span>
            <span class="n">theta1_dp180</span><span class="p">,</span><span class="n">theta2_dp180</span><span class="p">,</span><span class="n">deltaphi_dp0</span><span class="p">,</span><span class="n">dummy</span> <span class="o">=</span> <span class="n">parametric_angles</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">J_dp180</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>   
        <span class="k">else</span><span class="p">:</span>
            <span class="c"># Find S. Minimum of effective potential</span>
            <span class="n">dummy</span><span class="p">,</span><span class="n">dummy</span><span class="p">,</span><span class="n">S_dp180</span><span class="p">,</span><span class="n">dummy</span><span class="o">=</span> <span class="n">xi_allowed</span><span class="p">(</span><span class="n">J_dp180</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">more</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="c"># Find angles</span>
            <span class="n">theta1_dp180</span><span class="p">,</span><span class="n">theta2_dp180</span><span class="p">,</span><span class="n">deltaphi_dp180</span><span class="p">,</span><span class="n">dummy</span> <span class="o">=</span> <span class="n">parametric_angles</span><span class="p">(</span><span class="n">S_dp180</span><span class="p">,</span><span class="n">J_dp180</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
       
    <span class="k">if</span> <span class="bp">False</span><span class="p">:</span> <span class="c"># Sanity check. </span>
        <span class="k">print</span> <span class="s">&quot;DeltaPhi=0?&quot;</span><span class="p">,</span> <span class="n">deltaphi_dp0</span>
        <span class="k">print</span> <span class="s">&quot;DeltaPhi=pi?&quot;</span><span class="p">,</span> <span class="n">deltaphi_dp180</span>
    
    <span class="k">if</span> <span class="n">more</span><span class="p">:</span> <span class="c"># return everything you got</span>
        <span class="k">return</span> <span class="n">J_dp0</span><span class="p">,</span> <span class="n">S_dp0</span><span class="p">,</span> <span class="n">theta1_dp0</span><span class="p">,</span> <span class="n">theta2_dp0</span><span class="p">,</span> <span class="n">J_dp180</span><span class="p">,</span> <span class="n">S_dp180</span><span class="p">,</span> <span class="n">theta1_dp180</span><span class="p">,</span> <span class="n">theta2_dp180</span>
    <span class="k">else</span><span class="p">:</span> <span class="c"># return the angles only</span>
        <span class="k">return</span> <span class="n">theta1_dp0</span><span class="p">,</span> <span class="n">theta2_dp0</span><span class="p">,</span> <span class="n">theta1_dp180</span><span class="p">,</span> <span class="n">theta2_dp180</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.rtof">
    <p>def <span class="ident">rtof</span>(</p><p>r, M_msun)</p>
    </div>
    

    
  
    <div class="desc"><p>Conversion between emitted GW frequency f (in Hertz) and binary separation r
(in mass unit). We use the Newtonian expression: f^2 = G M / (pi^2 r^3) in
cgs units. Mass units: r--&gt; GMr/c^2</p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>f=precession.rtof(r,M_msun)
</pre></div>


<p><strong>Parameters:</strong></p>
<ul>
<li><code>r</code>: binary separation.</li>
<li><code>M_msun</code>: binary total mass in solar masses.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>f</code>: emitted GW frequency in Hertz.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.rtof', this);">Show source &equiv;</a></p>
  <div id="source-precession.rtof" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">rtof</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">M_msun</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Conversion between emitted GW frequency f (in Hertz) and binary separation r</span>
<span class="sd">    (in mass unit). We use the Newtonian expression: f^2 = G M / (pi^2 r^3) in</span>
<span class="sd">    cgs units. Mass units: r--&gt; GMr/c^2</span>
<span class="sd"> </span>
<span class="sd">    **Call:**</span>

<span class="sd">        f=precession.rtof(r,M_msun)</span>

<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `r`: binary separation.</span>
<span class="sd">    - `M_msun`: binary total mass in solar masses.</span>

<span class="sd">    **Returns:**</span>
<span class="sd">    </span>
<span class="sd">    - `f`: emitted GW frequency in Hertz.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">M_cgs</span><span class="o">=</span><span class="n">M_msun</span><span class="o">*</span><span class="p">(</span><span class="mf">2e33</span><span class="p">)</span>
    <span class="n">c_cgs</span><span class="o">=</span><span class="mf">2.99e10</span>
    <span class="n">G_cgs</span><span class="o">=</span><span class="mf">6.67e-8</span>
    <span class="n">f</span><span class="o">=</span><span class="nb">pow</span><span class="p">(</span><span class="n">c_cgs</span><span class="p">,</span><span class="mf">3.</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">G_cgs</span><span class="o">*</span><span class="n">M_cgs</span><span class="o">*</span><span class="nb">pow</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="mf">3.</span><span class="o">/</span><span class="mf">2.</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">f</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.samplingS">
    <p>def <span class="ident">samplingS</span>(</p><p>xi, J, q, S1, S2, r)</p>
    </div>
    

    
  
    <div class="desc"><p>Select a value of S weighted with |dt/dS|. Sampling implemented using the
cumulative distribution:</p>
<ol>
<li>select a random number epsilon in [0,1];</li>
<li>find the value of S at which the cumulative probability distribution is
equal to epsilon.</li>
</ol>
<p>The cumulative-distribution method is particualry suitable because the
probability distribution function |dt/dS| diverges at the extrema Sb_min and
Sb_max (and is troubling to apply a hit-or-miss approach).</p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>S=precession.samplingS(xi,J,q,S1,S2,r)
</pre></div>


<p><strong>Parameters:</strong></p>
<ul>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>J</code>: magnitude of the total angular momentum.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>r</code>: binary separation.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>S</code>: magnitude of the total spin.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.samplingS', this);">Show source &equiv;</a></p>
  <div id="source-precession.samplingS" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">samplingS</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">):</span>
    
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Select a value of S weighted with |dt/dS|. Sampling implemented using the</span>
<span class="sd">    cumulative distribution:</span>
<span class="sd">    </span>
<span class="sd">    1. select a random number epsilon in [0,1];</span>
<span class="sd">    2. find the value of S at which the cumulative probability distribution is</span>
<span class="sd">    equal to epsilon.</span>

<span class="sd">    The cumulative-distribution method is particualry suitable because the</span>
<span class="sd">    probability distribution function |dt/dS| diverges at the extrema Sb_min and</span>
<span class="sd">    Sb_max (and is troubling to apply a hit-or-miss approach).</span>

<span class="sd">    **Call:**</span>

<span class="sd">        S=precession.samplingS(xi,J,q,S1,S2,r)</span>
<span class="sd">    </span>
<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `J`: magnitude of the total angular momentum.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `r`: binary separation.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `S`: magnitude of the total spin.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">global</span> <span class="n">flags_q1</span>
    <span class="k">if</span> <span class="n">q</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">flags_q1</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="o">==</span><span class="bp">False</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;[samplingS] Warning q=1: sampling is cos(varphi), not S&quot;</span>
            <span class="n">flags_q1</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="o">=</span><span class="bp">True</span>
            
        <span class="c"># If q=1, the limits must be specified in cos(varphi)</span>
        <span class="n">tol</span><span class="o">=</span><span class="mf">1e-10</span> <span class="c"># Don&#39;t go too close to the actual limits</span>
        <span class="n">Sb_min</span><span class="o">=-</span><span class="mf">1.</span><span class="o">+</span><span class="n">tol</span>
        <span class="n">Sb_max</span><span class="o">=</span><span class="mf">1.</span><span class="o">-</span><span class="n">tol</span>
        
    <span class="k">else</span><span class="p">:</span>
        <span class="n">Sb_min</span><span class="p">,</span><span class="n">Sb_max</span><span class="o">=</span><span class="n">Sb_limits</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Sb_min</span><span class="o">-</span><span class="n">Sb_max</span><span class="p">)</span><span class="o">&lt;</span><span class="mf">1e-8</span><span class="p">:</span> <span class="c"># This typically happen when [Sb_limits] fails in bracketing of the solutions. In practice, this is a resonant binary.</span>
        <span class="n">S_sol</span><span class="o">=</span><span class="p">(</span><span class="n">Sb_min</span><span class="o">+</span><span class="n">Sb_max</span><span class="p">)</span><span class="o">/</span><span class="mf">2.</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">halfperiod</span><span class="o">=</span><span class="n">t_of_S</span><span class="p">(</span><span class="n">Sb_min</span><span class="p">,</span><span class="n">Sb_max</span><span class="p">,</span><span class="n">Sb_min</span><span class="p">,</span><span class="n">Sb_max</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
        
        <span class="n">eps</span><span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>    
        
        <span class="n">S_sol</span><span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="k">lambda</span> <span class="n">S</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">t_of_S</span><span class="p">(</span><span class="n">Sb_min</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">Sb_min</span><span class="p">,</span><span class="n">Sb_max</span><span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span> <span class="o">/</span> <span class="n">halfperiod</span><span class="p">)</span> <span class="o">-</span> <span class="n">eps</span><span class="p">,</span> <span class="n">Sb_min</span><span class="p">,</span> <span class="n">Sb_max</span><span class="p">)</span> <span class="c"># The brentq algorithm works very well with a monotonic function like the cumulative distribution</span>

    <span class="k">return</span> <span class="n">S_sol</span>            
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.t_of_S">
    <p>def <span class="ident">t_of_S</span>(</p><p>S_initial, S_final, Sb_min, Sb_max, xi, J, q, S1, S2, r, t_initial=0, sign=1.0)</p>
    </div>
    

    
  
    <div class="desc"><p>Integrate <a href="#precession.dSdt"><code>dSdt</code></a> to find t (time) as a function of S (magnitude
of the total spin). Since dS/dt depends on S and not on t, finding t(S) only
requires a numnerical integration; S(t) is provided in <a href="#precession.t_of_S"><code>t_of_S</code></a>.
Sb_min and Sb_max are passed to this function (and not computed within it)
for computational efficiency. This function can only integrate over half
precession period (i.e. from Sb_min to Sb_max at most). If you want t(S)
over more precession periods you should stich different solutions together,
consistently with the argument sign (in particular, flip sign every half
period).</p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>t=precession.t_of_S(S_initial,S_final,Sb_min,Sb_max,xi,J,q,S1,S2,r,t_initial=0,sign=1.)
</pre></div>


<p><strong>Parameters:</strong></p>
<ul>
<li><code>S_initial</code>: lower edge of the integration domain.</li>
<li><code>S_final</code>: upper edge of the integration domain.</li>
<li><code>Sb_min</code>: minimum value of S from geometrical constraints. This is S- in our papers.</li>
<li><code>Sb_max</code>: maximum value of S from geometrical constraints. This is S+ in our papers.</li>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>J</code>: magnitude of the total angular momentum.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>r</code>: binary separation.</li>
<li><code>t_initial</code>: intial integration time.</li>
<li><code>sign</code>: if 1 return angle in [0,pi], if -1 return angle in [-pi,0].</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>t</code>: time (in total mass units).</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.t_of_S', this);">Show source &equiv;</a></p>
  <div id="source-precession.t_of_S" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">t_of_S</span><span class="p">(</span> <span class="n">S_initial</span><span class="p">,</span><span class="n">S_final</span> <span class="p">,</span><span class="n">Sb_min</span><span class="p">,</span><span class="n">Sb_max</span> <span class="p">,</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">,</span> <span class="n">t_initial</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">sign</span><span class="o">=</span><span class="mf">1.</span> <span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Integrate `precession.dSdt` to find t (time) as a function of S (magnitude</span>
<span class="sd">    of the total spin). Since dS/dt depends on S and not on t, finding t(S) only</span>
<span class="sd">    requires a numnerical integration; S(t) is provided in `precession.t_of_S`.</span>
<span class="sd">    Sb_min and Sb_max are passed to this function (and not computed within it)</span>
<span class="sd">    for computational efficiency. This function can only integrate over half</span>
<span class="sd">    precession period (i.e. from Sb_min to Sb_max at most). If you want t(S)</span>
<span class="sd">    over more precession periods you should stich different solutions together,</span>
<span class="sd">    consistently with the argument sign (in particular, flip sign every half</span>
<span class="sd">    period).</span>

<span class="sd">    **Call:**</span>

<span class="sd">        t=precession.t_of_S(S_initial,S_final,Sb_min,Sb_max,xi,J,q,S1,S2,r,t_initial=0,sign=1.)</span>
<span class="sd">    </span>
<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `S_initial`: lower edge of the integration domain.</span>
<span class="sd">    - `S_final`: upper edge of the integration domain.</span>
<span class="sd">    - `Sb_min`: minimum value of S from geometrical constraints. This is S- in our papers.</span>
<span class="sd">    - `Sb_max`: maximum value of S from geometrical constraints. This is S+ in our papers.</span>
<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `J`: magnitude of the total angular momentum.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `r`: binary separation.</span>
<span class="sd">    - `t_initial`: intial integration time.</span>
<span class="sd">    - `sign`: if 1 return angle in [0,pi], if -1 return angle in [-pi,0].</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `t`: time (in total mass units).</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">global</span> <span class="n">flags_q1</span>
    <span class="k">if</span> <span class="n">q</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">flags_q1</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">==</span><span class="bp">False</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;[t_of_S] Warning q=1: input here is cos(varphi) not S; now computing t( cos(varphi) )&quot;</span>
            <span class="n">flags_q1</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">=</span><span class="bp">True</span>
            
        <span class="n">L</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">xi</span><span class="o">*</span><span class="n">L</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">S_min</span><span class="p">,</span><span class="n">S_max</span><span class="o">=</span><span class="n">St_limits</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">S</span><span class="o">-</span><span class="n">S_min</span><span class="p">)</span><span class="o">&lt;</span><span class="mf">1e-8</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">S</span><span class="o">-</span><span class="n">S_max</span><span class="p">)</span><span class="o">&lt;</span><span class="mf">1e-8</span><span class="p">:</span>
            <span class="k">print</span> <span class="s">&quot;[t_of_S] Warning: you are at resonance, varphi is ill defined here.&quot;</span>
            <span class="k">return</span> <span class="mf">0.</span>
        <span class="k">elif</span> <span class="nb">min</span><span class="p">(</span><span class="n">S_initial</span><span class="p">,</span><span class="n">S_final</span><span class="p">)</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="nb">max</span><span class="p">(</span><span class="n">S_initial</span><span class="p">,</span><span class="n">S_final</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">assert</span> <span class="bp">False</span><span class="p">,</span> <span class="s">&quot;[t_of_S] Error. You&#39;re trying to integrate over more than one (half)period&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">integrate</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="n">dtdS</span><span class="p">,</span> <span class="n">S_initial</span><span class="p">,</span> <span class="n">S_final</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">sign</span><span class="p">),</span><span class="n">full_output</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">t_initial</span> <span class="o">+</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">Sb_min</span><span class="o">-</span><span class="n">Sb_max</span><span class="p">)</span><span class="o">&lt;</span><span class="mf">1e-8</span><span class="p">:</span> <span class="c"># This happens when [Sb_limits] fails in bracketing of the solutions. In practice, this is a resonant binary.</span>
        <span class="k">return</span> <span class="mf">0.</span>
    <span class="k">elif</span> <span class="nb">min</span><span class="p">(</span><span class="n">S_initial</span><span class="p">,</span><span class="n">S_final</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">Sb_min</span> <span class="ow">or</span> <span class="nb">max</span><span class="p">(</span><span class="n">S_initial</span><span class="p">,</span><span class="n">S_final</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">Sb_max</span><span class="p">:</span>
        <span class="k">assert</span> <span class="bp">False</span><span class="p">,</span> <span class="s">&quot;[t_of_S] Error. You&#39;re trying to integrate over more than one (half)period&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">res</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">integrate</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="n">dtdS</span><span class="p">,</span> <span class="n">S_initial</span><span class="p">,</span> <span class="n">S_final</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">sign</span><span class="p">),</span><span class="n">full_output</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>               
        <span class="k">return</span> <span class="n">t_initial</span> <span class="o">+</span> <span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.thetas_inf">
    <p>def <span class="ident">thetas_inf</span>(</p><p>xi, kappa_inf, q, S1, S2)</p>
    </div>
    

    
  
    <div class="desc"><p>Find the asymptotic (constant) values of theta1 and theta2 given xi and
kappa_inf.</p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>theta1_inf,theta2_inf=precession.thetas_inf(xi,kappa_inf,q,S1,S2)
</pre></div>


<p><strong>Parameters:</strong></p>
<ul>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>kappa_inf</code>: asymptotic value of kappa at large separations.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>theta1_inf</code>: asymptotic value of theta1 at large separations.</li>
<li><code>theta2_inf</code>: asymptotic value of theta2 at large separations.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.thetas_inf', this);">Show source &equiv;</a></p>
  <div id="source-precession.thetas_inf" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">thetas_inf</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span><span class="n">kappa_inf</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Find the asymptotic (constant) values of theta1 and theta2 given xi and</span>
<span class="sd">    kappa_inf.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        theta1_inf,theta2_inf=precession.thetas_inf(xi,kappa_inf,q,S1,S2)</span>

<span class="sd">    **Parameters:**</span>

<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    - `kappa_inf`: asymptotic value of kappa at large separations.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `theta1_inf`: asymptotic value of theta1 at large separations.</span>
<span class="sd">    - `theta2_inf`: asymptotic value of theta2 at large separations.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="k">if</span> <span class="n">q</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">assert</span> <span class="bp">False</span><span class="p">,</span> <span class="s">&quot;[thetas_inf] Error: I&#39;m sorry, can&#39;t run for q=1. The angles theta1 and theta2 are not constant at large separations.&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ct1</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="n">xi</span> <span class="o">+</span> <span class="n">kappa_inf</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)))</span><span class="o">/</span><span class="p">(</span><span class="n">S1</span><span class="o">*</span><span class="p">(</span><span class="n">q</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="n">q</span><span class="p">))</span>
        <span class="n">ct2</span><span class="o">=</span><span class="p">(</span><span class="n">xi</span> <span class="o">-</span> <span class="n">kappa_inf</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="n">S2</span><span class="o">*</span><span class="p">(</span><span class="n">q</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="n">q</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">ct1</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">ct2</span><span class="p">)</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.updown">
    <p>def <span class="ident">updown</span>(</p><p>q, S1, S2)</p>
    </div>
    

    
  
    <div class="desc"><p>Instability range for up-down aligned binaries. Binaries with the primary
(secondary) spin aligned (antialigned) with the angular momentum are
unstable between the two separations returned. Hack the code to compute also
the function <em>switch</em>, for a sanity check on the property of the second
threshold (whether that's on <a href="#precession.xi_plus"><code>xi_plus</code></a> or on
<a href="#precession.xi_minus"><code>xi_minus</code></a>). All up-down binaries are stable in the equal-mass
case: if q=1 returns Nones.</p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>r_udp,r_udm=precession.updown(q,S1,S2)
</pre></div>


<p><strong>Parameters:</strong></p>
<ul>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>r_udp</code>: upper separation for the up-down instability.</li>
<li><code>r_udm</code>: lower separation for the up-down instability.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.updown', this);">Show source &equiv;</a></p>
  <div id="source-precession.updown" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">updown</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">):</span>
    
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Instability range for up-down aligned binaries. Binaries with the primary</span>
<span class="sd">    (secondary) spin aligned (antialigned) with the angular momentum are</span>
<span class="sd">    unstable between the two separations returned. Hack the code to compute also</span>
<span class="sd">    the function *switch*, for a sanity check on the property of the second</span>
<span class="sd">    threshold (whether that&#39;s on `precession.xi_plus` or on</span>
<span class="sd">    `precession.xi_minus`). All up-down binaries are stable in the equal-mass</span>
<span class="sd">    case: if q=1 returns Nones.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        r_udp,r_udm=precession.updown(q,S1,S2)</span>

<span class="sd">    **Parameters:**</span>

<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    </span>
<span class="sd">    **Returns:**</span>

<span class="sd">    - `r_udp`: upper separation for the up-down instability.</span>
<span class="sd">    - `r_udm`: lower separation for the up-down instability.    </span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="n">q</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&quot;[updown] Warning: up-down is always stable for q=1. Retuning Nones.&quot;</span>
        <span class="k">return</span> <span class="bp">None</span><span class="p">,</span> <span class="bp">None</span>

    <span class="n">r_udp</span><span class="o">=</span><span class="p">((</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span><span class="p">((</span><span class="n">q</span><span class="o">*</span><span class="n">S1</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span> <span class="o">+</span> <span class="n">S2</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">((</span><span class="mf">1.</span><span class="o">-</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">q</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">r_udm</span><span class="o">=</span><span class="p">((</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span><span class="p">((</span><span class="n">q</span><span class="o">*</span><span class="n">S1</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span> <span class="o">-</span> <span class="n">S2</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">((</span><span class="mf">1.</span><span class="o">-</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">q</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span>
    
    <span class="k">if</span> <span class="bp">False</span><span class="p">:</span>
        <span class="n">switch</span><span class="o">=</span><span class="n">q</span><span class="o">**</span><span class="mf">0.5</span><span class="o">+</span> <span class="n">q</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">S2</span><span class="o">/</span><span class="n">S1</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span> <span class="o">-</span> <span class="p">(</span><span class="n">S2</span><span class="o">/</span><span class="n">S1</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">r_udp</span><span class="p">,</span><span class="n">r_udm</span><span class="p">,</span><span class="n">switch</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">r_udp</span><span class="p">,</span><span class="n">r_udm</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.why">
    <p>def <span class="ident">why</span>(</p><p>)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.why', this);">Show source &equiv;</a></p>
  <div id="source-precession.why" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">why</span><span class="p">():</span>
    <span class="k">print</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">It&#39;s all about python and gravity. Go to&quot;</span>
    <span class="k">print</span> <span class="s">&quot;http://imgs.xkcd.com/comics/python.png</span><span class="se">\n</span><span class="s">&quot;</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">()</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.xi_allowed">
    <p>def <span class="ident">xi_allowed</span>(</p><p>J, q, S1, S2, r, more=False, verbose=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Find the allowed range of xi for fixed J, corresponding to the extrema of
the effective potential. Two implementations are presented, and are
controlled by the inner flag use_derivative. If False (default, suggested),
scipy's fminbound minimization algorithm is applied to the effective
potentials <a href="#precession.xi_minus"><code>xi_minus</code></a> and <a href="#precession.xi_plus"><code>xi_plus</code></a>. If True, we
explicitly look for the zeroes of the derivative of the effective potentials
with respect to S. J. Vosmera found that the bisect root finder behaves
better than brentq for low mass ratio. We believe both implementation are
correct: the former has been tested more extensively, the latter has been
found to be more reliable in the q-&gt;1 limit.</p>
<p>WARNING: This function is critical. It's tested, but is tricky numerical
issues may still be present.</p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>xi_low,xi_up=precession.xi_allowed(J,q,S1,S2,r,more=False,verbose=False)

xi_low,xi_up,S_xilow,S_xiup=precession.xi_allowed(J,q,S1,S2,r,more=True,verbose=False)
</pre></div>


<p><strong>Parameters:</strong></p>
<ul>
<li><code>J</code>: magnitude of the total angular momentum.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>r</code>: binary separation.</li>
<li><code>more</code>: if <code>True</code> returns additional quantities.</li>
<li><code>verbose</code>: if <code>True</code> print additional information.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>xi_low</code>: minimum allowed value of xi, given the input parameters.</li>
<li><code>xi_up</code>: maximum allowed value of xi, given the input parameters.</li>
<li><code>S_xilow</code>: (optional) value of S when xi=xi_low.</li>
<li><code>S_xiup</code>: (optional) value of S when xi=xi_up.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.xi_allowed', this);">Show source &equiv;</a></p>
  <div id="source-precession.xi_allowed" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">xi_allowed</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">,</span> <span class="n">more</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Find the allowed range of xi for fixed J, corresponding to the extrema of</span>
<span class="sd">    the effective potential. Two implementations are presented, and are</span>
<span class="sd">    controlled by the inner flag use_derivative. If False (default, suggested),</span>
<span class="sd">    scipy&#39;s fminbound minimization algorithm is applied to the effective</span>
<span class="sd">    potentials `precession.xi_minus` and `precession.xi_plus`. If True, we</span>
<span class="sd">    explicitly look for the zeroes of the derivative of the effective potentials</span>
<span class="sd">    with respect to S. J. Vosmera found that the bisect root finder behaves</span>
<span class="sd">    better than brentq for low mass ratio. We believe both implementation are</span>
<span class="sd">    correct: the former has been tested more extensively, the latter has been</span>
<span class="sd">    found to be more reliable in the q-&gt;1 limit.</span>

<span class="sd">    WARNING: This function is critical. It&#39;s tested, but is tricky numerical</span>
<span class="sd">    issues may still be present.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        xi_low,xi_up=precession.xi_allowed(J,q,S1,S2,r,more=False,verbose=False)</span>

<span class="sd">        xi_low,xi_up,S_xilow,S_xiup=precession.xi_allowed(J,q,S1,S2,r,more=True,verbose=False)</span>


<span class="sd">    **Parameters:**</span>

<span class="sd">    - `J`: magnitude of the total angular momentum.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `r`: binary separation.</span>
<span class="sd">    - `more`: if `True` returns additional quantities.</span>
<span class="sd">    - `verbose`: if `True` print additional information.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `xi_low`: minimum allowed value of xi, given the input parameters.</span>
<span class="sd">    - `xi_up`: maximum allowed value of xi, given the input parameters.</span>
<span class="sd">    - `S_xilow`: (optional) value of S when xi=xi_low.</span>
<span class="sd">    - `S_xiup`: (optional) value of S when xi=xi_up.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="c"># Take care of possible pathologies at the edges of the parameter space</span>
    <span class="n">Jmin</span><span class="p">,</span><span class="n">Jmax</span><span class="o">=</span> <span class="n">J_lim</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">J</span><span class="o">==</span><span class="n">Jmin</span> <span class="ow">or</span> <span class="n">J</span><span class="o">==</span><span class="n">Jmax</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">J</span><span class="o">==</span><span class="n">Jmin</span><span class="p">:</span>
            <span class="n">xiboth</span><span class="p">,</span> <span class="n">dummy</span><span class="p">,</span> <span class="n">Sboth</span><span class="p">,</span> <span class="n">dummy</span> <span class="o">=</span> <span class="n">xi_at_Jlim</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">more</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">J</span><span class="o">==</span><span class="n">Jmax</span><span class="p">:</span>
            <span class="n">dummy</span><span class="p">,</span> <span class="n">xiboth</span><span class="p">,</span> <span class="n">dummy</span><span class="p">,</span> <span class="n">Sboth</span> <span class="o">=</span> <span class="n">xi_at_Jlim</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">more</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">more</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">xiboth</span><span class="p">,</span> <span class="n">xiboth</span><span class="p">,</span> <span class="n">Sboth</span><span class="p">,</span> <span class="n">Sboth</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">xiboth</span><span class="p">,</span> <span class="n">xiboth</span>
    
    <span class="n">St_min</span><span class="p">,</span><span class="n">St_max</span><span class="o">=</span><span class="n">St_limits</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
    
    <span class="c"># The extrema are at S=St_min, St_max</span>
    <span class="k">if</span> <span class="n">q</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">L</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
        <span class="n">xi_low</span><span class="o">=</span><span class="p">(</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">St_max</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">L</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">xi_up</span><span class="o">=</span><span class="p">(</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">St_min</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">L</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">S_xilow</span><span class="o">=</span><span class="n">St_max</span>
        <span class="n">S_xiup</span><span class="o">=</span><span class="n">St_min</span>

    <span class="c"># Extremize the two effective potentials.  </span>
    <span class="k">else</span><span class="p">:</span>
    
        <span class="n">use_derivative</span><span class="o">=</span><span class="bp">False</span>
        
        <span class="c">#Run a minimization algorithms on the effective potentials. </span>
        <span class="k">if</span> <span class="n">use_derivative</span><span class="o">==</span><span class="bp">False</span><span class="p">:</span>
        
            <span class="c"># Minimum of xi_minus</span>
            <span class="n">resmin</span><span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">fminbound</span><span class="p">(</span><span class="k">lambda</span> <span class="n">S</span><span class="p">:</span> <span class="n">xi_minus</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">),</span> <span class="n">St_min</span><span class="p">,</span> <span class="n">St_max</span><span class="p">,</span><span class="n">xtol</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">,</span><span class="n">full_output</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">S_xilow</span><span class="o">=</span><span class="n">resmin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> 
            <span class="n">xi_low</span><span class="o">=</span><span class="n">resmin</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

            <span class="c"># Maximum of xi_plus. Scipy provides minimization algorithms: minimize -xi_plus and change sign at the end.</span>
            <span class="n">resmax</span><span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">fminbound</span><span class="p">(</span><span class="k">lambda</span> <span class="n">S</span><span class="p">:</span> <span class="o">-</span><span class="mf">1.</span><span class="o">*</span><span class="n">xi_plus</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">),</span> <span class="n">St_min</span><span class="p">,</span> <span class="n">St_max</span><span class="p">,</span><span class="n">xtol</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">,</span><span class="n">full_output</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">S_xiup</span><span class="o">=</span><span class="n">resmax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> 
            <span class="n">xi_up</span><span class="o">=-</span><span class="mf">1.</span><span class="o">*</span><span class="n">resmax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c"># Run a root finders on the derivative of the effective potentials. </span>
        <span class="k">elif</span> <span class="n">use_derivative</span><span class="o">==</span><span class="bp">True</span><span class="p">:</span>
        
            <span class="k">if</span> <span class="n">q</span><span class="o">&lt;</span><span class="mf">0.1</span><span class="p">:</span> <span class="c"># bisect behaves better for extreme mass ratios...</span>
                <span class="n">S_xilow</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">bisect</span><span class="p">(</span><span class="k">lambda</span> <span class="n">S</span><span class="p">:</span> <span class="n">dxidS_plus</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">),</span> <span class="n">St_min</span><span class="p">,</span> <span class="n">St_max</span><span class="p">,</span><span class="n">xtol</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">)</span>     
                <span class="n">S_xiup</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">bisect</span><span class="p">(</span><span class="k">lambda</span> <span class="n">S</span><span class="p">:</span> <span class="n">dxidS_minus</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">),</span> <span class="n">St_min</span><span class="p">,</span> <span class="n">St_max</span><span class="p">,</span><span class="n">xtol</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span> <span class="c"># ... but brentq is faster</span>
                <span class="n">S_xilow</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="k">lambda</span> <span class="n">S</span><span class="p">:</span> <span class="n">dxidS_plus</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">),</span> <span class="n">St_min</span><span class="p">,</span> <span class="n">St_max</span><span class="p">,</span><span class="n">xtol</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">)</span>    
                <span class="n">S_xiup</span><span class="o">=</span><span class="n">sp</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">brentq</span><span class="p">(</span><span class="k">lambda</span> <span class="n">S</span><span class="p">:</span> <span class="n">dxidS_minus</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">),</span> <span class="n">St_min</span><span class="p">,</span> <span class="n">St_max</span><span class="p">,</span><span class="n">xtol</span><span class="o">=</span><span class="mf">1e-12</span><span class="p">)</span>
            <span class="n">xi_low</span><span class="o">=</span><span class="n">xi_minus</span><span class="p">(</span><span class="n">S_xilow</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>
            <span class="n">xi_up</span> <span class="o">=</span><span class="n">xi_plus</span><span class="p">(</span><span class="n">S_xiup</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="k">print</span> <span class="s">&quot;[xi_allowed] xi_low&quot;</span><span class="p">,</span> <span class="n">xi_low</span><span class="p">,</span> <span class="s">&quot; xi_up=&quot;</span><span class="p">,</span> <span class="n">xi_up</span>
    <span class="k">if</span> <span class="n">more</span><span class="p">:</span> <span class="c"># Return the S values as well</span>
        <span class="k">return</span> <span class="n">xi_low</span><span class="p">,</span> <span class="n">xi_up</span><span class="p">,</span> <span class="n">S_xilow</span><span class="p">,</span> <span class="n">S_xiup</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">xi_low</span><span class="p">,</span> <span class="n">xi_up</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.xi_at_Jlim">
    <p>def <span class="ident">xi_at_Jlim</span>(</p><p>q, S1, S2, r, more=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Find the value of xi (and S, optional) when J is either Jmax or Jmin.</p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>xi_Jmin,xi_Jmax=precession.xi_at_Jlim(q,S1,S2,r,more=False)
</pre></div>


<p><strong>Parameters:</strong></p>
<ul>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>r</code>: binary separation.</li>
<li><code>more</code>: if <code>True</code> returns additional quantities.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>xi_Jmin</code>: value of xi when J=Jmin.</li>
<li><code>xi_Jmax</code>: value of xi when J=Jmax.</li>
<li><code>S_Jmin</code>: (optional) value of S when J=Jmin.</li>
<li><code>S_Jmax</code>: (optional) value of S when J=Jmax.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.xi_at_Jlim', this);">Show source &equiv;</a></p>
  <div id="source-precession.xi_at_Jlim" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">xi_at_Jlim</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">more</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Find the value of xi (and S, optional) when J is either Jmax or Jmin.</span>
<span class="sd">    </span>
<span class="sd">    **Call:**</span>

<span class="sd">        xi_Jmin,xi_Jmax=precession.xi_at_Jlim(q,S1,S2,r,more=False)</span>
<span class="sd">    </span>
<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `r`: binary separation.</span>
<span class="sd">    - `more`: if `True` returns additional quantities.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `xi_Jmin`: value of xi when J=Jmin.</span>
<span class="sd">    - `xi_Jmax`: value of xi when J=Jmax.</span>
<span class="sd">    - `S_Jmin`: (optional) value of S when J=Jmin.</span>
<span class="sd">    - `S_Jmax`: (optional) value of S when J=Jmax.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="c"># Find Jmin and Jmax</span>
    <span class="n">L</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>    
    <span class="n">Jmin</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="mf">1e-20</span><span class="p">,</span><span class="n">L</span><span class="o">-</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">,</span><span class="n">S1</span><span class="o">-</span><span class="n">L</span><span class="o">-</span><span class="n">S2</span><span class="p">,</span><span class="n">S2</span><span class="o">-</span><span class="n">S1</span><span class="o">-</span><span class="n">L</span><span class="p">)</span>
    <span class="n">Jmax</span><span class="o">=</span><span class="n">L</span><span class="o">+</span><span class="n">S1</span><span class="o">+</span><span class="n">S2</span>
    
    <span class="c"># Everything is aligned at Jmax</span>
    <span class="n">ct1</span><span class="o">=</span><span class="mf">1.</span>
    <span class="n">ct2</span><span class="o">=</span><span class="mf">1.</span>
    <span class="n">xi_Jmax</span><span class="o">=</span> <span class="p">((</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">S1</span><span class="o">*</span><span class="n">ct1</span><span class="o">+</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="o">**-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">S2</span><span class="o">*</span><span class="n">ct2</span><span class="p">)</span><span class="o">*</span><span class="n">M</span><span class="o">**-</span><span class="mi">2</span>
    <span class="n">S_Jmax</span><span class="o">=</span> <span class="n">S1</span><span class="o">+</span><span class="n">S2</span>
    
    <span class="c"># Split the Jmin cases</span>
    <span class="k">if</span> <span class="n">Jmin</span><span class="o">==</span><span class="mf">1e-20</span><span class="p">:</span> <span class="c"># Force vectors in a plane, closed triangle</span>
        <span class="n">ct1</span><span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">S1</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">S2</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">L</span><span class="o">*</span><span class="n">S1</span><span class="p">)</span>
        <span class="n">ct2</span><span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="n">S2</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">S1</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">L</span><span class="o">*</span><span class="n">S2</span><span class="p">)</span>
        <span class="n">S_Jmin</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">elif</span> <span class="n">Jmin</span><span class="o">==</span><span class="n">L</span><span class="o">-</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">:</span> <span class="c"># Both antialigned</span>
        <span class="n">ct1</span><span class="o">=-</span><span class="mf">1.</span>
        <span class="n">ct2</span><span class="o">=-</span><span class="mf">1.</span>
        <span class="n">S_Jmin</span><span class="o">=</span><span class="n">S1</span><span class="o">+</span><span class="n">S2</span>
    <span class="k">elif</span> <span class="n">Jmin</span><span class="o">==</span><span class="n">S1</span><span class="o">-</span><span class="n">L</span><span class="o">-</span><span class="n">S2</span><span class="p">:</span> <span class="c"># One antialigned</span>
        <span class="n">ct1</span><span class="o">=-</span><span class="mf">1.</span>
        <span class="n">ct2</span><span class="o">=</span><span class="mf">1.</span>
        <span class="n">S_Jmin</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">Jmin</span><span class="o">==</span><span class="n">S2</span><span class="o">-</span><span class="n">L</span><span class="o">-</span><span class="n">S1</span><span class="p">:</span> <span class="c"># One antialigned</span>
        <span class="n">ct1</span><span class="o">=</span><span class="mf">1.</span>
        <span class="n">ct2</span><span class="o">=-</span><span class="mf">1.</span>
        <span class="n">S_Jmin</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">)</span>
    <span class="n">xi_Jmin</span><span class="o">=</span> <span class="p">((</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">S1</span><span class="o">*</span><span class="n">ct1</span><span class="o">+</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="o">**-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">S2</span><span class="o">*</span><span class="n">ct2</span><span class="p">)</span><span class="o">*</span><span class="n">M</span><span class="o">**-</span><span class="mi">2</span>
    
    <span class="k">if</span> <span class="n">more</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">xi_Jmin</span><span class="p">,</span> <span class="n">xi_Jmax</span><span class="p">,</span> <span class="n">S_Jmin</span><span class="p">,</span> <span class="n">S_Jmax</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">xi_Jmin</span><span class="p">,</span> <span class="n">xi_Jmax</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.xi_contour">
    <p>def <span class="ident">xi_contour</span>(</p><p>varphi, S, J, q, S1, S2, r)</p>
    </div>
    

    
  
    <div class="desc"><p>Compute the projection of the effective spin xi as a function of the
spin-rotation degree of freedom varphi and the total spin magnitude S.</p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>xi=precession.xi_contour(varphi,S,J,q,S1,S2,r)
</pre></div>


<p><strong>Parameters:</strong></p>
<ul>
<li><code>varphi</code>: angle describing the rotation of S1 and S2 about S, in a frame aligned with J.</li>
<li><code>S</code>: magnitude of the total spin.</li>
<li><code>J</code>: magnitude of the total angular momentum.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>r</code>: binary separation.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.xi_contour', this);">Show source &equiv;</a></p>
  <div id="source-precession.xi_contour" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">xi_contour</span><span class="p">(</span><span class="n">varphi</span><span class="p">,</span><span class="n">S</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Compute the projection of the effective spin xi as a function of the</span>
<span class="sd">    spin-rotation degree of freedom varphi and the total spin magnitude S.</span>
<span class="sd"> </span>
<span class="sd">    **Call:**</span>

<span class="sd">        xi=precession.xi_contour(varphi,S,J,q,S1,S2,r)</span>
<span class="sd">    </span>
<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `varphi`: angle describing the rotation of S1 and S2 about S, in a frame aligned with J.</span>
<span class="sd">    - `S`: magnitude of the total spin.</span>
<span class="sd">    - `J`: magnitude of the total angular momentum.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `r`: binary separation.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">L</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
    <span class="n">t1</span><span class="o">=</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">4.</span><span class="o">*</span><span class="n">q</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">L</span><span class="p">)</span>
    <span class="n">t2</span><span class="o">=</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">t3</span><span class="o">=</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">-</span><span class="p">(</span><span class="n">S1</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">q</span><span class="p">)</span>
    <span class="n">t4</span><span class="o">=</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="p">((</span><span class="n">L</span><span class="o">+</span><span class="n">S</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
    <span class="n">t5</span><span class="o">=</span><span class="p">(</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="n">S</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>             
    <span class="n">t6</span><span class="o">=</span><span class="p">((</span><span class="n">S1</span><span class="o">+</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
    <span class="n">t7</span><span class="o">=</span><span class="p">(</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
    <span class="k">return</span> <span class="n">t1</span><span class="o">*</span><span class="p">((</span><span class="n">t2</span><span class="o">*</span><span class="n">t3</span><span class="p">)</span><span class="o">-</span><span class="p">(</span><span class="n">t4</span><span class="o">*</span><span class="n">t5</span><span class="o">*</span><span class="n">t6</span><span class="o">*</span><span class="n">t7</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">varphi</span><span class="p">)))</span>  
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.xi_lim">
    <p>def <span class="ident">xi_lim</span>(</p><p>q, S1, S2)</p>
    </div>
    

    
  
    <div class="desc"><p>Compute the absolute limits on xi (i.e. regardless of J). Check
<a href="#precession.xi_allowed"><code>xi_allowed</code></a> for the limits on xi for a given J. This functions
is simply checks -1&lt;cos(theta_i)&lt;1.</p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>xi_min,xi_max=precession.xi_lim(q,S1,S2)
</pre></div>


<p><strong>Parameters:</strong></p>
<ul>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>xi_min</code>: minimum value of xi from geometrical constraints.</li>
<li><code>xi_max</code>: maximum value of xi from geometrical constraints.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.xi_lim', this);">Show source &equiv;</a></p>
  <div id="source-precession.xi_lim" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">xi_lim</span><span class="p">(</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Compute the absolute limits on xi (i.e. regardless of J). Check</span>
<span class="sd">    `precession.xi_allowed` for the limits on xi for a given J. This functions</span>
<span class="sd">    is simply checks -1&lt;cos(theta_i)&lt;1.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        xi_min,xi_max=precession.xi_lim(q,S1,S2)</span>
<span class="sd">    </span>
<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    </span>
<span class="sd">    **Returns:**</span>
<span class="sd">    </span>
<span class="sd">    - `xi_min`: minimum value of xi from geometrical constraints.</span>
<span class="sd">    - `xi_max`: maximum value of xi from geometrical constraints.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">xi_max</span><span class="o">=</span> <span class="p">((</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">S1</span><span class="o">+</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="o">**-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">S2</span><span class="p">)</span><span class="o">*</span><span class="n">M</span><span class="o">**-</span><span class="mi">2</span>
    <span class="n">xi_min</span><span class="o">=-</span><span class="mf">1.</span><span class="o">*</span><span class="n">xi_max</span>
    <span class="k">return</span> <span class="n">xi_min</span><span class="p">,</span><span class="n">xi_max</span>    
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.xi_minus">
    <p>def <span class="ident">xi_minus</span>(</p><p>S, J, q, S1, S2, r)</p>
    </div>
    

    
  
    <div class="desc"><p>Lower effective potential, corresponding to cos(varphi)=+1.</p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>xi=precession.xi_minus(S,J,q,S1,S2,r)
</pre></div>


<p><strong>Parameters:</strong></p>
<ul>
<li><code>S</code>: magnitude of the total spin.</li>
<li><code>J</code>: magnitude of the total angular momentum.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>r</code>: binary separation.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.xi_minus', this);">Show source &equiv;</a></p>
  <div id="source-precession.xi_minus" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">xi_minus</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">):</span>
    
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Lower effective potential, corresponding to cos(varphi)=+1.</span>

<span class="sd">    **Call:**</span>

<span class="sd">        xi=precession.xi_minus(S,J,q,S1,S2,r)</span>
<span class="sd">    </span>
<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `S`: magnitude of the total spin.</span>
<span class="sd">    - `J`: magnitude of the total angular momentum.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `r`: binary separation.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="c"># Do it explicitely. Somehow faster than calling xi_contour(np.pi,...)    </span>
    <span class="n">L</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
    <span class="n">t1</span><span class="o">=</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">4.</span><span class="o">*</span><span class="n">q</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">L</span><span class="p">)</span>
    <span class="n">t2</span><span class="o">=</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">t3</span><span class="o">=</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">-</span><span class="p">(</span><span class="n">S1</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">q</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">S</span> <span class="ow">in</span> <span class="n">St_limits</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">):</span> <span class="c">#if you&#39;re on the limits, the second bit must be zero</span>
        <span class="n">t4</span><span class="o">=</span><span class="n">t5</span><span class="o">=</span><span class="n">t6</span><span class="o">=</span><span class="n">t7</span><span class="o">=</span><span class="mf">0.</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">t4</span><span class="o">=</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="p">((</span><span class="n">L</span><span class="o">+</span><span class="n">S</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
        <span class="n">t5</span><span class="o">=</span><span class="p">(</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="n">S</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>             
        <span class="n">t6</span><span class="o">=</span><span class="p">((</span><span class="n">S1</span><span class="o">+</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
        <span class="n">t7</span><span class="o">=</span><span class="p">(</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>    

    <span class="k">return</span> <span class="n">t1</span><span class="o">*</span><span class="p">((</span><span class="n">t2</span><span class="o">*</span><span class="n">t3</span><span class="p">)</span><span class="o">-</span><span class="p">(</span><span class="n">t4</span><span class="o">*</span><span class="n">t5</span><span class="o">*</span><span class="n">t6</span><span class="o">*</span><span class="n">t7</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="p">)))</span>  
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.xi_minus_comp">
    <p>def <span class="ident">xi_minus_comp</span>(</p><p>S, kappa, q, S1, S2, u)</p>
    </div>
    

    
  
    <div class="desc"><p>Auxiliary function, see <a href="#precession.xi_minus"><code>xi_minus</code></a>.</p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>xi=precession.xi_minus_comp(S,kappa,q,S1,S2,u)
</pre></div>


<p><strong>Parameters:</strong></p>
<ul>
<li><code>S</code>: magnitude of the total spin.</li>
<li><code>kappa</code>: rescaling of the total angular momentum to compactify the inspiral domain.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>u</code>: rescaling of the orbital angular momentum to compactify the inspiral domain.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.xi_minus_comp', this);">Show source &equiv;</a></p>
  <div id="source-precession.xi_minus_comp" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">xi_minus_comp</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">kappa</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">u</span><span class="p">):</span>
    
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Auxiliary function, see `precession.xi_minus`.</span>
<span class="sd">        </span>
<span class="sd">    **Call:**</span>

<span class="sd">        xi=precession.xi_minus_comp(S,kappa,q,S1,S2,u)</span>

<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `S`: magnitude of the total spin.</span>
<span class="sd">    - `kappa`: rescaling of the total angular momentum to compactify the inspiral domain.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `u`: rescaling of the orbital angular momentum to compactify the inspiral domain.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="n">t1</span><span class="o">=</span> <span class="n">kappa</span><span class="o">-</span><span class="n">u</span><span class="o">*</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">t2</span><span class="o">=</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">S1</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">q</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">S</span> <span class="ow">in</span> <span class="n">St_limits_comp</span><span class="p">(</span><span class="n">kappa</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">u</span><span class="p">):</span> <span class="c">#if you&#39;re on the limits, the second bit must be zero</span>
        <span class="n">t3</span><span class="o">=</span><span class="n">t4</span><span class="o">=</span><span class="n">t5</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">t3</span><span class="o">=</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">q</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">kappa</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">u</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">S</span><span class="o">**</span><span class="mi">4</span><span class="o">+</span><span class="mf">2.</span><span class="o">*</span><span class="n">u</span><span class="o">*</span><span class="n">kappa</span><span class="o">*</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span>
        <span class="n">t4</span><span class="o">=</span><span class="p">((</span><span class="n">S1</span><span class="o">+</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
        <span class="n">t5</span><span class="o">=</span><span class="p">(</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>    
    <span class="n">t6</span><span class="o">=</span> <span class="mf">2.</span><span class="o">*</span><span class="n">q</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">t1</span><span class="o">*</span><span class="n">t2</span> <span class="o">-</span> <span class="n">t3</span><span class="o">*</span><span class="n">t4</span><span class="o">*</span><span class="n">t5</span><span class="p">)</span><span class="o">/</span><span class="n">t6</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.xi_plus">
    <p>def <span class="ident">xi_plus</span>(</p><p>S, J, q, S1, S2, r)</p>
    </div>
    

    
  
    <div class="desc"><p>Upper effective potential, corresponding to cos(varphi)=-1.</p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>xi=precession.xi_plus(S,J,q,S1,S2,r)
</pre></div>


<p><strong>Parameters:</strong></p>
<ul>
<li><code>S</code>: magnitude of the total spin.</li>
<li><code>J</code>: magnitude of the total angular momentum.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>r</code>: binary separation.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.xi_plus', this);">Show source &equiv;</a></p>
  <div id="source-precession.xi_plus" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">xi_plus</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Upper effective potential, corresponding to cos(varphi)=-1.</span>
<span class="sd"> </span>
<span class="sd">    **Call:**</span>

<span class="sd">        xi=precession.xi_plus(S,J,q,S1,S2,r)</span>

<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `S`: magnitude of the total spin.</span>
<span class="sd">    - `J`: magnitude of the total angular momentum.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `r`: binary separation.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="c"># Do it explicitely. Somehow faster than calling xi_contour(np.pi,...)</span>
    <span class="n">L</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
    <span class="n">t1</span><span class="o">=</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">4.</span><span class="o">*</span><span class="n">q</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">L</span><span class="p">)</span>
    <span class="n">t2</span><span class="o">=</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">L</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">t3</span><span class="o">=</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">-</span><span class="p">(</span><span class="n">S1</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">q</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">S</span> <span class="ow">in</span> <span class="n">St_limits</span><span class="p">(</span><span class="n">J</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">r</span><span class="p">):</span> <span class="c">#if you&#39;re on the limits, the second bit must be zero</span>
        <span class="n">t4</span><span class="o">=</span><span class="n">t5</span><span class="o">=</span><span class="n">t6</span><span class="o">=</span><span class="n">t7</span><span class="o">=</span><span class="mf">0.</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">t4</span><span class="o">=</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="p">((</span><span class="n">L</span><span class="o">+</span><span class="n">S</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
        <span class="n">t5</span><span class="o">=</span><span class="p">(</span><span class="n">J</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">L</span><span class="o">-</span><span class="n">S</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>             
        <span class="n">t6</span><span class="o">=</span><span class="p">((</span><span class="n">S1</span><span class="o">+</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
        <span class="n">t7</span><span class="o">=</span><span class="p">(</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>    

    <span class="k">return</span> <span class="n">t1</span><span class="o">*</span><span class="p">((</span><span class="n">t2</span><span class="o">*</span><span class="n">t3</span><span class="p">)</span><span class="o">-</span><span class="p">(</span><span class="n">t4</span><span class="o">*</span><span class="n">t5</span><span class="o">*</span><span class="n">t6</span><span class="o">*</span><span class="n">t7</span><span class="o">*</span><span class="p">(</span><span class="o">-</span><span class="mf">1.</span><span class="p">)))</span>  
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.xi_plus_comp">
    <p>def <span class="ident">xi_plus_comp</span>(</p><p>S, kappa, q, S1, S2, u)</p>
    </div>
    

    
  
    <div class="desc"><p>Auxiliary function, see <a href="#precession.xi_plus"><code>xi_plus</code></a>.</p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>xi=precession.xi_plus_comp(S,kappa,q,S1,S2,u)
</pre></div>


<p><strong>Parameters:</strong></p>
<ul>
<li><code>S</code>: magnitude of the total spin.</li>
<li><code>kappa</code>: rescaling of the total angular momentum to compactify the inspiral domain.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>u</code>: rescaling of the orbital angular momentum to compactify the inspiral domain.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.xi_plus_comp', this);">Show source &equiv;</a></p>
  <div id="source-precession.xi_plus_comp" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">xi_plus_comp</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">kappa</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">u</span><span class="p">):</span>

    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Auxiliary function, see `precession.xi_plus`.</span>
<span class="sd">    </span>
<span class="sd">    **Call:**</span>

<span class="sd">        xi=precession.xi_plus_comp(S,kappa,q,S1,S2,u)</span>

<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `S`: magnitude of the total spin.</span>
<span class="sd">    - `kappa`: rescaling of the total angular momentum to compactify the inspiral domain.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>
<span class="sd">    - `u`: rescaling of the orbital angular momentum to compactify the inspiral domain.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `xi`: projection of the effective spin along the orbital angular momentum.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">t1</span><span class="o">=</span> <span class="n">kappa</span><span class="o">-</span><span class="n">u</span><span class="o">*</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">t2</span><span class="o">=</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">q</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">S1</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">q</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">S</span> <span class="ow">in</span> <span class="n">St_limits_comp</span><span class="p">(</span><span class="n">kappa</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">,</span><span class="n">u</span><span class="p">):</span> <span class="c">#if you&#39;re on the limits, the second bit must be zero</span>
        <span class="n">t3</span><span class="o">=</span><span class="n">t4</span><span class="o">=</span><span class="n">t5</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">t3</span><span class="o">=</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">q</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">kappa</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">u</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">S</span><span class="o">**</span><span class="mi">4</span><span class="o">+</span><span class="mf">2.</span><span class="o">*</span><span class="n">u</span><span class="o">*</span><span class="n">kappa</span><span class="o">*</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span>        
        <span class="n">t4</span><span class="o">=</span><span class="p">((</span><span class="n">S1</span><span class="o">+</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>
        <span class="n">t5</span><span class="o">=</span><span class="p">(</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="p">(</span><span class="n">S1</span><span class="o">-</span><span class="n">S2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**.</span><span class="mi">5</span>    
    <span class="n">t6</span><span class="o">=</span> <span class="mf">2.</span><span class="o">*</span><span class="n">q</span><span class="o">*</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">S</span><span class="o">**</span><span class="mi">2</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">t1</span><span class="o">*</span><span class="n">t2</span> <span class="o">+</span> <span class="n">t3</span><span class="o">*</span><span class="n">t4</span><span class="o">*</span><span class="n">t5</span><span class="p">)</span><span class="o">/</span><span class="n">t6</span>
</pre></div>

  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.xiinf_allowed">
    <p>def <span class="ident">xiinf_allowed</span>(</p><p>kappa_inf, q, S1, S2)</p>
    </div>
    

    
  
    <div class="desc"><p>Limits on xi for a given value of kappa_inf, obtained forcing
-1&lt;cos(theta_i)&lt;1.</p>
<p><strong>Call:</strong></p>
<div class="codehilite"><pre>xi_low,xi_up=precession.xiinf_allowed(kappa_inf,q,S1,S2)
</pre></div>


<p><strong>Parameters:</strong></p>
<ul>
<li><code>kappa_inf</code>: asymptotic value of kappa at large separations.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>xi_low</code>: minimum allowed value of xi, given the input parameters.</li>
<li><code>xi_up</code>: maximum allowed value of xi, given the input parameters.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.xiinf_allowed', this);">Show source &equiv;</a></p>
  <div id="source-precession.xiinf_allowed" class="source">
    <div class="codehilite"><pre><span class="k">def</span> <span class="nf">xiinf_allowed</span><span class="p">(</span><span class="n">kappa_inf</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">S1</span><span class="p">,</span><span class="n">S2</span><span class="p">):</span>
 
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Limits on xi for a given value of kappa_inf, obtained forcing</span>
<span class="sd">    -1&lt;cos(theta_i)&lt;1.</span>
<span class="sd"> </span>
<span class="sd">    **Call:**</span>

<span class="sd">        xi_low,xi_up=precession.xiinf_allowed(kappa_inf,q,S1,S2)</span>
<span class="sd">    </span>
<span class="sd">    **Parameters:**</span>
<span class="sd">    </span>
<span class="sd">    - `kappa_inf`: asymptotic value of kappa at large separations.</span>
<span class="sd">    - `q`: binary mass ratio. Must be q&lt;=1.</span>
<span class="sd">    - `S1`: spin magnitude of the primary BH.</span>
<span class="sd">    - `S2`: spin magnitude of the secondary BH.</span>

<span class="sd">    **Returns:**</span>

<span class="sd">    - `xi_low`: minimum allowed value of xi, given the input parameters.</span>
<span class="sd">    - `xi_up`: maximum allowed value of xi, given the input parameters.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="n">xi_low</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span> <span class="n">kappa_inf</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">q</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">q</span><span class="o">**-</span><span class="mi">1</span><span class="o">-</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">S2</span> <span class="p">,</span> <span class="n">kappa_inf</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">q</span><span class="o">**-</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">q</span><span class="o">**-</span><span class="mi">1</span><span class="o">-</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">S1</span> <span class="p">)</span>
    <span class="n">xi_up</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span> <span class="n">kappa_inf</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">q</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">q</span><span class="o">**-</span><span class="mi">1</span><span class="o">-</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">S2</span> <span class="p">,</span> <span class="n">kappa_inf</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">q</span><span class="o">**-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">q</span><span class="o">**-</span><span class="mi">1</span><span class="o">-</span><span class="n">q</span><span class="p">)</span><span class="o">*</span><span class="n">S1</span> <span class="p">)</span>
    <span class="k">return</span> <span class="n">xi_low</span><span class="p">,</span><span class="n">xi_up</span>
</pre></div>

  </div>
</div>

  </div>
  


    <h2 class="section-title" id="header-submodules">Sub-modules</h2>
      <div class="item">
      <p class="name"><a href="test/index.html">precession.test</a></p>
      
  
    <div class="desc"><p>This submodule provides practical examples to illustrate the main features of
<code>precession</code>. Examples are illustrated in </p>
<ul>
<li><em>Precession. Dynamics of spinning black-hole binaries with Python.</em> 
Davide Gerosa. Submitted to... arXiv:...</li>
</ul>
<p>This submodule has to be loaded separately:</p>
<div class="codehilite"><pre><span class="kn">import</span> <span class="nn">precessio...</span>
</pre></div></div>

      </div>
  </section>

    </article>
  <div class="clear"> </div>
  <footer id="footer">
    <p>
      Documentation generated by
      <a href="https://github.com/BurntSushi/pdoc">pdoc 0.3.1</a>
    </p>

    <p>pdoc is in the public domain with the
      <a href="http://unlicense.org">UNLICENSE</a></p>

    <p>Design by <a href="http://nadh.in">Kailash Nadh</a></p>
  </footer>
</div>
</body>
</html>
