<!doctype html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />

    <title>precession API documentation</title>
    <meta name="description" content="**Author** Davide Gerosa

**email** d.gerosa@damtp.cam.ac.uk

**Copyright** Copyright (C) 2015 David..." />

  <link href='http://fonts.googleapis.com/css?family=Source+Sans+Pro:400,300' rel='stylesheet' type='text/css'>
  
  <style type="text/css">
  
* {
  box-sizing: border-box;
}
/*! normalize.css v1.1.1 | MIT License | git.io/normalize */

/* ==========================================================================
   HTML5 display definitions
   ========================================================================== */

/**
 * Correct `block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

article,
aside,
details,
figcaption,
figure,
footer,
header,
hgroup,
main,
nav,
section,
summary {
    display: block;
}

/**
 * Correct `inline-block` display not defined in IE 6/7/8/9 and Firefox 3.
 */

audio,
canvas,
video {
    display: inline-block;
    *display: inline;
    *zoom: 1;
}

/**
 * Prevent modern browsers from displaying `audio` without controls.
 * Remove excess height in iOS 5 devices.
 */

audio:not([controls]) {
    display: none;
    height: 0;
}

/**
 * Address styling not present in IE 7/8/9, Firefox 3, and Safari 4.
 * Known issue: no IE 6 support.
 */

[hidden] {
    display: none;
}

/* ==========================================================================
   Base
   ========================================================================== */

/**
 * 1. Prevent system color scheme's background color being used in Firefox, IE,
 *    and Opera.
 * 2. Prevent system color scheme's text color being used in Firefox, IE, and
 *    Opera.
 * 3. Correct text resizing oddly in IE 6/7 when body `font-size` is set using
 *    `em` units.
 * 4. Prevent iOS text size adjust after orientation change, without disabling
 *    user zoom.
 */

html {
    background: #fff; /* 1 */
    color: #000; /* 2 */
    font-size: 100%; /* 3 */
    -webkit-text-size-adjust: 100%; /* 4 */
    -ms-text-size-adjust: 100%; /* 4 */
}

/**
 * Address `font-family` inconsistency between `textarea` and other form
 * elements.
 */

html,
button,
input,
select,
textarea {
    font-family: sans-serif;
}

/**
 * Address margins handled incorrectly in IE 6/7.
 */

body {
    margin: 0;
}

/* ==========================================================================
   Links
   ========================================================================== */

/**
 * Address `outline` inconsistency between Chrome and other browsers.
 */

a:focus {
    outline: thin dotted;
}

/**
 * Improve readability when focused and also mouse hovered in all browsers.
 */

a:active,
a:hover {
    outline: 0;
}

/* ==========================================================================
   Typography
   ========================================================================== */

/**
 * Address font sizes and margins set differently in IE 6/7.
 * Address font sizes within `section` and `article` in Firefox 4+, Safari 5,
 * and Chrome.
 */

h1 {
    font-size: 2em;
    margin: 0.67em 0;
}

h2 {
    font-size: 1.5em;
    margin: 0.83em 0;
}

h3 {
    font-size: 1.17em;
    margin: 1em 0;
}

h4 {
    font-size: 1em;
    margin: 1.33em 0;
}

h5 {
    font-size: 0.83em;
    margin: 1.67em 0;
}

h6 {
    font-size: 0.67em;
    margin: 2.33em 0;
}

/**
 * Address styling not present in IE 7/8/9, Safari 5, and Chrome.
 */

abbr[title] {
    border-bottom: 1px dotted;
}

/**
 * Address style set to `bolder` in Firefox 3+, Safari 4/5, and Chrome.
 */

b,
strong {
    font-weight: bold;
}

blockquote {
    margin: 1em 40px;
}

/**
 * Address styling not present in Safari 5 and Chrome.
 */

dfn {
    font-style: italic;
}

/**
 * Address differences between Firefox and other browsers.
 * Known issue: no IE 6/7 normalization.
 */

hr {
    -moz-box-sizing: content-box;
    box-sizing: content-box;
    height: 0;
}

/**
 * Address styling not present in IE 6/7/8/9.
 */

mark {
    background: #ff0;
    color: #000;
}

/**
 * Address margins set differently in IE 6/7.
 */

p,
pre {
    margin: 1em 0;
}

/**
 * Correct font family set oddly in IE 6, Safari 4/5, and Chrome.
 */

code,
kbd,
pre,
samp {
    font-family: monospace, serif;
    _font-family: 'courier new', monospace;
    font-size: 1em;
}

/**
 * Improve readability of pre-formatted text in all browsers.
 */

pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
}

/**
 * Address CSS quotes not supported in IE 6/7.
 */

q {
    quotes: none;
}

/**
 * Address `quotes` property not supported in Safari 4.
 */

q:before,
q:after {
    content: '';
    content: none;
}

/**
 * Address inconsistent and variable font size in all browsers.
 */

small {
    font-size: 80%;
}

/**
 * Prevent `sub` and `sup` affecting `line-height` in all browsers.
 */

sub,
sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
}

sup {
    top: -0.5em;
}

sub {
    bottom: -0.25em;
}

/* ==========================================================================
   Lists
   ========================================================================== */

/**
 * Address margins set differently in IE 6/7.
 */

dl,
menu,
ol,
ul {
    margin: 1em 0;
}

dd {
    margin: 0 0 0 40px;
}

/**
 * Address paddings set differently in IE 6/7.
 */

menu,
ol,
ul {
    padding: 0 0 0 40px;
}

/**
 * Correct list images handled incorrectly in IE 7.
 */

nav ul,
nav ol {
    list-style: none;
    list-style-image: none;
}

/* ==========================================================================
   Embedded content
   ========================================================================== */

/**
 * 1. Remove border when inside `a` element in IE 6/7/8/9 and Firefox 3.
 * 2. Improve image quality when scaled in IE 7.
 */

img {
    border: 0; /* 1 */
    -ms-interpolation-mode: bicubic; /* 2 */
}

/**
 * Correct overflow displayed oddly in IE 9.
 */

svg:not(:root) {
    overflow: hidden;
}

/* ==========================================================================
   Figures
   ========================================================================== */

/**
 * Address margin not present in IE 6/7/8/9, Safari 5, and Opera 11.
 */

figure {
    margin: 0;
}

/* ==========================================================================
   Forms
   ========================================================================== */

/**
 * Correct margin displayed oddly in IE 6/7.
 */

form {
    margin: 0;
}

/**
 * Define consistent border, margin, and padding.
 */

fieldset {
    border: 1px solid #c0c0c0;
    margin: 0 2px;
    padding: 0.35em 0.625em 0.75em;
}

/**
 * 1. Correct color not being inherited in IE 6/7/8/9.
 * 2. Correct text not wrapping in Firefox 3.
 * 3. Correct alignment displayed oddly in IE 6/7.
 */

legend {
    border: 0; /* 1 */
    padding: 0;
    white-space: normal; /* 2 */
    *margin-left: -7px; /* 3 */
}

/**
 * 1. Correct font size not being inherited in all browsers.
 * 2. Address margins set differently in IE 6/7, Firefox 3+, Safari 5,
 *    and Chrome.
 * 3. Improve appearance and consistency in all browsers.
 */

button,
input,
select,
textarea {
    font-size: 100%; /* 1 */
    margin: 0; /* 2 */
    vertical-align: baseline; /* 3 */
    *vertical-align: middle; /* 3 */
}

/**
 * Address Firefox 3+ setting `line-height` on `input` using `!important` in
 * the UA stylesheet.
 */

button,
input {
    line-height: normal;
}

/**
 * Address inconsistent `text-transform` inheritance for `button` and `select`.
 * All other form control elements do not inherit `text-transform` values.
 * Correct `button` style inheritance in Chrome, Safari 5+, and IE 6+.
 * Correct `select` style inheritance in Firefox 4+ and Opera.
 */

button,
select {
    text-transform: none;
}

/**
 * 1. Avoid the WebKit bug in Android 4.0.* where (2) destroys native `audio`
 *    and `video` controls.
 * 2. Correct inability to style clickable `input` types in iOS.
 * 3. Improve usability and consistency of cursor style between image-type
 *    `input` and others.
 * 4. Remove inner spacing in IE 7 without affecting normal text inputs.
 *    Known issue: inner spacing remains in IE 6.
 */

button,
html input[type="button"], /* 1 */
input[type="reset"],
input[type="submit"] {
    -webkit-appearance: button; /* 2 */
    cursor: pointer; /* 3 */
    *overflow: visible;  /* 4 */
}

/**
 * Re-set default cursor for disabled elements.
 */

button[disabled],
html input[disabled] {
    cursor: default;
}

/**
 * 1. Address box sizing set to content-box in IE 8/9.
 * 2. Remove excess padding in IE 8/9.
 * 3. Remove excess padding in IE 7.
 *    Known issue: excess padding remains in IE 6.
 */

input[type="checkbox"],
input[type="radio"] {
    box-sizing: border-box; /* 1 */
    padding: 0; /* 2 */
    *height: 13px; /* 3 */
    *width: 13px; /* 3 */
}

/**
 * 1. Address `appearance` set to `searchfield` in Safari 5 and Chrome.
 * 2. Address `box-sizing` set to `border-box` in Safari 5 and Chrome
 *    (include `-moz` to future-proof).
 */

input[type="search"] {
    -webkit-appearance: textfield; /* 1 */
    -moz-box-sizing: content-box;
    -webkit-box-sizing: content-box; /* 2 */
    box-sizing: content-box;
}

/**
 * Remove inner padding and search cancel button in Safari 5 and Chrome
 * on OS X.
 */

input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration {
    -webkit-appearance: none;
}

/**
 * Remove inner padding and border in Firefox 3+.
 */

button::-moz-focus-inner,
input::-moz-focus-inner {
    border: 0;
    padding: 0;
}

/**
 * 1. Remove default vertical scrollbar in IE 6/7/8/9.
 * 2. Improve readability and alignment in all browsers.
 */

textarea {
    overflow: auto; /* 1 */
    vertical-align: top; /* 2 */
}

/* ==========================================================================
   Tables
   ========================================================================== */

/**
 * Remove most spacing between table cells.
 */

table {
    border-collapse: collapse;
    border-spacing: 0;
}

  </style>

  <style type="text/css">
  
  html, body {
    margin: 0;
    padding: 0;
    height: 100%;
  }
  body {
    background: #fff;
    font-family: "Source Sans Pro", "Helvetica Neueue", Helvetica, sans;
    font-weight: 300;
    font-size: 16px;
    line-height: 1.6em;
  }
  #content {
    width: 70%;
    max-width: 850px;
    float: left;
    padding: 30px 60px;
    border-left: 1px solid #ddd;
  }
  #sidebar {
    width: 25%;
    float: left;
    padding: 30px;
    overflow: hidden;
  }
  #nav {
    font-size: 130%;
    margin: 0 0 15px 0;
  }

  #top {
    display: block;
    position: fixed;
    bottom: 5px;
    left: 5px;
    font-size: .85em;
    text-transform: uppercase;
  }

  #footer {
    font-size: .75em;
    padding: 5px 30px;
    border-top: 1px solid #ddd;
    text-align: right;
  }
    #footer p {
      margin: 0 0 0 30px;
      display: inline-block;
    }

  h1, h2, h3, h4, h5 {
    font-weight: 300;
  }
  h1 {
    font-size: 2.5em;
    line-height: 1.1em;
    margin: 0 0 .50em 0;
  }

  h2 {
    font-size: 1.75em;
    margin: 1em 0 .50em 0;
  }

  h3 {
    margin: 25px 0 10px 0;
  }

  h4 {
    margin: 0;
    font-size: 105%;
  }

  a {
    color: #058;
    text-decoration: none;
    transition: color .3s ease-in-out;
  }

  a:hover {
    color: #e08524;
    transition: color .3s ease-in-out;
  }

  pre, code, .mono, .name {
    font-family: "Ubuntu Mono", "Cousine", "DejaVu Sans Mono", monospace;
  }

  .title .name {
    font-weight: bold;
  }
  .section-title {
    margin-top: 2em;
  }
  .ident {
    color: #900;
  }

  code {
    background: #f9f9f9;
  } 

  pre {
    background: #fefefe;
    border: 1px solid #ddd;
    box-shadow: 2px 2px 0 #f3f3f3;
    margin: 0 30px;
    padding: 15px 30px;
  }

  .codehilite {
    margin: 0 30px 10px 30px;
  }

    .codehilite pre {
      margin: 0;
    }
    .codehilite .err { background: #ff3300; color: #fff !important; } 

  table#module-list {
    font-size: 110%;
  }

    table#module-list tr td:first-child {
      padding-right: 10px;
      white-space: nowrap;
    }

    table#module-list td {
      vertical-align: top;
      padding-bottom: 8px;
    }

      table#module-list td p {
        margin: 0 0 7px 0;
      }

  .def {
    display: table;
  }

    .def p {
      display: table-cell;
      vertical-align: top;
      text-align: left;
    }

    .def p:first-child {
      white-space: nowrap;
    }

    .def p:last-child {
      width: 100%;
    }


  #index {
    list-style-type: none;
    margin: 0;
    padding: 0;
  }
    ul#index .class_name {
      /* font-size: 110%; */
      font-weight: bold;
    }
    #index ul {
      margin: 0;
    }

  .item {
    margin: 0 0 15px 0;
  }

    .item .class {
      margin: 0 0 25px 30px;
    }

      .item .class ul.class_list {
        margin: 0 0 20px 0;
      }

    .item .name {
      background: #fafafa;
      margin: 0;
      font-weight: bold;
      padding: 5px 10px;
      border-radius: 3px;
      display: inline-block;
      min-width: 40%;
    }
      .item .name:hover {
        background: #f6f6f6;
      }

    .item .empty_desc {
      margin: 0 0 5px 0;
      padding: 0;
    }

    .item .inheritance {
      margin: 3px 0 0 30px;
    }

    .item .inherited {
      color: #666;
    }

    .item .desc {
      padding: 0 8px;
      margin: 0;
    }

      .item .desc p {
        margin: 0 0 10px 0;
      }

    .source_cont {
      margin: 0;
      padding: 0;
    }

    .source_link a {
      background: #ffc300;
      font-weight: 400;
      font-size: .75em;
      text-transform: uppercase;
      color: #fff;
      text-shadow: 1px 1px 0 #f4b700;
      
      padding: 3px 8px;
      border-radius: 2px;
      transition: background .3s ease-in-out;
    }
      .source_link a:hover {
        background: #FF7200;
        text-shadow: none;
        transition: background .3s ease-in-out;
      }

    .source {
      display: none;
      max-height: 600px;
      overflow-y: scroll;
      margin-bottom: 15px;
    }

      .source .codehilite {
        margin: 0;
      }

  .desc h1, .desc h2, .desc h3 {
    font-size: 100% !important;
  }
  .clear {
    clear: both;
  }

  @media all and (max-width: 950px) {
    #sidebar {
      width: 35%;
    }
    #content {
      width: 65%;
    }
  }
  @media all and (max-width: 650px) {
    #top {
      display: none;
    }
    #sidebar {
      float: none;
      width: auto;
    }
    #content {
      float: none;
      width: auto;
      padding: 30px;
    }

    #index ul {
      padding: 0;
      margin-bottom: 15px;
    }
    #index ul li {
      display: inline-block;
      margin-right: 30px;
    }
    #footer {
      text-align: left;
    }
    #footer p {
      display: block;
      margin: inherit;
    }
  }

  /*****************************/

  </style>


  <style type="text/css">
  
/* ==========================================================================
   EXAMPLE Media Queries for Responsive Design.
   These examples override the primary ('mobile first') styles.
   Modify as content requires.
   ========================================================================== */

@media only screen and (min-width: 35em) {
    /* Style adjustments for viewports that meet the condition */
}

@media print,
       (-o-min-device-pixel-ratio: 5/4),
       (-webkit-min-device-pixel-ratio: 1.25),
       (min-resolution: 120dpi) {
    /* Style adjustments for high resolution devices */
}

/* ==========================================================================
   Print styles.
   Inlined to avoid required HTTP connection: h5bp.com/r
   ========================================================================== */

@media print {
    * {
        background: transparent !important;
        color: #000 !important; /* Black prints faster: h5bp.com/s */
        box-shadow: none !important;
        text-shadow: none !important;
    }

    a,
    a:visited {
        text-decoration: underline;
    }

    a[href]:after {
        content: " (" attr(href) ")";
    }

    abbr[title]:after {
        content: " (" attr(title) ")";
    }

    /*
     * Don't show links for images, or javascript/internal links
     */

    .ir a:after,
    a[href^="javascript:"]:after,
    a[href^="#"]:after {
        content: "";
    }

    pre,
    blockquote {
        border: 1px solid #999;
        page-break-inside: avoid;
    }

    thead {
        display: table-header-group; /* h5bp.com/t */
    }

    tr,
    img {
        page-break-inside: avoid;
    }

    img {
        max-width: 100% !important;
    }

    @page {
        margin: 0.5cm;
    }

    p,
    h2,
    h3 {
        orphans: 3;
        widows: 3;
    }

    h2,
    h3 {
        page-break-after: avoid;
    }
}

  </style>

  <script type="text/javascript">
  function toggle(id, $link) {
    $node = document.getElementById(id);
    if (!$node)
    return;
    if (!$node.style.display || $node.style.display == 'none') {
    $node.style.display = 'block';
    $link.innerHTML = 'Hide source &nequiv;';
    } else {
    $node.style.display = 'none';
    $link.innerHTML = 'Show source &equiv;';
    }
  }
  </script>
</head>
<body>
<a href="#" id="top">Top</a>

<div id="container">
    
  
  <div id="sidebar">
    <h1>Index</h1>
    <ul id="index">
    <li class="set"><h3><a href="#header-variables">Module variables</a></h3>
      
  <ul>
    <li class="mono"><a href="#precession.M">M</a></li>
    <li class="mono"><a href="#precession.flags_q1">flags_q1</a></li>
    <li class="mono"><a href="#precession.storedir">storedir</a></li>
  </ul>

    </li>

    <li class="set"><h3><a href="#header-functions">Functions</a></h3>
      
  <ul>
    <li class="mono"><a href="#precession.J_allowed">J_allowed</a></li>
    <li class="mono"><a href="#precession.J_lim">J_lim</a></li>
    <li class="mono"><a href="#precession.Jframe_projection">Jframe_projection</a></li>
    <li class="mono"><a href="#precession.Jofr">Jofr</a></li>
    <li class="mono"><a href="#precession.Jofr_checkpoint">Jofr_checkpoint</a></li>
    <li class="mono"><a href="#precession.Jofr_infinity">Jofr_infinity</a></li>
    <li class="mono"><a href="#precession.Jofr_infinity_checkpoint">Jofr_infinity_checkpoint</a></li>
    <li class="mono"><a href="#precession.Omegaz">Omegaz</a></li>
    <li class="mono"><a href="#precession.OmegazdtdS">OmegazdtdS</a></li>
    <li class="mono"><a href="#precession.S3sines_comp">S3sines_comp</a></li>
    <li class="mono"><a href="#precession.Sb_limits">Sb_limits</a></li>
    <li class="mono"><a href="#precession.Sb_limits_comp">Sb_limits_comp</a></li>
    <li class="mono"><a href="#precession.Ssines_comp">Ssines_comp</a></li>
    <li class="mono"><a href="#precession.Sso_limits">Sso_limits</a></li>
    <li class="mono"><a href="#precession.St_limits">St_limits</a></li>
    <li class="mono"><a href="#precession.St_limits_comp">St_limits_comp</a></li>
    <li class="mono"><a href="#precession.alpha_of_S">alpha_of_S</a></li>
    <li class="mono"><a href="#precession.alphaz">alphaz</a></li>
    <li class="mono"><a href="#precession.cutoff">cutoff</a></li>
    <li class="mono"><a href="#precession.dJdL">dJdL</a></li>
    <li class="mono"><a href="#precession.dJdr">dJdr</a></li>
    <li class="mono"><a href="#precession.dSdt">dSdt</a></li>
    <li class="mono"><a href="#precession.dkappadu">dkappadu</a></li>
    <li class="mono"><a href="#precession.dtdS">dtdS</a></li>
    <li class="mono"><a href="#precession.dxidS_minus">dxidS_minus</a></li>
    <li class="mono"><a href="#precession.dxidS_plus">dxidS_plus</a></li>
    <li class="mono"><a href="#precession.empty_temp">empty_temp</a></li>
    <li class="mono"><a href="#precession.evolve_J">evolve_J</a></li>
    <li class="mono"><a href="#precession.evolve_J_backwards">evolve_J_backwards</a></li>
    <li class="mono"><a href="#precession.evolve_J_infinity">evolve_J_infinity</a></li>
    <li class="mono"><a href="#precession.evolve_angles">evolve_angles</a></li>
    <li class="mono"><a href="#precession.evolve_angles_single">evolve_angles_single</a></li>
    <li class="mono"><a href="#precession.find_morphology">find_morphology</a></li>
    <li class="mono"><a href="#precession.from_the_angles">from_the_angles</a></li>
    <li class="mono"><a href="#precession.from_the_angles_inf">from_the_angles_inf</a></li>
    <li class="mono"><a href="#precession.ftor">ftor</a></li>
    <li class="mono"><a href="#precession.get_fixed">get_fixed</a></li>
    <li class="mono"><a href="#precession.get_varphi">get_varphi</a></li>
    <li class="mono"><a href="#precession.hybrid">hybrid</a></li>
    <li class="mono"><a href="#precession.hybrid_single">hybrid_single</a></li>
    <li class="mono"><a href="#precession.kappa_backwards">kappa_backwards</a></li>
    <li class="mono"><a href="#precession.kappa_backwards_checkpoint">kappa_backwards_checkpoint</a></li>
    <li class="mono"><a href="#precession.kappainf_allowed">kappainf_allowed</a></li>
    <li class="mono"><a href="#precession.kappainf_lim">kappainf_lim</a></li>
    <li class="mono"><a href="#precession.make_temp">make_temp</a></li>
    <li class="mono"><a href="#precession.orbav_eqs">orbav_eqs</a></li>
    <li class="mono"><a href="#precession.orbav_integrator">orbav_integrator</a></li>
    <li class="mono"><a href="#precession.orbav_integrator_checkpoint">orbav_integrator_checkpoint</a></li>
    <li class="mono"><a href="#precession.orbit_angles">orbit_angles</a></li>
    <li class="mono"><a href="#precession.orbit_angles_single">orbit_angles_single</a></li>
    <li class="mono"><a href="#precession.orbit_averaged">orbit_averaged</a></li>
    <li class="mono"><a href="#precession.parametric_angles">parametric_angles</a></li>
    <li class="mono"><a href="#precession.phase_checker">phase_checker</a></li>
    <li class="mono"><a href="#precession.phase_xi">phase_xi</a></li>
    <li class="mono"><a href="#precession.precession_period">precession_period</a></li>
    <li class="mono"><a href="#precession.region_selection">region_selection</a></li>
    <li class="mono"><a href="#precession.resonant_finder">resonant_finder</a></li>
    <li class="mono"><a href="#precession.rtof">rtof</a></li>
    <li class="mono"><a href="#precession.samplingS">samplingS</a></li>
    <li class="mono"><a href="#precession.t_of_S">t_of_S</a></li>
    <li class="mono"><a href="#precession.thetas_inf">thetas_inf</a></li>
    <li class="mono"><a href="#precession.updown">updown</a></li>
    <li class="mono"><a href="#precession.why">why</a></li>
    <li class="mono"><a href="#precession.xi_allowed">xi_allowed</a></li>
    <li class="mono"><a href="#precession.xi_at_Jlim">xi_at_Jlim</a></li>
    <li class="mono"><a href="#precession.xi_contour">xi_contour</a></li>
    <li class="mono"><a href="#precession.xi_lim">xi_lim</a></li>
    <li class="mono"><a href="#precession.xi_minus">xi_minus</a></li>
    <li class="mono"><a href="#precession.xi_minus_comp">xi_minus_comp</a></li>
    <li class="mono"><a href="#precession.xi_plus">xi_plus</a></li>
    <li class="mono"><a href="#precession.xi_plus_comp">xi_plus_comp</a></li>
    <li class="mono"><a href="#precession.xiinf_allowed">xiinf_allowed</a></li>
  </ul>

    </li>


    <li class="set"><h3><a href="#header-submodules">Sub-modules</a></h3>
      <ul>
        <li class="mono"><a href="tutorial.m.html">precession.tutorial</a></li>
      </ul>
    </li>
    </ul>
  </div>

    <article id="content">
      
  

  


  <header id="section-intro">
  <h1 class="title"><span class="name">precession</span> module</h1>
  <p><strong>Author</strong> Davide Gerosa</p>
<p><strong>email</strong> d.gerosa@damtp.cam.ac.uk</p>
<p><strong>Copyright</strong> Copyright (C) 2015 Davide Gerosa</p>
<p><strong>Licence</strong> CC by-nc-sa 3.0</p>
<p><strong>Version</strong> 0.0.0.19</p>
<h1>DYNAMICS OF PRECESSING BLACK-HOLE BINARIES</h1>
<p>Detailed documentation and results from the code are available at:</p>
<ul>
<li><a href="www.damtp.cam.ac.uk/user/dg438/spinprecession">www.damtp.cam.ac.uk/user/dg438/spinprecession</a> </li>
<li><a href="www.davidegerosa.com/spinprecession">www.davidegerosa.com/spinprecession</a></li>
</ul>
<p>This code is released to the community under the <a href="http://creativecommons.org/licenses/by-nc-sa/3.0">Creative Commons
attribution-noncommercial-sharealike
license</a>. Essentially, you may
use <code>precession</code>, but must make reference to our work, and you must not use it
for commercial purposes. Any code where precession is used, must be released
under the same licence.  When using precession in any published work, you must
cite the papers describing its implementation:</p>
<p>ADD REFERENCE TO CODE PAPER HERE!</p>
<h3>INSTALLATION</h3>
<p><code>precession</code> works in python 2.x and has been tested on 2.7.10. It can be
installed through pip:</p>
<pre><code>pip install precession
</code></pre>
<p>Prerequisites are <code>numpy</code>, <code>scipy</code> and <code>parmap</code>. All can be installed through
pip.</p>
<h3>THINGS TO KEEP IN MIND</h3>
<ol>
<li>
<p><strong>Units</strong>. All quantities in the code are specified in units where c=G=1.
Moreover, the binary total mass M=m1+m2 is  set to 1, and everything else is
computed accordingly. In practice, this means that e.g. the binary separation r
is actually r/M. If you are trying to use <code>precession</code> from a code with
different units (lal?), you should just pass r/M instead of your cgs or SI r.
Equivalently, the angular momentum L, the spins Si and the total angular
momentum J are actually L/M^2, Si/M^2 and J/M^2.</p>
</li>
<li>
<p><strong>Don't go too close to the limits (i)</strong>. This is a code to study double-spin
precession and, in general, it won't behave nicely if you are too close to
aligned, hence non-precessing, configurations. These configurations are given by
the limits Jmin and Jmax of the total angular momentum J, and/or by
sin(theta_i)=0. I strongly recommend to always set a tolerance, for instance,</p>
<pre><code>Jmin,Jmax=precession.J_lim(q,S1,S2,r) for J in
numpy.linspace(Jmin+1e-4,Jmax-1e-4,100): 
    do things...
</code></pre>
</li>
<li>
<p><strong>Don't go too close to the limits (ii)</strong>. For the same reason, some
quantities cannot be computed efficiently for binaries which are very close to a
spin-orbit resonance (which indeed does not precess at all!). For instance,  the
computation of the angle alpha is somewhat unstable close to xi_min and xi_max
as returned by xi_allowed. Richard O'Shaughnessy found that a tolerance of 2e-3
on xi works well.</p>
</li>
<li>
<p><strong>Checkpointing</strong>. Checkpointing is implemented in some functions for
computational efficiency. Temporary data are stored in a local directory and
will be read in if available. To delete all previous data run</p>
<pre><code>precession.empty_temp()
</code></pre>
<p>By default, data are stored in a local directory called <code>checkpoints</code>, which
is created when needed. You can change it setting</p>
<pre><code>precession.storedir=[path]
</code></pre>
</li>
<li>
<p><strong>Parallelization</strong>. Some parts of the code are parallelized using the
<code>parmap</code> module. Instructions on code parallelization are set by the global
variable CPUs - <code>CPUs=1</code>: no parallelization will be used; - <code>CPUs=integer</code>: to
specify the actual number of cores to be used; - <code>CPUs=0</code> (default): all CPUs in
the current machine will be used.</p>
<p>You can set this variable using</p>
<pre><code>precession.CPUs = [integer]
</code></pre>
</li>
<li>
<p><strong>The equal-mass limit</strong>. The equal-mass q=1 limit requires some extra care.
If q=1 the total-spin magnitude S cannot be used to parametrize the precession
cycle and the angle varphi needs to be tracked explicitly. The q=1 case is
implemented in the code: inputs and outputs of some of the functions are
actually specified in cos(varphi), even if for simplicity we still call them
<strong>S</strong>. In case of precession-averaged integrations to/from infinity, kappa_inf
becomes degenerate with xi and a required initial value of S is required.
Please, refer to the documentation below for details. The generic unequal-mass
part of the code works fine up to q&lt;0.9999. To run higher values of q we
recommend setting q=1.</p>
</li>
<li>
<p><strong>Stalling</strong>. When performing precession-averaged evolutions, some binaires
may occasionally stall and take longer to run. This is due to the first step
attempted by the ODE integrator. This is a minor issue and  only happens to
roughly one binary in a million or so. If you really want to fix this, you
should play with the h0 optional paramenter in scipy's odeint function.</p>
</li>
</ol>
<h3>THANKS</h3>
<p>The code is developed and maintained by <a href="www.davidegerosa.com">Davide Gerosa</a>. 
Please, report bugs to</p>
<pre><code>d.gerosa@damtp.cam.ac.uk
</code></pre>
<p>I'm happy to help you out! </p>
<p>I'd like to thank E.
Berti, M. Kesden, U. Sperhake, R. O'Shaughnessy, D. Trifiro' and J. Vosmera for
the help receiving in interpreting the physical results and implementing some of
the algorithms.</p>
  
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession', this);">Show source &equiv;</a></p>
  <div id="source-precession" class="source">
    <pre><code>'''
# DYNAMICS OF PRECESSING BLACK-HOLE BINARIES

Detailed documentation and results from the code are available at:

- [www.damtp.cam.ac.uk/user/dg438/spinprecession](www.damtp.cam.ac.uk/user/dg438/spinprecession) 
- [www.davidegerosa.com/spinprecession](www.davidegerosa.com/spinprecession)

This code is released to the community under the [Creative Commons
attribution-noncommercial-sharealike
license](http://creativecommons.org/licenses/by-nc-sa/3.0). Essentially, you may
use `precession`, but must make reference to our work, and you must not use it
for commercial purposes. Any code where precession is used, must be released
under the same licence.  When using precession in any published work, you must
cite the papers describing its implementation:

ADD REFERENCE TO CODE PAPER HERE!

### INSTALLATION
 
`precession` works in python 2.x and has been tested on 2.7.10. It can be
installed through pip:

    pip install precession

Prerequisites are `numpy`, `scipy` and `parmap`. All can be installed through
pip.


### THINGS TO KEEP IN MIND

1. **Units**. All quantities in the code are specified in units where c=G=1.
Moreover, the binary total mass M=m1+m2 is  set to 1, and everything else is
computed accordingly. In practice, this means that e.g. the binary separation r
is actually r/M. If you are trying to use `precession` from a code with
different units (lal?), you should just pass r/M instead of your cgs or SI r.
Equivalently, the angular momentum L, the spins Si and the total angular
momentum J are actually L/M^2, Si/M^2 and J/M^2.

2. **Don't go too close to the limits (i)**. This is a code to study double-spin
precession and, in general, it won't behave nicely if you are too close to
aligned, hence non-precessing, configurations. These configurations are given by
the limits Jmin and Jmax of the total angular momentum J, and/or by
sin(theta_i)=0. I strongly recommend to always set a tolerance, for instance,

        Jmin,Jmax=precession.J_lim(q,S1,S2,r) for J in
        numpy.linspace(Jmin+1e-4,Jmax-1e-4,100): 
            do things...

3. **Don't go too close to the limits (ii)**. For the same reason, some
quantities cannot be computed efficiently for binaries which are very close to a
spin-orbit resonance (which indeed does not precess at all!). For instance,  the
computation of the angle alpha is somewhat unstable close to xi_min and xi_max
as returned by xi_allowed. Richard O'Shaughnessy found that a tolerance of 2e-3
on xi works well.


4. **Checkpointing**. Checkpointing is implemented in some functions for
computational efficiency. Temporary data are stored in a local directory and
will be read in if available. To delete all previous data run

        precession.empty_temp()

    By default, data are stored in a local directory called `checkpoints`, which
    is created when needed. You can change it setting

        precession.storedir=[path]

5. **Parallelization**. Some parts of the code are parallelized using the
`parmap` module. Instructions on code parallelization are set by the global
variable CPUs - `CPUs=1`: no parallelization will be used; - `CPUs=integer`: to
specify the actual number of cores to be used; - `CPUs=0` (default): all CPUs in
the current machine will be used.

    You can set this variable using

        precession.CPUs = [integer]

6. **The equal-mass limit**. The equal-mass q=1 limit requires some extra care.
If q=1 the total-spin magnitude S cannot be used to parametrize the precession
cycle and the angle varphi needs to be tracked explicitly. The q=1 case is
implemented in the code: inputs and outputs of some of the functions are
actually specified in cos(varphi), even if for simplicity we still call them
**S**. In case of precession-averaged integrations to/from infinity, kappa_inf
becomes degenerate with xi and a required initial value of S is required.
Please, refer to the documentation below for details. The generic unequal-mass
part of the code works fine up to q<0.9999. To run higher values of q we
recommend setting q=1.

7. **Stalling**. When performing precession-averaged evolutions, some binaires
may occasionally stall and take longer to run. This is due to the first step
attempted by the ODE integrator. This is a minor issue and  only happens to
roughly one binary in a million or so. If you really want to fix this, you
should play with the h0 optional paramenter in scipy's odeint function.


###THANKS
The code is developed and maintained by [Davide Gerosa](www.davidegerosa.com). 
Please, report bugs to

    d.gerosa@damtp.cam.ac.uk

I'm happy to help you out! 

I'd like to thank E.
Berti, M. Kesden, U. Sperhake, R. O'Shaughnessy, D. Trifiro' and J. Vosmera for
the help receiving in interpreting the physical results and implementing some of
the algorithms.
'''

__author__ = "Davide Gerosa"
__email__ = "d.gerosa@damtp.cam.ac.uk"
__copyright__ = "Copyright (C) 2015 Davide Gerosa"
__license__ = "CC by-nc-sa 3.0"
__version__ = "0.0.0.19"


__doc__="**Author** "+__author__+"\n\n"+\
        "**email** "+__email__+"\n\n"+\
        "**Copyright** "+__copyright__+"\n\n"+\
        "**Licence** "+__license__+"\n\n"+\
        "**Version** "+__version__+"\n\n"+\
        __doc__

def why():
    print "\nIt's all about python and gravity. Go to"
    print "http://imgs.xkcd.com/comics/python.png\n"
    sys.exit()


################################
########### STARTUP ############
################################

import os, sys, imp
import numpy as np
import scipy as sp
from scipy import optimize
from scipy import integrate
import random
import math
import multiprocessing,parmap # if you don't have parmap, try "pip install parmap".
import __main__ 

##Unbuffereb stdout. Less efficient but interesting for debugging.
if False:
    class Unbuffered(object):
        def __init__(self, stream):
            self.stream = stream
        def write(self, data):
            self.stream.write(data)
            self.stream.flush()
        def __getattr__(self, attr):
            return getattr(self.stream, attr)
    sys.stdout = Unbuffered(sys.stdout) 

# Checkpoint setup. Checkpoints will be stored in the storedir directory.
# storedir=imp.find_module('precession')[1].split("precession.py")[0]+"precession_checkpoints" ## Global directory
storedir="precession_checkpoints" ## Local directory
'''
Directory path to store checkpoints. Deafult is `./precession_checkpoints`.
'''

def make_temp():

    '''
    Make an empty directory to store checkpoints. Calling this function is typically not necessary, because the checkpoint directory is created when needed.

    **Call:**

        precession.empty_temp()
    '''
    
    global storedir
    print "[make_temp] Creating temp directory: "+storedir
    os.system("mkdir -p "+storedir) 


def empty_temp():

    '''
    Remove all checkpoints.

    **Call:**

        precession.empty_temp()
    '''
    
    global storedir
    print "[empty_temp] Removing temp files from directory: "+storedir
    os.system("rm -rf "+storedir) 
#empty_temp(storedir)

M=1.
'''
The total mass is just a free scale, and we set it to 1. Please, don't change this, because I never checked that the various M factors are all right. 
'''

flags_q1=list(np.zeros((20), dtype=bool)) 
'''
Global flags to reduce warnings in the equal-mass limit q=1.
'''

#################################
############# LIMITS ############
#################################

def get_fixed(q,chi1,chi2):
    
    '''
    Compute individual masses and spins, from mass ratio (q<1) and
    dimensionless spins (0<chi<1).

    **Call:**

        M,m1,m2,S1,S2=precession.get_fixed(q,chi1,chi2)
    
    **Parameters:**
    
    - `q`: binary mass ratio. Must be q<=1.
    - `chi1`: dimensionless spin magnitude of the primary BH. Must be 0<chi1<1.
    - `chi2`: dimensionless spin magnitude of the secondary BH. Must be 0<chi2<1.

    **Returns:**
    
    - `M`: total mass of the binary (set to 1).
    - `m1`: mass of the primary BH.
    - `m2`: mass of the secondary BH.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    '''
    
    global M
    m1=M/(1.+q) # Primary mass
    m2=q*M/(1.+q) # Secondary mass
    S1=chi1*m1**2 # Primary spin magnitude
    S2=chi2*m2**2 # Secondary spin magnitude
    return M,m1,m2,S1,S2


def J_lim(q,S1,S2,r, verbose=False):
    
    '''
    Compute the limits on the magnitude of the total angular momentum J, defined as J=|L+S1+S2|.    

    **Call:**

        Jmin,Jmax=precession.J_lim(q,S1,S2,r, verbose=False)
    
    **Parameters:**
 
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `r`: binary separation.
    - `verbose`: if `True` print additional information.

    **Returns:**
    
    - `Jmin`: minimum value of J from geometrical constraints.
    - `Jmax`: maximum value of J from geometrical constraints.
    '''

    L=(q/(1.+q)**2)*(r*M**3)**.5    
    Jmin=max(1e-20,L-S1-S2,S1-L-S2,S2-S1-L)
    Jmax=L+S1+S2
    
    if verbose:
        print "[J_lim] L=",L, " S1=",S1," S2=",S2
        print "[J_lim] Jmin=",Jmin, " Jmax=",Jmax
        if Jmin==1e-20:
            print "[J_lim] Jmin=0, Jmax=L+S1+S2"
        elif Jmin==L-S1-S2:
            print "[J_lim] Jmin=L-S1-S2, Jmax=L+S1+S2"
        if Jmin==S1-L-S2:
            print "[J_lim] Jmin=S1-L-S2, Jmax=L+S1+S2"
        if Jmin==S2-L-S1:
            print "[J_lim] Jmin=S2-L-S1, Jmax=L+S1+S2"
            
    return Jmin,Jmax    
    
def St_limits(J,q,S1,S2,r,verbose=False):
     
    '''
    Compute the *total* limits on the magnitude of the total spin S. S has to satisfy both S=S1+S2 and S=J-L.

    **Call:**

        St_min,St_max=precession.St_limits(J,q,S1,S2,r,verbose=False)
    
    **Parameters:**
    
    - `J`: magnitude of the total angular momentum.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `r`: binary separation.
    - `verbose`: if `True` print additional information.

    **Returns:**
    
    - `St_min`: minimum value of S from geometrical constraints. This is S_min in our papers.
    - `St_max`: maximum value of S from geometrical constraints. This is S_max in our papers.
    '''

    ttol=0.0
    L=(q/(1.+q)**2)*(r*M**3)**.5
    St_min=float(max(np.abs(J-L),np.abs(S1-S2)))
    St_max=min(J+L,S1+S2)
    if verbose:
        print "[S_lim] L=",L, " J",J, " S1=",S1," S2=",S2
        print "[S_lim] St_min=",St_min, " St_max=",St_max
        if St_min==np.abs(J-L) and St_max==J+L:
            print "[S_lim] St_min=|J-L|, St_max=J+L"
        elif St_min==np.abs(J-L) and St_max==S1+S2:
            print "[S_lim] St_min=|J-L|, St_max=S1+S2"
        elif St_min==np.abs(S1-S2) and St_max==J+L:
            print "[S_lim] St_min=|S1-S2|, St_max=J+L"
        elif St_min==np.abs(S1-S2) and St_max==S1+S2:
            print "[S_lim] St_min=|S1-S2|, St_max=S1+S2"

    return St_min+ttol,St_max-ttol


def Sso_limits(S1,S2):
    
    '''
    Compute the *spin-only* limits on the magnitude of the total spin S, considering the single constraint S=S1+S2.  This is needed e.g. to provide initial condition to
    precession-averaged integration from infinity in the q=1 limit.

    **Call:**

        Sso_min,Sso_max=precession.Sso_limits(S1,S2)

    **Parameters:**
    
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.

    **Returns:**
    
    - `Sso_min`: minimum value of S from the spin constraint only.
    - `Sso_max`: maximum value of S from the spin constraint only.
    '''
    
    return np.abs(S1-S2), S1+S2


def xi_lim(q,S1,S2):

    '''
    Compute the absolute limits on xi (i.e. regardless of J). Check `precession.xi_allowed` for the limits on xi for a given J. This functions is simply checks -1<cos(theta_i)<1.

    **Call:**

        xi_min,xi_max=precession.xi_lim(q,S1,S2)
    
    **Parameters:**
    
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    
    **Returns:**
    
    - `xi_min`: minimum value of xi from geometrical constraints.
    - `xi_max`: maximum value of xi from geometrical constraints.
    '''

    xi_max= ((1.+q)*S1+(1.+q**-1)*S2)*M**-2
    xi_min=-1.*xi_max
    return xi_min,xi_max    


def xi_at_Jlim(q,S1,S2,r,more=False):

    '''
    Find the value of xi (and S, optional) when J is either Jmax or Jmin..
    
    **Call:**

        xi_Jmin,xi_Jmax=precession.xi_at_Jlim(q,S1,S2,r,more=False)
    
    **Parameters:**
    
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `r`: binary separation.
    - `more`: if `True` returns additional quantities,

    **Returns:**

    - `xi_Jmin`: value of xi when J=Jmin.
    - `xi_Jmax`: value of xi when J=Jmax.
    - `S_Jmin`: (optional) value of S when J=Jmin.
    - `S_Jmax`: (optional) value of S when J=Jmax.
    '''

    # Find Jmin and Jmax
    L=(q/(1.+q)**2)*(r*M**3)**.5    
    Jmin=max(1e-20,L-S1-S2,S1-L-S2,S2-S1-L)
    Jmax=L+S1+S2
    
    # Everything is aligned at Jmax
    ct1=1.
    ct2=1.
    xi_Jmax= ((1.+q)*S1*ct1+(1.+q**-1)*S2*ct2)*M**-2
    S_Jmax= S1+S2
    
    # Split the Jmin cases
    if Jmin==1e-20: # Force vectors in a plane, closed triangle
        ct1= (-S1**2+S2**2-L**2)/(2.*L*S1)
        ct2= (-S2**2+S1**2-L**2)/(2.*L*S2)
        S_Jmin=0
    elif Jmin==L-S1-S2: # Both antialigned
        ct1=-1.
        ct2=-1.
        S_Jmin=S1+S2
    elif Jmin==S1-L-S2: # One antialigned
        ct1=-1.
        ct2=1.
        S_Jmin=np.abs(S1-S2)
    elif Jmin==S2-L-S1: # One antialigned
        ct1=1.
        ct2=-1.
        S_Jmin=np.abs(S1-S2)
    xi_Jmin= ((1.+q)*S1*ct1+(1.+q**-1)*S2*ct2)*M**-2
    
    if more:
        return xi_Jmin, xi_Jmax, S_Jmin, S_Jmax
    else:
        return xi_Jmin, xi_Jmax


def kappainf_lim(S1,S2):
    
    '''
    Absolute limits in kappa_inf (asymptotic value of kappa). At large separations, kappa is the projection of the total spin along L.

    **Call:**

        kappainf_min,kappainf_max=precession.kappainf_lim(S1,S2)
     
    **Parameters:**
    
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.

    **Returns:**

    - `kappainf_min`: minimum value of kappa at infinitely large separations.
    - `kappainf_max`: maximum value of kappa at infinitely large separations.
    '''
    
    return -(S1+S2), S1+S2
 
 
def xiinf_allowed(kappa_inf,q,S1,S2):
 
    '''
    Limits on xi for a given value of kappa_inf, obtained forcing -1<cos(theta_i)<1.
 
    **Call:**

        xi_low,xi_up=precession.xiinf_allowed(kappa_inf,q,S1,S2)
    
    **Parameters:**
    
    - `kappa_inf`: asymptotic value of kappa at large separations.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.

    **Returns:**

    - `xi_low`: minimum allowed value of xi, given the input parameters.
    - `xi_up`: maximum allowed value of xi, given the input parameters.
    '''
    
    xi_low = max( kappa_inf*(1+q) - (q**-1-q)*S2 , kappa_inf*(1+q**-1) - (q**-1-q)*S1 )
    xi_up = min( kappa_inf*(1+q) + (q**-1-q)*S2 , kappa_inf*(1+q**-1) + (q**-1-q)*S1 )
    return xi_low,xi_up
 
 
def kappainf_allowed(xi,q,S1,S2):

    '''
    Limits on kappa_inf for a given value of xi, obtained forcing -1<cos(theta_i)<1.
 
    **Call:**

        kappainf_low,kappainf_up=precession.kappainf_allowed(xi,q,S1,S2)
    
    **Parameters:**
    
    - `xi`: projection of the effective spin along the orbital angular momentum.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.

    **Returns:**

    - `kappainf_low`: minimum allowed value of kappa_inf, given the input parameters.
    - `kappainf_up`: maximum allowed value of kappa_inf, given the input parameters.
    '''
    
    kappainf_low = max( (xi - (q**-1-q)*S2)/(1+q) , (xi - (q**-1-q)*S1)/(1+q**-1) )
    kappainf_up = min( (xi + (q**-1-q)*S2)/(1+q) , (xi + (q**-1-q)*S1)/(1+q**-1) )
    return kappainf_low,kappainf_up




#################################
##### EFFECTIVE POTENTIALS ######
#################################


def xi_contour(varphi,S,J,q,S1,S2,r):

    '''
    Compute the projection of the effective spin xi as a function of the spin-rotation degree of freedom
    varphi and the total spin magnitude S.
 
    **Call:**

        xi=precession.xi_contour(varphi,S,J,q,S1,S2,r)
    
    **Parameters:**
    
    - `varphi`: angle describing the rotation of S1 and S2 about S, in a frame aligned with J.
    - `S`: magnitude of the total spin.
    - `J`: magnitude of the total angular momentum.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `r`: binary separation.

    **Returns:**

    - `xi`: projection of the effective spin along the orbital angular momentum.
    '''

    L=(q/(1.+q)**2)*(r*M**3)**.5
    t1=(1.+q)/(4.*q*M**2*S**2*L)
    t2=J**2-L**2-S**2
    t3=S**2*(1.+q)-(S1**2-S2**2)*(1.-q)
    t4=(1.-q)*((L+S)**2-J**2)**.5
    t5=(J**2-(L-S)**2)**.5             
    t6=((S1+S2)**2-S**2)**.5
    t7=(S**2-(S1-S2)**2)**.5
    return t1*((t2*t3)-(t4*t5*t6*t7*np.cos(varphi)))  

    
def xi_plus(S,J,q,S1,S2,r):

    '''
    Upper effective potential, corresponding to cos(varphi)=-1.
 
    **Call:**

        xi=precession.xi_plus(S,J,q,S1,S2,r)

    **Parameters:**
    
    - `S`: magnitude of the total spin.
    - `J`: magnitude of the total angular momentum.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `r`: binary separation.

    **Returns:**

    - `xi`: projection of the effective spin along the orbital angular momentum.
    '''
    
    # Do it explicitely. Somehow faster than calling xi_contour(np.pi,...)
    L=(q/(1.+q)**2)*(r*M**3)**.5
    t1=(1.+q)/(4.*q*M**2*S**2*L)
    t2=J**2-L**2-S**2
    t3=S**2*(1.+q)-(S1**2-S2**2)*(1.-q)

    if S in St_limits(J,q,S1,S2,r): #if you're on the limits, the second bit must be zero
        t4=t5=t6=t7=0.
    else:
        t4=(1.-q)*((L+S)**2-J**2)**.5
        t5=(J**2-(L-S)**2)**.5             
        t6=((S1+S2)**2-S**2)**.5
        t7=(S**2-(S1-S2)**2)**.5    

    return t1*((t2*t3)-(t4*t5*t6*t7*(-1.)))  
 
 
def xi_minus(S,J,q,S1,S2,r):
    
    '''
    Lower effective potential, corresponding to cos(varphi)=+1.

    **Call:**

        xi=precession.xi_minus(S,J,q,S1,S2,r)
    
    **Parameters:**
    
    - `S`: magnitude of the total spin.
    - `J`: magnitude of the total angular momentum.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `r`: binary separation.

    **Returns:**

    - `xi`: projection of the effective spin along the orbital angular momentum.
    '''
    
    # Do it explicitely. Somehow faster than calling xi_contour(np.pi,...)    
    L=(q/(1.+q)**2)*(r*M**3)**.5
    t1=(1.+q)/(4.*q*M**2*S**2*L)
    t2=J**2-L**2-S**2
    t3=S**2*(1.+q)-(S1**2-S2**2)*(1.-q)

    if S in St_limits(J,q,S1,S2,r): #if you're on the limits, the second bit must be zero
        t4=t5=t6=t7=0.
    else:
        t4=(1.-q)*((L+S)**2-J**2)**.5
        t5=(J**2-(L-S)**2)**.5             
        t6=((S1+S2)**2-S**2)**.5
        t7=(S**2-(S1-S2)**2)**.5    

    return t1*((t2*t3)-(t4*t5*t6*t7*(1.)))  


def dxidS_plus(S,J,q,S1,S2,r):

    '''
    Derivative of the effective potential xi_plus with respect to S.    

    **Call:**

        dxidS=precession.dxidS_plus(S,J,q,S1,S2,r)
    
    **Parameters:**
    
    - `S`: magnitude of the total spin.
    - `J`: magnitude of the total angular momentum.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `r`: binary separation.

    **Returns:**

    - `dxidS`: derivative of effective potential with respect to S.
    '''
    
    L=(q/(1.+q)**2)*(r*M**3)**.5
    A1=np.sqrt(J**2-(L-S)**2)
    A2=np.sqrt((L+S)**2-J**2)
    A3=np.sqrt(S**2-(S1-S2)**2)
    A4=np.sqrt((S1+S2)**2-S**2)
    Fp = (J**2-L**2-S**2)*(S**2*(1+q)**2-(S1**2-S2**2)*(1-q**2))+(1-q**2)*A1*A2*A3*A4
    G=4*q*M**2*S**2*L
    dFpdS = -2*S*(S**2*(1+q)**2-(S1**2-S2**2)*(1-q**2))+2*S*(1+q)**2*(J**2-L**2-S**2)+(1-q**2)*(((L-S)*A2*A3*A4)/A1+((L+S)*A3*A4*A1)/A2+(S*A4*A1*A2)/A3-(S*A1*A2*A3)/A4)
    dGdS=8*q*M**2*S*L
    dxipdS=(dFpdS*G-dGdS*Fp)/(G**2)
    return dxipdS


def dxidS_minus(S,J,q,S1,S2,r):
    
    '''
    Derivative of the effective potential xi_minus with respect to S.    

    **Call:**

        dxidS=precession.dxidS_minus(S,J,q,S1,S2,r)
    
    **Parameters:**
    
    - `S`: magnitude of the total spin.
    - `J`: magnitude of the total angular momentum.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `r`: binary separation.

    **Returns:**

    - `dxidS`: derivative of effective potential with respect to S.
    '''

    L=(q/(1.+q)**2)*(r*M**3)**.5
    A1=np.sqrt(J**2-(L-S)**2)
    A2=np.sqrt((L+S)**2-J**2)
    A3=np.sqrt(S**2-(S1-S2)**2)
    A4=np.sqrt((S1+S2)**2-S**2)
    Fm = (J**2-L**2-S**2)*(S**2*(1+q)**2-(S1**2-S2**2)*(1-q**2))-(1-q**2)*A1*A2*A3*A4
    G=4*q*M**2*S**2*L
    dFmdS = -2*S*(S**2*(1+q)**2-(S1**2-S2**2)*(1-q**2))+2*S*(1+q)**2*(J**2-L**2-S**2)-(1-q**2)*(((L-S)*A2*A3*A4)/A1+((L+S)*A3*A4*A1)/A2+(S*A4*A1*A2)/A3-(S*A1*A2*A3)/A4)
    dGdS=8*q*M**2*S*L
    dximdS=(dFmdS*G-dGdS*Fm)/(G**2)
    return dximdS


def get_varphi(xi,S,J,q,S1,S2,r,sign=1):

    '''
    Compute varphi from a given xi. This can be seen as the inverse of xi_contour. If phase==1 (default) return varphi in [0,pi], if sign==-1 return varphi in [-pi,0].    

    WARKNING: Don't run for q=1, as varphi is independent of S in this limit.

    **Call:**

        varphi=precession.get_varphi(xi,S,J,q,S1,S2,r,sign=1)
    
    **Parameters:**
    
    - `xi`: projection of the effective spin along the orbital angular momentum.
    - `S`: magnitude of the total spin.
    - `J`: magnitude of the total angular momentum.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `r`: binary separation.
    - `sign`: if 1 return angle in [0,pi], if -1 return angle in [-pi,0].

    **Returns:**

    - `varphi`: angle describing the rotation of S1 and S2 about S, in a frame aligned with J.
    '''

    if q==1:
        print "[get_varphi] Error: I'm sorry, can't run for q=1. S is degenerate with varphi."
        sys.exit()

    L=(q/(1.+q)**2)*(r*M**3)**.5
    t1=(1.+q)/(4.*q*M**2*S**2*L)
    t2=J**2-L**2-S**2
    t3=S**2*(1.+q)-(S1**2-S2**2)*(1.-q)
    t4=(1.-q)*((L+S)**2-J**2)**.5
    t5=(J**2-(L-S)**2)**.5             
    t6=((S1+S2)**2-S**2)**.5
    t7=(S**2-(S1-S2)**2)**.5
    cosvarphi= ((t2*t3)-(xi/t1))/(t4*t5*t6*t7)
    
    return np.arccos(cosvarphi)*sign


def Sb_limits(xi,J,q,S1,S2,r):
    
    '''
    Compute the *bounded* limits on S, using xi as a constant of motion. The routine first guesses where the extrema are expected to be, then brakets the solution, and finally runs root finder. In some cases the braketing may fail: this typically happens if the two roots are very close (DeltaS<1e-8) and cannot be distinguished numerically. In this case, assume Sb_min=Sb_max.

    WARNING: This function is critical. It is well tested, but is tricky numerical issues may still be present.

    **Call:**

        Sb_min,Sb_max=precession.Sb_limits(xi,J,q,S1,S2,r)

    **Parameters:**
    
    - `xi`: projection of the effective spin along the orbital angular momentum.
    - `J`: magnitude of the total angular momentum.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `r`: binary separation.

    **Returns:**

    - `Sb_min`: minimum value of S from geometrical constraints. This is S- in our papers.
    - `Sb_max`: maximum value of S from geometrical constraints. This is S+ in our papers.   
    '''
 
    St_min,St_max=St_limits(J,q,S1,S2,r)
    if St_max<St_min:
        print "[Sb_limits] Problem in the absolute limits at r="+str(r)+". Assume Sb_min=Sb_max=mean(St_min,St_max)"        
        return np.mean([St_min,St_max]), np.mean([St_min,St_max])

    if q==1: # if q=1 the effective potential loop shrinks to a lime (Sb_min=Sb_max) and the equations xi_/pm(S)=xi can be solved analytically.
        L=(q/(1.+q)**2)*(r*M**3)**.5
        Sb_both=np.sqrt(J**2-L**2-xi*L*M**2)
        return Sb_both,Sb_both

    # Remember: xi_minus=xi_plus at St_min and St_max
    xi_low=xi_minus(St_min,J,q,S1,S2,r) 
    xi_up=xi_minus(St_max,J,q,S1,S2,r)
 
    #Debug option: print the parameter-space region of the initial guess
    whereareyou=False
 
    # Both roots on xi_plus. Split the interval first
    if xi > xi_low and xi > xi_up:    
        if whereareyou:
            print "[Sb_limits] Both roots on xi_plus"
        
        resmax= sp.optimize.fminbound(lambda S: -1.*xi_plus(S,J,q,S1,S2,r), St_min, St_max,full_output=1)
        S_up=resmax[0]
        xi_max=-1.*resmax[1]
        
        if xi_max<xi: #Braket failed!
            print "[Sb_limits] Braket failed on xi_plus at r="+str(r)+". Assume Sb_min=Sb_max"
            #print  xi_plus(S_up,J,q,S1,S2,r), xi
            Sb_min=S_up
            Sb_max=S_up  
        else: #Braket succeeded!
            Sb_min= sp.optimize.brentq(lambda S: xi_plus(S,J,q,S1,S2,r)-xi, St_min, S_up)
            Sb_max= sp.optimize.brentq(lambda S: xi_plus(S,J,q,S1,S2,r)-xi, S_up, St_max)

    # Both roots on xi_minus. Split the interval first
    elif xi < xi_low and xi < xi_up:    
        if whereareyou:
            print "[Sb_limits] Both roots on xi_minus"
            
        resmin= sp.optimize.fminbound(lambda S: xi_minus(S,J,q,S1,S2,r), St_min, St_max,full_output=1)
        S_low=resmin[0]
        xi_min=resmin[1]
                 
        if xi_min>xi: #Braket failed! 
            print "[Sb_limits] Braket failed on xi_minus at r="+str(r)+". Assume Sb_min=Sb_max"
            Sb_min=S_low
            Sb_max=S_low  
        else: #Braket succeeded!
            Sb_min= sp.optimize.brentq(lambda S: xi_minus(S,J,q,S1,S2,r)-xi, St_min, S_low)
            Sb_max= sp.optimize.brentq(lambda S: xi_minus(S,J,q,S1,S2,r)-xi, S_low, St_max)

    # One root on xi_plus and the other one on xi_plus. No additional maximization is neeeded
    elif xi >= xi_low and xi <= xi_up:    
        if whereareyou:
            print "[Sb_limits] Sb_min on xi_plus, Sb_max on xi_minus"

        Sb_min= sp.optimize.brentq(lambda S: xi_plus(S,J,q,S1,S2,r)-xi, St_min, St_max)
        Sb_max= sp.optimize.brentq(lambda S: xi_minus(S,J,q,S1,S2,r)-xi, St_min, St_max)
    
    elif xi <= xi_low and xi >= xi_up:    
        if whereareyou:
            print "[Sb_limits] Sb_min on xi_minus, Sb_max on xi_plus"

        Sb_min= sp.optimize.brentq(lambda S: xi_minus(S,J,q,S1,S2,r)-xi, St_min, St_max)
        Sb_max= sp.optimize.brentq(lambda S: xi_plus(S,J,q,S1,S2,r)-xi, St_min, St_max)
                    
    else:
        print "[Sb_limits] Erorr in case selection"
        print "xi=", xi
        print "xi(Stmin)=", xi_low
        print "xi(Stmax)=", xi_up
        print "Stmin=", St_min
        print "Stmax", St_max
        print "J=", J
        print "L=", (q/(1.+q)**2)*(r*M**3)**.5
        print "r=", r
        sys.exit()

    btol=1e-8 # Never go to close to the actual limits, because of numerical stabilty
    Sb_min+=btol
    Sb_max-=btol

    if whereareyou:
        print "[Sb_limits] Results:", Sb_min,Sb_max
    
    if Sb_min>Sb_max: # This may happen (numerically) if they're too close to each other. Assume they're the same.
        return np.mean([Sb_min,Sb_max]), np.mean([Sb_min,Sb_max])
    else: 
        return Sb_min, Sb_max

  
def parametric_angles(S,J,xi,q,S1,S2,r):
    
    '''
    Compute the angles theta1,theta2,deltaphi and theta12, given S, J and xi. 
    Roundoff errors are fixed forcing cosines to be in [-1,1]. 
    The thetas are polar angles in [0,pi]. Deltaphi is an azimuthal angle, in principle lies in [-pi,pi]. Here we assumed DeltaPhi to be in [0,pi] as returned by arcccos: one may
    need to add a sign, depending on the actual application of this function
    (see e.g. `precession.orbit_angles` below). This function can be seen as the inverse of `precession.from_the_angles`. In the equal-mass limit q=1, S doesn't
    parametrize the precessional motion; we track the binary precession using
    varphi explicitly.

    **Call:**

        theta1,theta2,deltaphi,theta12=precession.parametric_angles(S,J,xi,q,S1,S2,r)

    **Parameters:**
    
    - `S`: magnitude of the total spin.   
    - `J`: magnitude of the total angular momentum.
    - `xi`: projection of the effective spin along the orbital angular momentum.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `r`: binary separation.

    **Returns:**

    - `theta1`: angle between the spin of the primary and the orbital angular momentum.
    - `theta2`: angle between the spin of the secondary and the orbital angular momentum.
    - `deltaphi`: angle between the projection of the two spins on the orbital plane.
    - `theta12`: angle between the two spins.
    '''
    
    L=(q/(1.+q)**2)*(r*M**3)**.5

    global flags_q1    
    if q==1:
        if flags_q1[0]==False:
            print "[parametric_angles] Warning q=1: input here is cos(varphi), not S."
            flags_q1[0]=True # Suppress future warnings
        cosvarphi=S # The input variable is actually cos(varphi)
        S=(J**2-L**2-xi*L*M**2)**.5
        t4=J**2-(L-S)**2
        t5=(L+S)**2-J**2
        t6=(S1+S2)**2-S**2
        t7=S**2-(S1-S2)**2        
        B=max(0,t4*t5*t6*t7)
        costheta1= (1/(4*S1*S**2*L))*((J**2-L**2-S**2)*(S**2+S1**2-S2**2)+np.sqrt(B)*cosvarphi)
        costheta2= (1/(4*S2*S**2*L))*((J**2-L**2-S**2)*(S**2+S2**2-S1**2)-np.sqrt(B)*cosvarphi)
    
    else:
        costheta1= ( ((J**2-L**2-S**2)/L) - (2.*q*M**2*xi)/(1.+q) )/(2.*(1.-q)*S1)
        costheta2= ( ((J**2-L**2-S**2)*(-q/L)) + (2.*q*M**2*xi)/(1.+q) )/(2.*(1.-q)*S2)

    # Force all cosines in [-1,1].
    costheta1=max(-1,min(costheta1,1.))
    theta1=np.arccos(costheta1)
    costheta2=max(-1,min(costheta2,1.))
    theta2=np.arccos(costheta2)
    costheta12=(S**2-S1**2-S2**2)/(2.*S1*S2)
    costheta12=max(-1,min(costheta12,1.))
    theta12=np.arccos(costheta12)
    cosdeltaphi= (costheta12 - costheta1*costheta2)/(np.sin(theta1)*np.sin(theta2))    
    cosdeltaphi=max(-1,min(cosdeltaphi,1.))
    deltaphi=np.arccos(cosdeltaphi)
    
    return theta1,theta2,deltaphi,theta12


def from_the_angles(theta1,theta2,deltaphi,q,S1,S2,r):

    '''
    Convert a set of angles theta1,theta2,deltaphi into values of J,xi,S.
    This function can be seen as the inverse of `precession.parametric_angles`. In the
    equal-mass limit q=1, S doesn't parametrize the precessional motion; we
    track the binary precession using varphi explicitly.

    **Call:**

        xi,J,S=precession.from_the_angles(theta1,theta2,deltaphi,q,S1,S2,r)

    **Parameters:**

    - `theta1`: angle between the spin of the primary and the orbital angular momentum.
    - `theta2`: angle between the spin of the secondary and the orbital angular momentum.
    - `deltaphi`: angle between the projection of the two spins on the orbital plane.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `r`: binary separation.

    **Returns:**
    
    - `xi`: projection of the effective spin along the orbital angular momentum.
    - `J`: magnitude of the total angular momentum.
    - `S`: magnitude of the total spin.   
    '''

    L=(q/(1.+q)**2)*(r*M**3)**.5
    
    global flags_q1
    if q==1:
        if flags_q1[1]==False:
            print "[from_the_angles] Warning q=1: output here is cos(varphi), not S."
            flags_q1[1]=True # Suppress future warnings
        xi = (2/M**2)*(S1 *np.cos(theta1)+S2*np.cos(theta2))
        Ssq = S1**2 + S2**2 +2*S1*S2*(np.cos(theta1)*np.cos(theta2)+np.sin(theta1)*np.sin(theta2)*np.cos(deltaphi))
        J=np.sqrt(Ssq+L**2+xi*L*M**2)
        t6=((S1+S2)**2-Ssq)
        t7=(Ssq-(S1-S2)**2)        
        B=(4*Ssq-xi**2*M**4)*t6*t7
        cosvarphi= (4*S1*Ssq*np.cos(theta1)-xi*M**2*(Ssq+S1**2-S2**2))/(np.sqrt(B))
        return xi,J,cosvarphi # The output variable is actually cos(varphi)
    
    else:
        xi= ((1.+q)*S1*np.cos(theta1)+(1.+q**-1)*S2*np.cos(theta2))*M**-2
        S= (S1**2+S2**2+2.*S1*S2*(np.sin(theta1)*np.sin(theta2)*np.cos(deltaphi)+np.cos(theta1)*np.cos(theta2)))**.5
        J= (L**2+S**2+2.*L*(S1*np.cos(theta1)+S2*np.cos(theta2)))**.5
        return xi,J,S


def xi_allowed(J,q,S1,S2,r, more=False,verbose=False):

    '''
    Find the allowed range of xi for fixed J, corresponding to the extrema of
    the effective potential. Two implementations are presented, and are
    controlled by the inner flag use_derivative. If False (default, suggested), scipy's
    fminbound minimization algorithm is applied to the effective potentials
    `precession.xi_minus` and `precession.xi_plus`. If True, we explicitly look for the zeroes of the
    derivative of the effective potentials with respect to S. J. Vosmera
    found that the bisect root finder behaves better than brentq for low mass
    ratio. We believe both implementation are correct: the former has been
    tested more extensively, the latter has been found to be more reliable in
    the q->1 limit. 
    
    WARNING: This function is critical. It's tested, but is
    tricky numerical issues may still be present.

    **Call:**

        xi_low,xi_up=precession.xi_allowed(J,q,S1,S2,r,more=False,verbose=False)

        xi_low,xi_up,S_xilow,S_xiup=precession.xi_allowed(J,q,S1,S2,r,more=True,verbose=False)


    **Parameters:**

    - `J`: magnitude of the total angular momentum.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `r`: binary separation.
    - `more`: if `True` returns additional quantities,
    - `verbose`: if `True` print additional information.

    **Returns:**

    - `xi_low`: minimum allowed value of xi, given the input parameters.
    - `xi_up`: maximum allowed value of xi, given the input parameters.
    - `S_xilow`: (optional) value of S when xi=xi_low.
    - `S_xiup`: (optional) value of S when xi=xi_up.
    '''

    # Take care of possible pathologies at the edges of the parameter space
    Jmin,Jmax= J_lim(q,S1,S2,r)
    if J==Jmin or J==Jmax:
        if J==Jmin:
            xiboth, dummy, Sboth, dummy = xi_at_Jlim(q,S1,S2,r,more=True)
        elif J==Jmax:
            dummy, xiboth, dummy, Sboth = xi_at_Jlim(q,S1,S2,r,more=True)
        if more:
            return xiboth, xiboth, Sboth, Sboth
        else:
            return xiboth, xiboth
    
    St_min,St_max=St_limits(J,q,S1,S2,r)
    
    # The extrema are at S=St_min, St_max
    if q==1:
        L=(q/(1.+q)**2)*(r*M**3)**.5
        xi_low=(J**2-L**2-St_max**2)/(L*M**2)
        xi_up=(J**2-L**2-St_min**2)/(L*M**2)
        S_xilow=St_max
        S_xiup=St_min

    # Extremize the two effective potentials.  
    else:
    
        use_derivative=False
        
        #Run a minimization algorithms on the effective potentials. 
        if use_derivative==False:
        
            # Minimum of xi_minus
            resmin= sp.optimize.fminbound(lambda S: xi_minus(S,J,q,S1,S2,r), St_min, St_max,xtol=1e-12,full_output=1)
            S_xilow=resmin[0] 
            xi_low=resmin[1]

            # Maximum of xi_plus. Scipy provides minimization algorithms: minimize -xi_plus and change sign at the end.
            resmax= sp.optimize.fminbound(lambda S: -1.*xi_plus(S,J,q,S1,S2,r), St_min, St_max,xtol=1e-12,full_output=1)
            S_xiup=resmax[0] 
            xi_up=-1.*resmax[1]

        # Run a root finders on the derivative of the effective potentials. 
        elif use_derivative==True:
        
            if q<0.1: # bisect behaves better for extreme mass ratios...
                S_xilow=sp.optimize.bisect(lambda S: dxidS_plus(S,J,q,S1,S2,r), St_min, St_max,xtol=1e-12)     
                S_xiup=sp.optimize.bisect(lambda S: dxidS_minus(S,J,q,S1,S2,r), St_min, St_max,xtol=1e-12)
            else: # ... but brentq is faster
                S_xilow=sp.optimize.brentq(lambda S: dxidS_plus(S,J,q,S1,S2,r), St_min, St_max,xtol=1e-12)    
                S_xiup=sp.optimize.brentq(lambda S: dxidS_minus(S,J,q,S1,S2,r), St_min, St_max,xtol=1e-12)
            xi_low=xi_minus(S_xilow,J,q,S1,S2,r)
            xi_up =xi_plus(S_xiup,J,q,S1,S2,r)

    if verbose:
        print "[xi_allowed] xi_low", xi_low, " xi_up=", xi_up
    if more: # Return the S values as well
        return xi_low, xi_up, S_xilow, S_xiup
    else:
        return xi_low, xi_up


def resonant_finder(xi,q,S1,S2,r, more=False):

    '''
    Find the spin-orbit resonances, for given xi, as extrema of the allowed region in the parameter space. Two resonances are present for DeltaPhi=0 and DeltaPhi=pi. They maximize (0) and minimize (pi) J for fixed xi. This is an alternative (and more powerful) approach to solving the Schnittman equation, given in Eq.(35) of [PRD 70,124020(2004)](http://journals.aps.org/prd/abstract/10.1103/PhysRevD.70.124020).
    
    **Call:**

        theta1_dp0,theta2_dp0,theta1_dp180,theta2_dp180=precession.resonant_finder(xi,q,S1,S2,r,more=False)

        J_dp0,S_dp0,theta1_dp0,theta2_dp0,J_dp180,S_dp180,theta1_dp180,theta2_dp180=precession.resonant_finder(xi,q,S1,S2,r,more=True)

    **Parameters:**

    - `xi`: projection of the effective spin along the orbital angular momentum.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `r`: binary separation.
    - `more`: if `True` returns additional quantities,

    **Returns:**

    - J_dp0: (optional) value of J for the DeltaPhi=0 resonance.
    - S_dp0: (optional) value of S for the DeltaPhi=0 resonance.
    - theta1_dp0: value of theta1 for the DeltaPhi=0 resonance.
    - theta2_dp0: value of theta2 for the DeltaPhi=pi resonance.
    - J_dp180: (optional) value of J for the DeltaPhi=pi resonance.
    - S_dp180: (optional) value of S for the DeltaPhi=pi resonance.
    - theta1_dp180: value of theta1 for the DeltaPhi=pi resonance.
    - theta2_dp180: value of theta2 for the DeltaPhi=pi resonance. 
    '''
    
    Jmin,Jmax=J_lim(q,S1,S2,r)    
    L=(q/(1.+q)**2)*(r*M**3)**.5    
    
    #DeltaPhi=0 resonance.
    J_dp0=sp.optimize.brentq(lambda J: xi_allowed(J,q,S1,S2,r)[0] -xi , abs(L-S1-S2), Jmax,xtol=1e-12)

    if q==1: 
        # Find S. St_max
        S_dp0=St_limits(J_dp0,q,S1,S2,r)[1]
        # Find angles
        theta1_dp0,theta2_dp0,deltaphi_dp0,dummy = parametric_angles(0,J_dp0,xi,q,S1,S2,r)   
                
    else:
        # Find S. Minimum of effective potential       
        dummy,dummy,S_dp0,dummy= xi_allowed(J_dp0,q,S1,S2,r,more=True)
        # Find angles
        theta1_dp0,theta2_dp0,deltaphi_dp0,dummy = parametric_angles(S_dp0,J_dp0,xi,q,S1,S2,r)

    #DeltaPhi=180 resonance.
    xi_Jmin,xi_Jmax= xi_at_Jlim(q,S1,S2,r)
            
    if xi>xi_Jmin:
        # Find J. Solution always on xi_max, between Jmin and Jmax
        J_dp180=sp.optimize.brentq(lambda J: xi_allowed(J,q,S1,S2,r)[1] -xi , Jmin, Jmax,xtol=1e-12)
        if q==1:
            # Find S. St_min
            S_dp180=St_limits(J_dp180,q,S1,S2,r)[0]
            # Find angles
            theta1_dp180,theta2_dp180,deltaphi_dp0,dummy = parametric_angles(0,J_dp180,xi,q,S1,S2,r)   
        else:
            # Find S. Maximum of effective potential
            dummy,dummy,dummy,S_dp180= xi_allowed(J_dp180,q,S1,S2,r,more=True)
            # Find angles
            theta1_dp180,theta2_dp180,deltaphi_dp180,dummy = parametric_angles(S_dp180,J_dp180,xi,q,S1,S2,r)
    else:
        # Find J. Solution still on xi_min, between Jmin and L-S1-S2. You're not here if Jmin=L-S1-S2, because xi_Jmin is the lower allowed value for xi in that case.
        J_dp180=sp.optimize.brentq(lambda J: xi_allowed(J,q,S1,S2,r)[0] -xi ,Jmin, abs(L-S1-S2),xtol=1e-12)
        if q==1:
            # Find S. St_max
            S_dp180=St_limits(J_dp180,q,S1,S2,r)[1]
            # Find angles
            theta1_dp180,theta2_dp180,deltaphi_dp0,dummy = parametric_angles(0,J_dp180,xi,q,S1,S2,r)   
        else:
            # Find S. Minimum of effective potential
            dummy,dummy,S_dp180,dummy= xi_allowed(J_dp180,q,S1,S2,r,more=True)
            # Find angles
            theta1_dp180,theta2_dp180,deltaphi_dp180,dummy = parametric_angles(S_dp180,J_dp180,xi,q,S1,S2,r)
       
    if False: # Sanity check. 
        print "DeltaPhi=0?", deltaphi_dp0
        print "DeltaPhi=pi?", deltaphi_dp180
    
    if more: # return everything you got
        return J_dp0, S_dp0, theta1_dp0, theta2_dp0, J_dp180, S_dp180, theta1_dp180, theta2_dp180
    else: # return the angles only
        return theta1_dp0, theta2_dp0, theta1_dp180, theta2_dp180


def J_allowed(xi,q,S1,S2,r):

    '''
    Find allowed values of J for fixed xi, i.e the spin-orbit resonances. See `precession.resonant_finder`.

    **Call:**

        J_low,J_up=precession.J_allowed(xi,q,S1,S2,r)
    
    **Parameters:**

    - `xi`: projection of the effective spin along the orbital angular momentum.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `r`: binary separation.

    **Returns:**

    - `J_low`: minimum allowed value of J, given the input parameters.
    - `J_up`: maximum allowed value of J, given the input parameters.
    '''
    
    J_dp0, dummy, dummy, dummy, J_dp180, dummy, dummy, dummy = resonant_finder(xi,q,S1,S2,r, more=True)
    return min(J_dp0,J_dp180),max(J_dp0,J_dp180)
 
 
def thetas_inf(xi,kappa_inf,q,S1,S2):

    '''
    Find the asymptotic (constant) values of theta1 and theta2 given xi and kappa_inf.

    **Call:**

        theta1_inf,theta2_inf=precession.thetas_inf(xi,kappa_inf,q,S1,S2)

    **Parameters:**

    - `xi`: projection of the effective spin along the orbital angular momentum.
    - `kappa_inf`: asymptotic value of kappa at large separations.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.

    **Returns:**

    - `theta1_inf`: asymptotic value of theta1 at large separations.
    - `theta2_inf`: asymptotic value of theta2 at large separations.
    '''
    
    if q==1:
        print "[thetas_inf] Error: I'm sorry, can't run for q=1. The angles theta1 and theta2 are not constant at large separations."
        sys.exit()
    else:
        ct1=(-xi + kappa_inf*(1.+q**(-1)))/(S1*(q**(-1)-q))
        ct2=(xi - kappa_inf*(1.+q))/(S2*(q**(-1)-q))
        return np.arccos(ct1),np.arccos(ct2)


def from_the_angles_inf(theta1_inf,theta2_inf,q,S1,S2):
    
    '''
    Find xi and kappa_inf given the asymptotic (constant) values of theta1 and theta2.

    **Call:**

        xi,kappa_inf=precession.from_the_angles_inf(theta1_inf,theta2_inf,q,S1,S2)
    
    **Parameters:**

    - `theta1_inf`: asymptotic value of theta1 at large separations.
    - `theta2_inf`: asymptotic value of theta2 at large separations.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    
    **Returns:**

    - `xi`: projection of the effective spin along the orbital angular momentum.
    - `kappa_inf`: asymptotic value of kappa at large separations.
    '''
    
    if q==1:
        print "[from_the_angles_inf] Error: I'm sorry, can't run for q=1. The angles theta1 and theta2 are not constant at large separations."
        sys.exit()
    else:
        xi= ((1.+q)*S1*np.cos(theta1_inf)+(1.+q**-1)*S2*np.cos(theta2_inf))*M**-2
        kappa_inf= (S1*np.cos(theta1_inf)+S2*np.cos(theta2_inf))*M**-2
        return xi,kappa_inf


def updown(q,S1,S2):
    
    '''
    Instability range for up-down aligned binaries. Binaries with the primary (secondary) spin aligned (antialigned) with the angular momentum are unstable between the two separations returned.
    Hack the code to compute also the function *switch*, for a sanity check on the property of the second threshold (whether that's on `precession.xi_plus` or on `precession.xi_minus`).
    All up-down binaries are stable in the equal-mass case: if q=1 returns Nones.

    **Call:**

        r_udp,r_udm=precession.updown(q,S1,S2)

    **Parameters:**

    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    
    **Returns:**

    - `r_udp`: upper separation for the up-down instability.
    - `r_udm`: lower separation for the up-down instability.    
    '''

    if q==1:
        print "[updown] Warning: up-down is always stable for q=1. Retuning Nones."
        return None, None

    r_udp=((1.+q)**2 *((q*S1)**0.5 + S2**0.5)**2/((1.-q)*q))**2
    r_udm=((1.+q)**2 *((q*S1)**0.5 - S2**0.5)**2/((1.-q)*q))**2
    
    if False:
        switch=q**0.5+ q**(-0.5) - (S2/S1)**0.5 - (S2/S1)**(-0.5)
        return r_udp,r_udm,switch
    else:
        return r_udp,r_udm
    


    
#################################
######### MORPHOLOGIES ##########
#################################


def find_morphology(xi,J,q,S1,S2,r):

    '''
    Compute the precessional morphology in DeltaPhi. Returns:
    
    - -1 if librating about DeltaPhi=0;
    - 0 if circulating in the whole DeltaPhi range [-pi,pi];
    - +1 if librating about DeltaPhi=pi.

    **Call:**

        morphology=precession.find_morphology(xi,J,q,S1,S2,r)

    **Parameters:**

    - `xi`: projection of the effective spin along the orbital angular momentum.
    - `J`: magnitude of the total angular momentum.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `r`: binary separation.

    **Returns:**

    - morphology: precessional morphology in DeltaPhi: -1 if librating about DeltaPhi=0; 0 if circulating; +1 if librating about DeltaPhi=pi.
    '''
  
    if q==1: # If q=1, the limits must be specified in cos(varphi)
        Sb_min=-1
        Sb_max=1
    else:    
        Sb_min,Sb_max=Sb_limits(xi,J,q,S1,S2,r)      
    
    dummy,dummy,deltaphi_Sbmin,dummy = parametric_angles(Sb_min,J,xi,q,S1,S2,r)
    dummy,dummy,deltaphi_Sbmax,dummy = parametric_angles(Sb_max,J,xi,q,S1,S2,r)

    # Both the initial and the final point in a precession cycle are <pi/2. This is a libration about DeltaPhi=0
    if deltaphi_Sbmin<np.pi/2. and deltaphi_Sbmax<np.pi/2.:
        return -1.
    # Both the initial and the final point in a precession cycle are >pi/2. This is a libration about DeltaPhi=180
    elif deltaphi_Sbmin>np.pi/2. and deltaphi_Sbmax>np.pi/2.:
        return 1.
    # The precession orbit crosses both DeltaPhi=0 and DeltaPhi=180. This is  circulation
    else:
        return 0.


def region_selection(varphi,S,J,q,S1,S2,r):

    '''
    Get the morphology in the varphi plane. See `precession.find_morphology`.

    **Call:**

        morphology=precession.region_selection(varphi,S,J,q,S1,S2,r)

    **Parameters:**

    - `varphi`: angle describing the rotation of S1 and S2 about S, in a frame aligned with J.
    - `S`: magnitude of the total spin.
    - `J`: magnitude of the total angular momentum.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `r`: binary separation.

    **Returns:**

    - morphology: precessional morphology in DeltaPhi: -1 if librating about DeltaPhi=0; 0 if circulating; +1 if librating about DeltaPhi=pi.
    '''
    
    xi=xi_contour(varphi,S,J,q,S1,S2,r)
    return find_morphology(xi,J,q,S1,S2,r)
    
    
def phase_checker(q,S1,S2,r,verbose=False):
    
    '''
    Computes the number of different morphologies you MAY have for a given geometrical configuration (i.e. given the lengths of the vectors L, S1 and S2). These are just geometrical constraints: the actual number of allowed morphologies depends on J, as returned by `precession.phase_xi`, but it can't be out of what returned by this function. This function is basically a sanity check for `precession.phase_xi`.

    **Call:**

        phases_vals=precession.phase_checker(q,S1,S2,r,verbose=False)
    
    **Parameters:**

    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `r`: binary separation.
    - `verbose`: if True print additional information.

    **Returns:**

    - phases_vals: number of coexisting morphologies: 1 if only the DeltaPhi~pi phase is present; 2 if two DeltaPhi~pi phases and a circulating phase are present; 3 if a librating DeltaPhi~0, a circulating, and a DeltaPhi~pi phase al all present (array).
    '''

    L=(q/(1.+q)**2)*(r*M**3)**.5
    
    if L > S1 + S2:
        if verbose:
            print "L > S1 + S2 : 3"
        phases=[3]
    
    elif (S1 + S2 > L and L > max(S1, S2)):
        if verbose:
            print "S1 + S2 > L > max(S1, S2) : 3,1"
        phases=[3,1]

    elif (max(S1,S2) > L and  L>np.abs(S1-S2)):
        if verbose:
            print "max(S1,S2) > L > |S1-S2| : 3,2,1"
        phases=[3,2,1]
    
    elif np.abs(S1-S2) > L:
        if verbose:
            print "|S1 - S2| > L : 3,2"
        phases=[3,2]

    else:
        print "[phase_checker] Error. You should never be here!"        
        sys.exit()
        
    return phases


def phase_xi(J,q,S1,S2,r): 

    '''
    Return an integer number, phases, specifying the number of precessional morphologies that can coexist for a given value of J. Returns:

    - 1 if only the DeltaPhi~pi phase is present;
    - 2 if two DeltaPhi~pi phases and a circulating phase are present;
    - 3 if a librating DeltaPhi~0, a circulating, and a DeltaPhi~pi phase al all present.

    The latter is *standard* case studied in [our first PRL](http://journals.aps.org/prl/abstract/10.1103/PhysRevLett.114.081103). Additionally, return the values of xi that, for given J, separate the binaries with different morphologies. If there are no transitions (i.e. phase=1), the transition values of xi are returned as Nones. If transitions cannot be found for numerical reasons, assume they coincides with the extrema of xi (see `precession.xi_allowed`). The output of this function can be tested with `precession.phase_checker`.

    **Call:**

        phases=precession.phase_xi(J,q,S1,S2,r)
    
    **Parameters:**

    - `J`: magnitude of the total angular momentum.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `r`: binary separation.

    **Returns:**

    - phases: number of coexisting morphologies: 1 if only the DeltaPhi~pi phase is present; 2 if two DeltaPhi~pi phases and a circulating phase are present; 3 if a librating DeltaPhi~0, a circulating, and a DeltaPhi~pi phase al all present.
    '''

    xi_min,xi_max=xi_allowed(J,q,S1,S2,r)
    L=(q/(1.+q)**2)*(r*M**3)**.5
    
    # The following should be equivalent to apply find_morphology at xi_min and xi_max but it turns out to be more stable to numerical noise because it doesn't rely on Sb_limits
    St_min,St_max=St_limits(J,q,S1,S2,r)
    morph_ximin=find_morphology(xi_plus(St_max,J,q,S1,S2,r),J,q,S1,S2,r)
    morph_ximax=find_morphology(xi_plus(St_min,J,q,S1,S2,r),J,q,S1,S2,r)
    
    # The morphology at xi_max must be librating about pi. The morphology at xi_min can't be circulating.  Check if, because of degeneracies and numerical issues, a different morphology is be detected... 
    if morph_ximax!=1 or morph_ximin==0:
        print "[phase_xi] I think this should never ever happen. morph_ximax=",morph_ximax," morph_ximin=",morph_ximin
        if morph_ximin==-1:
            phase=3.
            xi_transit_up=xi_plus(St_min,J,q,S1,S2,r)+1e-9
            try:
                xi_transit_low=sp.optimize.brentq(lambda xi: (find_morphology(xi,J,q,S1,S2,r) +0.5), xi_min,xi_transit_up-1e-5, xtol=1e-5)
            except:
                xi_transit_low=xi_min

            return phase,xi_transit_low,xi_transit_up
        
    if morph_ximin==-1: 

        phase=3. # This is a three-phase case: Deltaphi~pi close to xi_max, Deltaphi~0 at xi_min and a circulating phase in between

        #Find transition Librating 180 - Circulating. Shift the find_morphology output, such that the zero is between the two phases
        try:
            xi_transit_up=sp.optimize.brentq(lambda xi: (find_morphology(xi,J,q,S1,S2,r) -0.5), xi_min,xi_max, xtol=1e-5)
        except:
            xi_transit_up=xi_max
            
        #Find transition Librating 0 - Circulating. Shift the find_morphology output, such that the zero is between the two phases
        try:
            xi_transit_low=sp.optimize.brentq(lambda xi: (find_morphology(xi,J,q,S1,S2,r) +0.5), xi_min,xi_max, xtol=1e-5)
        except:
            xi_transit_low=xi_min
            
        #xi_transit_low,xi_transit_up=sorted([xi_transit_0,xi_transit_180])

    elif morph_ximin==1:  # This is either a two-phase or a single-phase case.
        # Here we need to bracket the interval to find two roots. Two possible bracketing points are checked: the values of S for which
            # [first try] cos(theta1)=1 and cos(theta2)= -1 
            # [second try] cos(theta1)=-1 and cos(theta2)= 1 
        # Either one of the two choice typically gives the correct results for all the cases we tried; we cannot exclude the presence of pathological sets of parameters where both choices fail.

        for xi_bracket in [ -1.*(1.+q)*S1+(1.+1./q)*S2 , (1.+q)*S1-(1.+1./q)*S2 ]:
            if xi_bracket>xi_max or xi_bracket<xi_min:
                phase=1. # Either the bracketing is wrong or this is a single-phase case
                xi_transit_low=xi_min
                xi_transit_up=xi_max
            elif find_morphology(xi_bracket,J,q,S1,S2,r)==0:
                phase=2. # You found a good bracketing point. This must be a two-phase case             
            
                #Find the first transition Librating 180 - Circulating at lower xi. Shift the find_morphology output, such that the zero is between the two phase
                try:
                    xi_transit_low=sp.optimize.brentq(lambda xi: (find_morphology(xi,J,q,S1,S2,r) -0.5), xi_min,xi_bracket, xtol=1e-5)
                except:
                    xi_transit_low=xi_min
   
                #Find the other transition Librating 180 - Circulating at larger xi. Shift the find_morphology output, such that the zero is between the two phase
                try:
                    xi_transit_up=sp.optimize.brentq(lambda xi:  (find_morphology(xi,J,q,S1,S2,r) -0.5), xi_bracket,xi_max, xtol=1e-5)
                except:
                    xi_transit_up=xi_max
             
                break # One bracketing point is enough. Get out if you found the solution
            
            else:
                phase=1.  # Either the bracketing is wrong or this is a single-phase case
                xi_transit_low=xi_min
                xi_transit_up=xi_max
                          
    if phase not in phase_checker(q,S1,S2,r):
        print "[phase_xi] Warning: detected phases not allowed by geometry!"

    return phase, xi_transit_low,xi_transit_up


def Jframe_projection(xi,S,J,q,S1,S2,r):    

    '''
    Project the three momenta on the reference frame aligned with the total angular momentum J. The z axis points in the J direction, and the x axis lies in the plane spanned by J and L. The y axis complete an orthonormal triad. Note that this is not an inertial frame (not even on the precession time) because it precesses together with L.

    **Call:**

        Jvec,Lvec,S1vec,S2vec,Svec=precession.Jframe_projection(xi,S,J,q,S1,S2,r)
    
    **Parameters:**

    - `xi`: projection of the effective spin along the orbital angular momentum.
    - `S`: magnitude of the total spin.
    - `J`: magnitude of the total angular momentum.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `r`: binary separation.

    **Returns:**

    - `Jvec`: components of J in a reference frame (3 values for x,y,z).
    - `Lvec`: components of L in a reference frame (3 values for x,y,z).
    - `S1vec`: components of S1 in a reference frame (3 values for x,y,z).
    - `S2vec`: components of S2 in a reference frame (3 values for x,y,z).
    - `Svec`: components of S in a reference frame (3 values for x,y,z).
    '''
    
    global flags_q1
    L=(q/(1.+q)**2)*(r*M**3)**.5
    
    if q==1:
        if flags_q1[2]==False:
            print "[Jframe_projection] Warning q=1: input here is cos(varphi), not S."
            flags_q1[2]=True
        varphi=np.arccos(S)
        S=np.sqrt(J**2-L**2-xi*L*M**2)
    else:
        varphi=get_varphi(xi,S,J,q,S1,S2,r,sign=1)
        
    Jx = 0.
    Jy = 0.
    Jz = J # Definition!
    
    Lx = ( (((L+S)**2-J**2)**.5) * ((J**2-(L-S)**2)**.5) ) / (2.*J)
    Ly = 0. # Definition!
    Lz = (J**2+L**2-S**2) / (2.*J)
    
    S1x = (1./(4.*J*S**2))* \
          ( -1.*(S**2+S1**2-S2**2) * (((L+S)**2-J**2)**.5) * ((J**2-(L-S)**2)**.5) \
          + (J**2-L**2+S**2) * (((S1+S2)**2-S**2)**.5) * ((S**2-(S1-S2)**2)**.5) * np.cos(varphi) )
    S1y = (1./(2.*S))* \
          (((S1+S2)**2-S**2)**.5) * ((S**2-(S1-S2)**2)**.5)  * np.sin(varphi)
    S1z = (1./(4.*J*S**2))* \
          ( (S**2+S1**2-S2**2) * (J**2-L**2+S**2) \
          + (((L+S)**2-J**2)**.5) * ((J**2-(L-S)**2)**.5) *(((S1+S2)**2-S**2)**.5) * ((S**2-(S1-S2)**2)**.5) *np.cos(varphi) )

    S2x = (-1./(4.*J*S**2))* \
          ( (S**2+S2**2-S1**2) * (((L+S)**2-J**2)**.5) * ((J**2-(L-S)**2)**.5) \
          + (J**2-L**2+S**2) * (((S1+S2)**2-S**2)**.5) * ((S**2-(S1-S2)**2)**.5) * np.cos(varphi) )
    S2y = (-1./(2.*S))* \
          (((S1+S2)**2-S**2)**.5) * ((S**2-(S1-S2)**2)**.5)  * np.sin(varphi)
    S2z = (1./(4.*J*S**2))* \
          ( (S**2+S2**2-S1**2) * (J**2-L**2+S**2) \
          - (((L+S)**2-J**2)**.5) * ((J**2-(L-S)**2)**.5) *(((S1+S2)**2-S**2)**.5) * ((S**2-(S1-S2)**2)**.5) *np.cos(varphi) )    

    Jvec=np.array([Jx,Jy,Jz])
    Lvec=np.array([Lx,Ly,Lz])
    S1vec=np.array([S1x,S1y,S1z])
    S2vec=np.array([S2x,S2y,S2z])
    Svec= S1vec+S2vec

    if False: #Sanity check. These sets of numbers should really be the same
        print "[Jframe_projection] Check varphi", np.cos(varphi), np.sin(varphi)
        print "[Jframe_projection] Check J norm", np.linalg.norm(Jvec), J
        print "[Jframe_projection] Check norm", np.linalg.norm(Lvec), L
        print "[Jframe_projection] Check norm", np.linalg.norm(S1vec), S1
        print "[Jframe_projection] Check norm", np.linalg.norm(S2vec), S2
        print "[Jframe_projection] Check norm", np.linalg.norm(Svec), S

    return Jvec,Lvec,S1vec,S2vec,Svec




#################################
### TIME-DEPENDENT PRECESSION ###
#################################


def Omegaz(S,xi,J,q,S1,S2,r):

    '''
    Compute the (azimuthal) precessional frequency of the orbital angular momentum L about the total angular momentum J.

    **Call:**

        Omega=precession.Omegaz(S,xi,J,q,S1,S2,r)
    
    **Parameters:**
    
    - `S`: magnitude of the total spin.
    - `xi`: projection of the effective spin along the orbital angular momentum.
    - `J`: magnitude of the total angular momentum.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `r`: binary separation.

    **Returns:**

    - `Omega`: precessional frequency of L about J.
    '''

    L=(q/(1.+q)**2)*(r*M**3)**.5
    eta=q/(1.+q)**2
    t1=(J/2.)*((eta**2*M**3/L**2)**3)
    t2=(3./(2.*eta))*(1.-(eta*M**2*xi/L))
    t3=(3.*(1.+q)/(2.*q*(J**2-(L-S)**2)*((L+S)**2-J**2)))*(1.-(eta*M**2*xi/L))
    t4=4.*(1.-q)*L**2*(S1**2-S2**2)
    t5=(1.+q)*(J**2-L**2-S**2)*(J**2-L**2-S**2-4.*eta*M**2*L*xi)
    
    return t1*(1.+t2-t3*(t4-t5))


def dSdt(S,xi,J,q,S1,S2,r,sign=1.):

    '''
    Compute the derivative of S with respect to t (on the precessional time only, i.e. assuming J is constant). Uses the spin-precession equations, but not the radiation reaction equation. The additional sign lets you specifiy the sign of the angle deltaphi: for consistency with what presented in our papers, use sign=1 if you are in the second half of the precession cycle (deltaphi is in [0,pi]) and sign=-1 if you are in the first half of the precession cycle (deltaphi is in [-pi,0]). If q=1, this function computes d(cos(varphi))/dt.

    **Call:**

        dSdt=precession.dSdt(S,xi,J,q,S1,S2,r,sign=1.)
    
    **Parameters:**
    
    - `S`: magnitude of the total spin.
    - `xi`: projection of the effective spin along the orbital angular momentum.
    - `J`: magnitude of the total angular momentum.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `r`: binary separation.
    - `sign`: if 1 return angle in [0,pi], if -1 return angle in [-pi,0].

    **Returns:**

    - `dSdt`: precessional-cycle speed.
    '''

    global flags_q1   

    L=(q/(1.+q)**2)*(r*M**3)**.5
    eta=q/(1.+q)**2

    if q==1:
        if flags_q1[3]==False:
            print "[dSdt] Warning q=1: input here is cos(varphi), not S; now computing d(cos(varphi))/dt "
            flags_q1[3]=True
        
        cosvarphi = S # The input variable is actually cos(varphi)
        S = np.sqrt(J**2-L**2-xi*L*M**2)
        S_min,S_max=St_limits(J,q,S1,S2,r)
        
        if np.abs(S-S_min)<1e-8 or np.abs(S-S_max)<1e-8:
            print "[dSdt] Warning: you are at resonance, varphi is ill-defined here."
            return 0.
        
        # Compute d(cos(varphi))/dt
        t6=((S1+S2)**2-S**2)
        t7=(S**2-(S1-S2)**2)        
        B=(4*S**2-xi**2*M**4)*t6*t7
        #B=max(0.0,B)
        t1= (12*S**2*S1*S2)/(np.sqrt(B))
        t2= (eta**2*M**3)**3/L**6
        t3= 1-(eta*M**2*xi)/L
        ct1= (1/(4*S1*S**2))*(xi*M**2*(S**2+S1**2-S2**2)+np.sqrt(B)*cosvarphi)
        ct2= (1/(4*S2*S**2))*(xi*M**2*(S**2+S2**2-S1**2)-np.sqrt(B)*cosvarphi)
        ct12=(S**2-S1**2-S2**2)/(2.*S1*S2)
        t4=(np.abs(1.-ct1**2-ct2**2-ct12**2 +2.*ct1*ct2*ct12))**.5        
        der=sign*t1*t2*t3*t4

    else:
        
        # Compute dS/dt
        t1= (-3. * (1.-q**2) *S1*S2*eta**6*M**9)/(2.*q*S*L**5)
        t2= 1.-((eta*M**2*xi)/L)
        #It's faster if you don't call [parametric_angles] here. Equivalent to 
            #theta1,theta2,deltaphi,theta12 = parametric_angles(S,J,xi,q,S1,S2,r)    
            #der=sign*t1*t2*np.sin(theta1)*np.sin(theta2)*np.sin(deltaphi)
        ct1= ( ((J**2-L**2-S**2)/L) - (2.*q*M**2*xi)/(1.+q) )/(2.*(1.-q)*S1)
        ct2= ( ((J**2-L**2-S**2)*(-q/L)) + (2.*q*M**2*xi)/(1.+q) )/(2.*(1.-q)*S2)
        ct12=(S**2-S1**2-S2**2)/(2.*S1*S2)
        t3=(np.abs(1.-ct1**2-ct2**2-ct12**2 +2.*ct1*ct2*ct12))**.5 # I know abs is dirty, but does the job
        der=sign*t1*t2*t3
        
    return der
    
    
def dtdS(S,xi,J,q,S1,S2,r,sign=1.):

    '''
    Auxiliary function dt/dS=(dS/dt)^-1. `See precession.dSdt`.

    **Call:**

        dtdS=precession.dtdS(S,xi,J,q,S1,S2,r,sign=1.)
    
    **Parameters:**
    
    - `S`: magnitude of the total spin.
    - `xi`: projection of the effective spin along the orbital angular momentum.
    - `J`: magnitude of the total angular momentum.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `r`: binary separation.
    - `sign`: if 1 return angle in [0,pi], if -1 return angle in [-pi,0].

    **Returns:**

    - `dtdS`: inverse of the precessional-cycle speed.
    '''

    return 1./(dSdt(S,xi,J,q,S1,S2,r,sign))


def t_of_S( S_initial,S_final ,Sb_min,Sb_max ,xi,J,q,S1,S2,r, t_initial=0, sign=1. ):

    '''
    Integrate `precession.dSdt' to find t (time) as a function of S (magnitude of the total spin). Since dS/dt depends on S and not on t, finding t(S) only requires a numnerical integration; finding S(t) would require a ODE solver (straightforward, but it has not been implemented). Sb_min and Sb_max are passed to this function (and not computed within it) for computational efficiency. This function can only integrate over half precession period (i.e. from Sb_min to Sb_max at most). If you want t(S) over more precession periods you should stich different solutions together, consistently with the argument sign (in particular, flip sign every half period).

    **Call:**

        t=precession.t_of_S(S_initial,S_final,Sb_min,Sb_max,xi,J,q,S1,S2,r,t_initial=0,sign=1.)
    
    **Parameters:**
    
    - `S_initial`: lower edge of the integration domain.
    - `S_final`: upper edge of the integration domain.
    - `Sb_min`: minimum value of S from geometrical constraints. This is S- in our papers.
    - `Sb_max`: maximum value of S from geometrical constraints. This is S+ in our papers.
    - `xi`: projection of the effective spin along the orbital angular momentum.
    - `J`: magnitude of the total angular momentum.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `r`: binary separation.
    - `t_initial`: intial integration time.
    - `sign`: if 1 return angle in [0,pi], if -1 return angle in [-pi,0].

    **Returns:**

    - `t`: time (in total mass units).
    '''

    global flags_q1
    if q==1:
        if flags_q1[4]==False:
            print "[t_of_S] Warning q=1: input here is cos(varphi) not S; now computing t( cos(varphi) )"
            flags_q1[4]=True
            
        L=(q/(1.+q)**2)*(r*M**3)**.5
        S = np.sqrt(J**2-L**2-xi*L*M**2)
        S_min,S_max=St_limits(J,q,S1,S2,r)
        if np.abs(S-S_min)<1e-8 or np.abs(S-S_max)<1e-8:
            print "[t_of_S] Warning: you are at resonance, varphi is ill defined here."
            return 0.
        elif min(S_initial,S_final) < -1 or max(S_initial,S_final) > 1:
            print "[t_of_S] Error. You're trying to integrate over more than one (half)period"
            sys.exit()
        else:
            res=sp.integrate.quad(dtdS, S_initial, S_final, args=(xi,J,q,S1,S2,r,sign),full_output=1)
            return t_initial + res[0]
            
    if np.abs(Sb_min-Sb_max)<1e-8: # This happens when [Sb_limits] fails in bracketing of the solutions. In practice, this is a resonant binary.
        return 0.
    elif min(S_initial,S_final) < Sb_min or max(S_initial,S_final) > Sb_max:
        print "[t_of_S] Error. You're trying to integrate over more than one (half)period"
        print Sb_min,Sb_max
        sys.exit()
    else:
        res=sp.integrate.quad(dtdS, S_initial, S_final, args=(xi,J,q,S1,S2,r,sign),full_output=1)               
        return t_initial + res[0]


def precession_period(xi,J,q,S1,S2,r):
    
    '''
    Find the period of S, i.e. the precessional timescale. This is `precession.t_of_S` integrated from Sb_min to Sb_max times 2.

    **Call:**

        tau=precession.precession_period(xi,J,q,S1,S2,r)
    
    **Parameters:**
    
    - `xi`: projection of the effective spin along the orbital angular momentum.
    - `J`: magnitude of the total angular momentum.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `r`: binary separation.

    **Returns:**

    - `tau`: precessional period (in total mass units).
    '''
    
    if q==1: # If q=1, the limits must be specified in cos(varphi)
       Sb_min=-1
       Sb_max=1
    else:
        Sb_min,Sb_max=Sb_limits(xi,J,q,S1,S2,r)
    
    halfperiod = t_of_S(Sb_min,Sb_max,Sb_min,Sb_max,xi,J,q,S1,S2,r)
    #abs because here you don't care about the <sign> issue in dS/dt here
    return np.abs(2*halfperiod)


def OmegazdtdS(S,xi,J,q,S1,S2,r,sign=1.):
    
    '''
    Auxiliary function Omega_z * dt/dS. See `precession.Omegaz` and `precession.dSdt`.

    **Call:**

        OmegadtdS=precession.OmegazdtdS(S,xi,J,q,S1,S2,r,sign=1.):
    
    **Parameters:**
    
    - `S`: magnitude of the total spin.
    - `xi`: projection of the effective spin along the orbital angular momentum.
    - `J`: magnitude of the total angular momentum.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `r`: binary separation.
    - `sign`: if 1 return angle in [0,pi], if -1 return angle in [-pi,0].

    **Returns:**

    - `OmegadtdS`: Omega_z * dt/dS.
    '''

    global flags_q1
    if q==1:
        if flags_q1[5]==False:
            print "[OmegazdtdS] Warning q=1: input here is cos(varphi), not S; now computing Omegaz * dt / d(cos(varphi))"
            flags_q1[5]=True
        cosvarphi=S # The input variable is actually cos(varphi)
        L=(q/(1.+q)**2)*(r*M**3)**.5
        S=np.sqrt(J**2-L**2-xi*L*M**2)
        return Omegaz(S,xi,J,q,S1,S2,r)/np.abs(dSdt(cosvarphi,xi,J,q,S1,S2,r,sign))
    
    else:
        return Omegaz(S,xi,J,q,S1,S2,r)/np.abs(dSdt(S,xi,J,q,S1,S2,r,sign)) 


def alpha_of_S( S_initial,S_final ,Sb_min,Sb_max ,xi,J,q,S1,S2,r, alpha_initial=0, sign=1.):
    
    '''
    Integrate `precession.Omegaz' to find the precession angle spanned by L about J, phiL, as a function of S. Sb_min and Sb_max are passed to this function (and not computed in it) to speed things up. This function can only integrate over half precession period (i.e. from Sb_min to Sb_max at most). If you want phiL(S) over more precession periods you should stich different solutions together, consistently with the argument sign (in particular, flip sign every half period).

    **Call:**

        phiL=precession.alpha_of_S(S_initial,S_final,Sb_min,Sb_max,xi,J,q,S1,S2,r,alpha_initial=0,sign=1.):
    
    **Parameters:**
    
    - `S_initial`: lower edge of the integration domain.
    - `S_final`: upper edge of the integration domain.
    - `Sb_min`: minimum value of S from geometrical constraints. This is S- in our papers.
    - `Sb_max`: maximum value of S from geometrical constraints. This is S+ in our papers.
    - `xi`: projection of the effective spin along the orbital angular momentum.
    - `J`: magnitude of the total angular momentum.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `r`: binary separation.
    - `alpha_initial`: initial integration angle.
    - `sign`: if 1 return angle in [0,pi], if -1 return angle in [-pi,0].

    **Returns:**

    - `phiL`: azimuthal angle spanned by L about J.
    '''

    global flags_q1
    if q==1:
        if flags_q1[6]==False:
            print "[alpha_of_S] Warning q=1: input here is cos(varphi), not S; now computing alpha(cosvarphi)"
            flags_q1[6]=True
        
        L=(q/(1.+q)**2)*(r*M**3)**.5
        S = np.sqrt(J**2-L**2-xi*L*M**2)
        S_min,S_max=St_limits(J,q,S1,S2,r)
        
        if np.abs(S-S_min)<1e-8 or np.abs(S-S_max)<1e-8:
            print "[alpha_of_S] Warning: you are at resonance, varphi is ill defined here."
            return 0.
        elif min(S_initial,S_final) < -1 or max(S_initial,S_final) > 1:
            print "[alpha_of_S] Error. You're trying to integrate over more than one (half)period"
            sys.exit()
        else:
            # If q=1, S is constant and therefore Omegaz is also constant. It can be taken out of the integral.
            deltat=t_of_S(S_initial,S_final,Sb_min,Sb_max,xi,J,q,S1,S2,r)
            return alpha_initial + Omegaz(S,xi,J,q,S1,S2,r) *deltat            
    
    if np.abs(Sb_min-Sb_max)<1e-8: # This typically happen when [Sb_limits] fails in bracketing of the solutions. In practice, this is a resonant binary.
        return 0.
    elif min(S_initial,S_final) < Sb_min or max(S_initial,S_final) > Sb_max:
        print "[alpha_of_S] Error. You're trying to integrate over more than one (half)period"
        print Sb_min,Sb_max
        sys.exit()
    else:
        # Actual integration
        res=sp.integrate.quad(OmegazdtdS, S_initial, S_final, args=(xi,J,q,S1,S2,r,sign),full_output=1)               
        return alpha_initial + res[0]


def alphaz(xi,J,q,S1,S2,r):

    '''
    Angle spanned by L about J in a single precession cycle. This is `precession.alpha_of_S` integrated from Sb_min to Sb_max times 2.

    **Call:**

        alpha=precession.alphaz(xi,J,q,S1,S2,r)
    
    **Parameters:**
    
    - `xi`: projection of the effective spin along the orbital angular momentum.
    - `J`: magnitude of the total angular momentum.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `r`: binary separation.

    **Returns:**

    - `alpha`: azimuthal angle spanned by L about J in an entire precession cycle.
    '''

    if q==1: # If q=1, the limits must be specified in cos(varphi)
        Sb_min=-1
        Sb_max=1
        return 2*alpha_of_S(Sb_min,Sb_max,Sb_min,Sb_max,xi,J,q,S1,S2,r) 
        
    else:
        Sb_min,Sb_max=Sb_limits(xi,J,q,S1,S2,r)
        if np.abs(Sb_min-Sb_max)<1e-8: # This typically happen when [Sb_limits] fails in bracketing of the solutions. In practice, this is a resonant binary.
            return 0.
        else:
            res=sp.integrate.quad(OmegazdtdS, Sb_min, Sb_max, args=(xi,J,q,S1,S2,r), full_output=1)
        return 2*res[0]


def samplingS(xi,J,q,S1,S2,r):
    
    '''
    Select a value of S weighted with |dt/dS|. Sampling implemented using the cumulative distribution:
    
    1. select a random number epsilon in [0,1];
    2. find the value of S at which the cumulative probability distribution is equal to epsilon.

    The cumulative-distribution method is particualry suitable because the probability distribution function |dt/dS| diverges at the extrema Sb_min and Sb_max (and is troubling to apply a hit-or-miss approach).

    **Call:**

        S=precession.samplingS(xi,J,q,S1,S2,r)
    
    **Parameters:**
    
    - `xi`: projection of the effective spin along the orbital angular momentum.
    - `J`: magnitude of the total angular momentum.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `r`: binary separation.

    **Returns:**

    - `S`: magnitude of the total spin.
    '''

    global flags_q1
    if q==1:
        if flags_q1[7]==False:
            print "[samplingS] Warning q=1: sampling is cos(varphi), not S"
            flags_q1[7]=True
            
        # If q=1, the limits must be specified in cos(varphi)
        tol=1e-10 # Don't go too close to the actual limits
        Sb_min=-1.+tol
        Sb_max=1.-tol
        
    else:
        Sb_min,Sb_max=Sb_limits(xi,J,q,S1,S2,r)
    
    if np.abs(Sb_min-Sb_max)<1e-8: # This typically happen when [Sb_limits] fails in bracketing of the solutions. In practice, this is a resonant binary.
        S_sol=(Sb_min+Sb_max)/2.
    else:
        halfperiod=t_of_S(Sb_min,Sb_max,Sb_min,Sb_max,xi,J,q,S1,S2,r)
        
        eps= random.uniform(0,1)    
        
        S_sol= sp.optimize.brentq(lambda S: np.abs(t_of_S(Sb_min,S,Sb_min,Sb_max,xi,J,q,S1,S2,r) / halfperiod) - eps, Sb_min, Sb_max) # The brentq algorithm works very well with a monotonic function like the cumulative distribution

    return S_sol            




#################################
# PRECESSION-AVERAGED INSPIRAL ##
#################################

def St_limits_comp(kappa,q,S1,S2,u):

    '''
    Auxiliary function, see `precession.St_limits`.
    
    **Call:**

        St_min,St_max=precession.St_limits_comp(kappa,q,S1,S2,u)

    **Parameters:**
    
    - `kappa`: rescaling of the total angular momentum to compactify the inspiral domain.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `u`: rescaling of the orbital angular momentum to compactify the inspiral domain.

    **Returns:**
    
    - `St_min`: minimum value of S from geometrical constraints. This is S_min in our papers.
    - `St_max`: maximum value of S from geometrical constraints. This is S_max in our papers.
    '''

    if u==0:
        St_min=max(np.abs(S1-S2),np.abs(kappa))
        St_max=S1+S2
    else:
        St_min=max(np.abs(S1-S2),np.abs( ((1.+4*kappa*u)**0.5-1)/(2.*u)))
        St_max=min(S1+S2,np.abs( ((1.+4*kappa*u)**0.5+1)/(2.*u)))

    return float(St_min),float(St_max)
    
    
def xi_plus_comp(S,kappa,q,S1,S2,u):

    '''
    Auxiliary function, see `precession.xi_plus`.
    
    **Call:**

        xi=precession.xi_plus_comp(S,kappa,q,S1,S2,u)

    **Parameters:**
    
    - `S`: magnitude of the total spin.
    - `kappa`: rescaling of the total angular momentum to compactify the inspiral domain.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `u`: rescaling of the orbital angular momentum to compactify the inspiral domain.

    **Returns:**

    - `xi`: projection of the effective spin along the orbital angular momentum.
    '''

    t1= kappa-u*S**2
    t2=S**2*(1.+q)**2-(S1**2-S2**2)*(1.-q**2)
    if S in St_limits_comp(kappa,q,S1,S2,u): #if you're on the limits, the second bit must be zero
        t3=t4=t5=0
    else:
        t3=(1.-q**2)*(S**2 - kappa**2-u**2*S**4+2.*u*kappa*S**2)**0.5        
        t4=((S1+S2)**2-S**2)**.5
        t5=(S**2-(S1-S2)**2)**.5    
    t6= 2.*q*M**2*S**2
    return (t1*t2 + t3*t4*t5)/t6
    
    
def xi_minus_comp(S,kappa,q,S1,S2,u):
    
    '''
    Auxiliary function, see `precession.xi_minus`.
        
    **Call:**

        xi=precession.xi_minus_comp(S,kappa,q,S1,S2,u)

    **Parameters:**
    
    - `S`: magnitude of the total spin.
    - `kappa`: rescaling of the total angular momentum to compactify the inspiral domain.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `u`: rescaling of the orbital angular momentum to compactify the inspiral domain.

    **Returns:**

    - `xi`: projection of the effective spin along the orbital angular momentum.
    '''
    
    t1= kappa-u*S**2
    t2=S**2*(1.+q)**2-(S1**2-S2**2)*(1.-q**2)
    if S in St_limits_comp(kappa,q,S1,S2,u): #if you're on the limits, the second bit must be zero
        t3=t4=t5=0
    else:
        t3=(1.-q**2)*(S**2 - kappa**2-u**2*S**4+2.*u*kappa*S**2)**0.5
        t4=((S1+S2)**2-S**2)**.5
        t5=(S**2-(S1-S2)**2)**.5    
    t6= 2.*q*M**2*S**2
    return (t1*t2 - t3*t4*t5)/t6
   
   
def Sb_limits_comp(xi,kappa,q,S1,S2,u):

    '''
    Auxiliary function, see `precession.Sb_limits`.
        
    **Call:**

        Sb_min,Sb_max=precession.Sb_limits_comp(xi,kappa,q,S1,S2,u)

    **Parameters:**
    
    - `xi`: projection of the effective spin along the orbital angular momentum.
    - `kappa`: rescaling of the total angular momentum to compactify the inspiral domain.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `u`: rescaling of the orbital angular momentum to compactify the inspiral domain.

    **Returns:**

    - `Sb_min`: minimum value of S from geometrical constraints. This is S- in our papers.
    - `Sb_max`: maximum value of S from geometrical constraints. This is S+ in our papers.   
    '''

    global flags_q1
    if q==1:
        if u==0:
            if flags_q1[8]==False:
                print "[Sb_limits_comp] Warning q=1,u=0: input for kappa means S"
                flags_q1[8]=True
            Sb_both=kappa
        else:
           Sb_both=np.sqrt(kappa/u-0.5*xi*M**2/u)
        return Sb_both,Sb_both

    St_min,St_max=St_limits_comp(kappa,q,S1,S2,u)
    xi_low=xi_minus_comp(St_min,kappa,q,S1,S2,u) 
    xi_up=xi_minus_comp(St_max,kappa,q,S1,S2,u)
 
    #Debug option: print the parameter-space region of the initial guess
    whereareyou=False
 
    # Both roots on xi_plus. Split the interval first
    if xi > xi_low and xi > xi_up:    

        if whereareyou:
            print "[Sb_limits_comp] Both roots on xi_plus"

        resmax= sp.optimize.fminbound(lambda S: -1.*xi_plus_comp(S,kappa,q,S1,S2,u), St_min, St_max,full_output=1)
        S_up=resmax[0]
        xi_max=-1.*resmax[1]
        if xi_max<xi: #Braket failed!
            print "[Sb_limits_comp] Braket failed on xi_plus at u="+str(u)+". Assume Sb_min=Sb_max"
            #print  xi_plus(S_up,J,q,S1,S2,r), xi
            Sb_min=S_up
            Sb_max=S_up  
        else: #Braket succeeded!
                    
            Sb_min= sp.optimize.brentq(lambda S: xi_plus_comp(S,kappa,q,S1,S2,u)-xi, St_min, S_up)
            Sb_max= sp.optimize.brentq(lambda S: xi_plus_comp(S,kappa,q,S1,S2,u)-xi, S_up, St_max)

    # Both roots on xi_minus. Split the interval first
    elif xi < xi_low and xi < xi_up:    
        
        if whereareyou:
            print "[Sb_limits_comp] Both roots on xi_minus"
            
        resmin= sp.optimize.fminbound(lambda S: xi_minus_comp(S,kappa,q,S1,S2,u), St_min, St_max,full_output=1)
        S_low=resmin[0]
        xi_min=resmin[1]
                 
        if xi_min>xi: #Braket failed! 
            print "[Sb_limits_comp] Braket failed on xi_minus at u="+str(u)+". Assume Sb_min=Sb_max"
            Sb_min=S_low
            Sb_max=S_low  
        else: #Braket succeeded!
            Sb_min= sp.optimize.brentq(lambda S: xi_minus_comp(S,kappa,q,S1,S2,u)-xi, St_min, S_low)
            Sb_max= sp.optimize.brentq(lambda S: xi_minus_comp(S,kappa,q,S1,S2,u)-xi, S_low, St_max)

    # One root on xi_plus and the other one on xi_plus. No additional maximization is neeeded
    elif xi >= xi_low and xi <= xi_up:    

        if whereareyou:
            print "[Sb_limits_comp] Sb_min on xi_plus, Sb_max on xi_minus"

        Sb_min= sp.optimize.brentq(lambda S: xi_plus_comp(S,kappa,q,S1,S2,u)-xi, St_min, St_max)
        Sb_max= sp.optimize.brentq(lambda S: xi_minus_comp(S,kappa,q,S1,S2,u)-xi, St_min, St_max)
    elif xi <= xi_low and xi >= xi_up:    
    
        if whereareyou:
            print "[Sb_limits_comp] Sb_min on xi_minus, Sb_max on xi_plus"

        Sb_min= sp.optimize.brentq(lambda S: xi_minus_comp(S,kappa,q,S1,S2,u)-xi, St_min, St_max)
        Sb_max= sp.optimize.brentq(lambda S: xi_plus_comp(S,kappa,q,S1,S2,u)-xi, St_min, St_max)
                    
    else:
        print "[Sb_limits_comp] Erorr in case selection"
        print "xi=", xi
        print "xi(stmin)=", xi_low
        print "xi(stmax)=", xi_up
        print "Stmin=", St_min
        print "Stmax", St_max
        print "kappa=", kappa
        print "u=", u
        sys.exit()

    btol=1e-8 # Never go to close to the actual limits, because everything blows up there
    Sb_min+=btol
    Sb_max-=btol
    
    if whereareyou:
        print "[Sb_limits_comp] Results:", Sb_min,Sb_max
    
    
    if Sb_min>Sb_max: # This may happen (numerically) if they're too close to each other. Assume they're the same.
        return np.mean([Sb_min,Sb_max]), np.mean([Sb_min,Sb_max])
    else: 
        return Sb_min, Sb_max

      
def S3sines_comp(S,xi,kappa,q,S1,S2,u):

    '''
    Auxiliary function, see `precession.dkappadu`.
        
    **Call:**

        denominator=precession.S3sines_comp(S,xi,kappa,q,S1,S2,u)

    **Parameters:**
    
    - `S`: magnitude of the total spin.
    - `xi`: projection of the effective spin along the orbital angular momentum.
    - `kappa`: rescaling of the total angular momentum to compactify the inspiral domain.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `u`: rescaling of the orbital angular momentum to compactify the inspiral domain.

    **Returns:**

    - `denominator`: denominator in integrand `precession.dkappapu`.
    '''

    ct1= ( kappa - u*S**2  - q*M**2*xi/(1.+q) )/((1.-q)*S1)
    ct2= q*( -kappa + u*S**2  + M**2*xi/(1.+q) )/((1.-q)*S2)
    ct12=(S**2-S1**2-S2**2)/(2.*S1*S2)
    t3=max( (np.abs(1.-ct1**2-ct2**2-ct12**2 +2.*ct1*ct2*ct12))**.5, 1e-20) # I know abs is dirty, but does the job 
    if t3==0: # prevent occasional crash
        t3=1e-20
    return S**3/t3


def Ssines_comp(S,xi,kappa,q,S1,S2,u):
    
    '''
    Auxiliary function, see `precession.dkappadu`.

    **Call:**

        numerator=precession.Ssines_comp(S,xi,kappa,q,S1,S2,u)

    **Parameters:**
    
    - `S`: magnitude of the total spin.
    - `xi`: projection of the effective spin along the orbital angular momentum.
    - `kappa`: rescaling of the total angular momentum to compactify the inspiral domain.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `u`: rescaling of the orbital angular momentum to compactify the inspiral domain.

    **Returns:**

    - `numerator`: numerator in integrand `precession.dkappapu`.
    '''
    
    ct1= ( kappa - u*S**2  - q*M**2*xi/(1.+q) )/((1.-q)*S1)
    ct2= q*( -kappa + u*S**2  + M**2*xi/(1.+q) )/((1.-q)*S2)
    ct12=(S**2-S1**2-S2**2)/(2.*S1*S2)
    t3=max( (np.abs(1.-ct1**2-ct2**2-ct12**2 +2.*ct1*ct2*ct12))**.5, 1e-20) # I know abs is dirty, but does the job 
    return S/t3
    
    
def dkappadu(kappa,u,xi,q,S1,S2):    
      
    '''
    Inspiral ODE to perform precession-averaged inspiral: dkappa/du = S^2_pre. We use variables kappa and u (rather than J and L, see `precession.dJdL`) because this formulation naturally allows for integration from infinitely large separations, i.e. u=0. This function is only the actual equation, not the ODE solver.

    **Call:**

        dkappadu=precession.dkappadu(kappa,u,xi,q,S1,S2)
    
    **Parameters:**

    - `kappa`: rescaling of the total angular momentum to compactify the inspiral domain.
    - `u`: rescaling of the orbital angular momentum to compactify the inspiral domain.
    - `xi`: projection of the effective spin along the orbital angular momentum.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.

    **Returns:**

    - `dkappadu`: precession-averaged derivative of kappa with respect to u.
    '''
  
    dkappadu_debug=False #Debug option
    if dkappadu_debug:
        print "[dkappadu] ODE int: u="+str(u)+"\t\tkappa="+str(float(kappa))
    
    Sb_min,Sb_max = Sb_limits_comp(xi,kappa,q,S1,S2,u)

    if np.abs(Sb_min-Sb_max)<1e-8:
        if dkappadu_debug:
            print "[dkappadu] Warning. Applyting analytical approximation. u=",u
        return (np.mean([Sb_min,Sb_max]))**2
    else:      
        up=sp.integrate.quad(S3sines_comp, Sb_min, Sb_max, args=(xi,kappa,q,S1,S2,u), full_output=1)
        down=sp.integrate.quad(Ssines_comp , Sb_min, Sb_max, args=(xi,kappa,q,S1,S2,u), full_output=1)
        return up[0]/down[0]


def dJdr(J,r,xi,q,S1,S2):

    '''
    Inspiral ODE describing the evolution of the magnitude of the total angular momentum vs. the separation r. This function is NOT used by the ODE solvers (see `precession.dkappadu`).

    **Call:**

        dJdr=precession.dJdr(J,r,xi,q,S1,S2)
    
    **Parameters:**

    - `J`: magnitude of the total angular momentum.
    - `r`: binary separation.
    - `xi`: projection of the effective spin along the orbital angular momentum.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.

    **Returns:**

    - `dJdr`: precession-averaged derivative of J with respect to r.
    '''

    L=(q/(1.+q)**2)*(r*M**3)**.5    
    kappa=(J**2-L**2)/(2.*L)
    u=1./(2.*L)
    S2pre=dkappadu(kappa,u,xi,q,S1,S2)
    dJdL=(1./(2.*L*J))*(J**2+L**2-S2pre)
    dLdr=L/(2.*r)

    return dJdL*dLdr

def dJdL(J,r,xi,q,S1,S2):

    '''
    Inspiral ODE describing the evolution of the magnitude of the total angular momentum vs. the separation r. This function is NOT used by the ODE solvers (see `precession.dkappadu`).

    **Call:**

        dJdL=precession.dJdL(J,r,xi,q,S1,S2)
    
    **Parameters:**

    - `J`: magnitude of the total angular momentum.
    - `r`: binary separation.
    - `xi`: projection of the effective spin along the orbital angular momentum.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.

    **Returns:**

    - `dJdL`: precession-averaged derivative of J with respect to L.
    '''

    L=(q/(1.+q)**2)*(r*M**3)**.5    
    kappa=(J**2-L**2)/(2.*L)
    u=1./(2.*L)
    S2pre=dkappadu(kappa,u,xi,q,S1,S2)
    dJdL=(1./(2.*L*J))*(J**2+L**2-S2pre)
    return dJdL


def Jofr(xi,J_initial,r_vals,q,S1,S2):

    '''
    Single integration of the dJ/dL equation to perfom precession-averaged inspiral. Input/output are provided in J and r, but the internal integrator uses kappa and u (see `precession.dkappadu`). Integration is performed using scipy's `odeint`.
    
    This function integrates to/from FINITE separations only.
    
    It takes the desired output separations r_vals, and the intial condition for the total angular momentum J_initial. The latter must be consistent with the initial separation (i.e. r_vals[0]) and the value of xi; an error is raised in case of inconsistencies. It doesn't matter if you integrate from large to small separations of the other way round, as long as J_initial is consistent with r_vals[0]. It returns a vector with the values of J at each input separation, the first item being just the initial condition.
    
    We recommend to use this function through the wrapper `precession.evolve_J` provided.

    **Call:**

        J_vals=precession.Jofr(xi,J_initial,r_vals,q,S1,S2)
    
    **Parameters:**

    - `xi`: projection of the effective spin along the orbital angular momentum.
    - `J_initial`: initial condition for numerical integration.
    - `r_vals`: binary separation (array).
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.

    **Returns:**

    - `J_vals`: magnitude of the total angular momentum (array).
    '''

    L_vals=[ (q/(1.+q)**2)*(r*M**3)**.5 for r in r_vals]
    kappa_initial= (J_initial**2 - (L_vals[0])**2) / (2.*L_vals[0])
    u_vals=[ 1./(2.*L) for L in L_vals]

    # Analytical solution for q=1. S is constant on the radiation-reaction time
    if q==1:
        L_initial=L_vals[0]
        Ssq=J_initial**2-L_initial**2-xi*L_initial*M**2
        J_vals=[np.sqrt(Ssq+((q/(1.+q)**2)*(r*M**3)**.5)**2+xi*M**2*((q/(1.+q)**2)*(r*M**3)**.5)) for r in r_vals]
    
    # Numerical integration
    else:
        #sing = [ M*((1.+q)**2*(S1+S2)/(q*M**2))**2 ,  M*((1.+q)**2*(S1-S2)/(q*M**2))**2 ] # Expected singularities. Not needed
        # Increase h0 to prevent occasional slowing down of the integration
        res =integrate.odeint(dkappadu, kappa_initial, u_vals, args=(xi,q,S1,S2), mxstep=50000, full_output=0, printmessg=0)#,h0=0.001)#,tcrit=sing)
        kappa_vals=[x[0] for x in res]
        J_vals= [ (k*2.*L + L**2)**0.5 for k,L in zip(kappa_vals,L_vals)]
    return J_vals
    
    
def Jofr_checkpoint(xi,J_initial,r_vals,q,S1,S2):

    '''
    Auxiliary function, see `precession.evolve_J`.

    **Call:**

        savename=precession.Jofr_checkpoint(xi,J_initial,r_vals,q,S1,S2)
    
    **Parameters:**

    - `xi`: projection of the effective spin along the orbital angular momentum.
    - `J_initial`: initial condition for numerical integration.
    - `r_vals`: binary separation (array).
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.

    **Returns:**

    - `savename`: checkpoint filename.
    '''
    
    os.system("mkdir -p "+storedir) 
    savename= storedir+"/evJ_"+'_'.join([str(x) for x in (xi,J_initial,max(r_vals),min(r_vals),len(r_vals),q,S1,S2)])+".dat"
        
    if not os.path.isfile(savename):
        print "[evolve_J] Transferring binary. Output:", savename
        outfilesave = open(savename,"w",0)
       
        J_vals= Jofr(xi,J_initial,r_vals,q,S1,S2)

        for J_f,r_f in zip(J_vals,r_vals):        
            outfilesave.write(str(r_f)+" "+str(J_f)+"\n")
        outfilesave.close()

    #else:
    #    print "[evolve_J] Skipping. Output:", savename
    
    return savename


def evolve_J(xi_vals,J_vals,r_vals,q,S1,S2):

    '''
    Wrapper of `precession.Jofr` to enable parallelization through the python `parmap` module; the number of available cores can be specified using the integer global variable `CPUs` (all available cores will be used by default). Evolve a sequence of binaries with the SAME q, S1, S2 but different xi and initial values of J and save outputs at r_vals. Output is a 2D array, where e.g. J_vals[0] is the first binary (1D array at all output separations) and J_vals[0][0] is the first binary at the first output separation (this is a scalar). We strongly reccommend using this function, even for a single binary.

    Checkpointing is implemented: results are stored in `precession.storedir`.
 
    **Call:**

        Jf_vals=precession.evolve_J(xi_vals,Ji_vals,r_vals,q,S1,S2)
     
    **Parameters:**

    - `xi_vals`: projection of the effective spin along the orbital angular momentum (array).
    - `Ji_vals`: initial condition for numerical integration (array).
    - `r_vals`: binary separation (array).
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.

    **Returns:**

    - `Jf_vals`: magnitude of the total angular momentum (2D array).
    '''

    global CPUs

    single_flag=False
    try: # Convert float to array if you're evolving just one binary
        len(xi_vals)
        len(J_vals)
    except:
        xi_vals=[xi_vals]
        J_vals=[J_vals]
        single_flag=True
    try: # Set default
        CPUs
    except:
        CPUs=0
        print "[evolve_J] Default parallel computation"
    # Parallelization.
    if CPUs==0: # Run on all cpus on the current machine! (default option)
        filelist=parmap.starmap(Jofr_checkpoint, zip(xi_vals,J_vals),r_vals,q,S1,S2,parallel=True) 
    elif CPUs==1: # 1 cpus done by explicitely switching parallelization off
        filelist=parmap.starmap(Jofr_checkpoint, zip(xi_vals,J_vals),r_vals,q,S1,S2,parallel=False) 
    else: # Run on a given number of CPUs        
        p = multiprocessing.Pool(CPUs)
        filelist=parmap.starmap(Jofr_checkpoint, zip(xi_vals,J_vals),r_vals,q,S1,S2,pool=p) 

    J_fvals=[]
    for index, file in enumerate(filelist):
        print "[evolve_J] Reading:", index, file
        dummy,J_f= np.loadtxt(file,unpack=True)
             
        J_fvals.append(J_f)

    if single_flag==True:
        return J_fvals[0]
    else:
        return J_fvals


def evolve_angles_single(theta1_i,theta2_i,deltaphi_i,r_vals,q,S1,S2):

    '''
    Auxiliary function, see `evolve_angles`.

    **Call:**

        savename=precession.evolve_angles(theta1_i,theta2_i,deltaphi_i,r_vals,q,S1,S2)

    **Parameters:**
    
    - `theta1_i`: initial condition for theta1.
    - `theta2_i`: initial condition for theta2
    - `deltaphi_i`: initial condition for deltaphi.
    - `r_vals`: binary separation (array).
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.

    **Returns:**

    - `savename`: checkpoint filename.
    '''


    os.system("mkdir -p "+storedir) 
    savename= storedir+"/eva_"+'_'.join([str(x) for x in (theta1_i,theta2_i,deltaphi_i,max(r_vals),min(r_vals),len(r_vals),q,S1,S2)])+".dat"
        
    if not os.path.isfile(savename):
        print "[evolve_angles] Transferring binary. Output:", savename
        outfilesave = open(savename,"w",0)
       
        # Step 1. Get xi and J for each intial angle. Forget S    
        xi,J_i,dummy= from_the_angles(theta1_i,theta2_i,deltaphi_i,q,S1,S2,r_vals[0]) 
                
        # Step 2. Evolve binaires with the dJ/dr ODE.
        J_vals= Jofr(xi,J_i,r_vals,q,S1,S2)

        for J_f,r_f in zip(J_vals,r_vals):
            # Step 3. Select S at the final separation with weight dt/dS
            S_f=samplingS(xi,J_f,q,S1,S2,r_f)
            # Step 4. Back to theta1, theta2, deltaphi
            theta1_f,theta2_f,deltaphi_f,dummy= parametric_angles(S_f,J_f,xi,q,S1,S2,r_f)
            deltaphi_f*=random.choice([-1., 1.])
            # Step 5. Store data            
            #outfilesave.write(str(r_f)+" "+str(xi)+" "+str(J_f)+" "+str(S_f)+" "+str(theta1_f)+" "+str(theta2_f)+" "+str(deltaphi_f)+"\n")
            outfilesave.write(str(r_f)+" "+str(theta1_f)+" "+str(theta2_f)+" "+str(deltaphi_f)+"\n")
        outfilesave.close()

    #else:
    #    print "[evolve_angles] Skipping. Output:", savename
    
    return savename


def evolve_angles(theta1_vals,theta2_vals,deltaphi_vals,r_vals,q,S1,S2):

    '''
    Binary evolution from the angles theta1, theta2 and deltaphi as initial data (to/from FINITE separations only). This is our so-called *transfer function*. The transfer procedure is implemented as follows:
    
    1. Convert theta1,theta2, deltaphi into J, xi and S.
    2. Forget S and evolve J.
    3. Resample S at the final separation according to dt/dS. 
    4. Covert J, xi and S back to theta1, theta2 and deltaphi; assign a random sign to deltaphi.

    Parallelization through the python `parmap` module is implemented; the number of available cores can be specified using the integer global variable `CPUs` (all available cores will be used by default). Evolve a sequence of binaries with the SAME q, S1,S2 but different theta1, theta2, deltaphi (assumed to be specified at r_vals[0]) and save outputs at r_vals. Outputs are 2D arrays, where e.g theta1_fvals[0] is the first binary (1D array at all output separations) and theta1_fvals[0][0] is the first binary at the first output separation (this is a scalar).

    Checkpointing is implemented: results are stored in `precession.storedir`.
 
    **Call:**

        theta1f_vals,theta2f_vals,deltaphif_vals=precession.evolve_angles(theta1i_vals,theta2i_vals,deltaphii_vals,r_vals,q,S1,S2)
         
    **Parameters:**
    
    - `theta1i_vals`: initial condition for theta1 (array).
    - `theta2i_vals`: initial condition for theta2 (array).
    - `deltaphii_vals`: initial condition for deltaphi (array).
    - `r_vals`: binary separation (array).
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.

    **Returns:**

    - `theta1f_vals`: solutions for theta1 (2D array).
    - `theta2f_vals`: solutions for theta2 (2D array).
    - `deltaphif_vals`: solutions for deltaphi (2D array).
    '''

    global CPUs
    single_flag=False

    try: # Convert float to array if you're evolving just one binary
        len(theta1_vals)
        len(theta1_vals)
        len(deltaphi_vals)
    except:
        single_flag=True
        theta1_vals=[theta1_vals]
        theta2_vals=[theta2_vals]
        deltaphi_vals=[deltaphi_vals]

    try: # Set default
        CPUs
    except:
        CPUs=0
        print "[evolve_angles] Default parallel computation"

    loopflag=True
    while loopflag: # Restart is some of the cores crashed. This happend if you run too many binaries on too many different machines. Nevermind, trash the file and do it again.
        loopflag=False

        #Parallelization
        if CPUs==0: #Run on all cpus on the current machine! (default option)
            filelist=parmap.starmap(evolve_angles_single, zip(theta1_vals,theta2_vals,deltaphi_vals),r_vals,q,S1,S2,parallel=True) 
        elif CPUs==1: #1 cpus done by explicitely removing parallelization
            filelist=parmap.starmap(evolve_angles_single, zip(theta1_vals,theta2_vals,deltaphi_vals),r_vals,q,S1,S2,parallel=False) 
        else: # Run on a given number of CPUs        
            p = multiprocessing.Pool(CPUs)
            filelist=parmap.starmap(evolve_angles_single, zip(theta1_vals,theta2_vals,deltaphi_vals),r_vals,q,S1,S2,pool=p) 

        theta1_fvals=[]
        theta2_fvals=[]
        deltaphi_fvals=[]
        for index, file in enumerate(filelist):
            print "[evolve_angles] Reading:", index, file
            numlines=sum(1 for line in open(file))
            if numlines!=0 and numlines!=len(r_vals): # Restart if core(s) crashed
                print "[evolve_angles] Error on file", file,". Jobs are being restarted!"
                os.system("rm "+file) 
                loopflag=True
 
            else:
                dummy,theta1_f,theta2_f,deltaphi_f= np.loadtxt(file,unpack=True)
                theta1_fvals.append(theta1_f)
                theta2_fvals.append(theta2_f)
                deltaphi_fvals.append(deltaphi_f)        
        
    if single_flag==True:
        return theta1_fvals[0], theta2_fvals[0], deltaphi_fvals[0]
    else:
        return theta1_fvals, theta2_fvals, deltaphi_fvals

      
def Jofr_infinity(xi,kappa_inf,r_vals,q,S1,S2): 

    '''
    Single integration of the dJ/dL equation to perfom precession-averaged inspiral. Input/output are provided in J and r, but the internal integrator uses kappa and u (see `precession.dkappadu`). Integration is performed using scipy's `odeint`.
    
    This function integrates FROM INFINITE separation (u=0) only.    
    
    The latter must be consistent with `precession.kappainf_lim`; an error is raised in case of inconsistencies. It assume that the array r_vals is sorted in reversed order, i.e. that you are integrating from large to small separations. It returns a vector with the values of J at each input separation. The initial condition is NOT returned by this function (unlike the `precession.Jofr` for integrations to/from finite separations). If q=1, kappa_inf is degenerate with xi: the required initial condition is assumed to be S (which is constant).

    We recommend to use this function through the wrapper `precession.evolve_J_infinity` provided.
 
    **Call:**

        J_vals=precession.Jofr_infinity(xi,kappa_inf,r_vals,q,S1,S2)

    **Parameters:**

    - `xi`: projection of the effective spin along the orbital angular momentum.
    - `kappa_inf`: asymptotic value of kappa at large separations.
    - `r_vals`: binary separation (array).
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.

    **Returns:**

    - `J_vals`: magnitude of the total angular momentum (array).
    '''

    # ASSUMES r_vals is sorted in reversed order!!!
    L_vals=[ (q/(1.+q)**2)*(r*M**3)**.5 for r in r_vals]

    global flags_q1 
    if q==1:
        if flags_q1[9]==False:
            print "[Jofr_infinity] Warning q=1: required intial condition is S, not kappa_inf."
            flags_q1[9]=True # Suppress future warnings
        S=kappa_inf
        J_vals=[np.sqrt(L**2+S**2+xi*L*M**2) for L in L_vals]
    else:
        u_vals=[ 1./(2.*L) for L in L_vals]
        u_vals.insert(0, 0.) # Add initial condition, r=inifinty u=0
    
        # Numerical integration from u=0   
        # Increase h0 to prevent occasional slowing down of the integration
        res =integrate.odeint(dkappadu, kappa_inf, u_vals, args=(xi,q,S1,S2), mxstep=50000, full_output=0, printmessg=0,h0=2e-4)

        kappa_vals=[x[0] for x in res][1:] # Remove initial condition (not present in r_vals...)
        J_vals= [ (k*2.*L + L**2)**0.5 for k,L in zip(kappa_vals,L_vals)]
    
    return J_vals

   
def Jofr_infinity_checkpoint(xi,kappa_inf,r_vals,q,S1,S2):
    
    '''
    Auxiliary function, see `precession.evolve_J_infinity`.
 
    **Call:**

        savename=precession.Jofr_infinity_checkpoint(xi,kappa_inf,r_vals,q,S1,S2)

    **Parameters:**

    - `xi`: projection of the effective spin along the orbital angular momentum.
    - `kappa_inf`: asymptotic value of kappa at large separations.
    - `r_vals`: binary separation (array).
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.

    **Returns:**

    - `savename`: checkpoint filename.
    '''
    
    os.system("mkdir -p "+storedir) 
    savename= storedir+"/evJinf_"+'_'.join([str(x) for x in (xi,kappa_inf,max(r_vals),min(r_vals),len(r_vals),q,S1,S2)])+".dat"
        
    if not os.path.isfile(savename):
        print "[evolve_J_infinity] Transferring binary. Output:", savename
        outfilesave = open(savename,"w",0)
       
        J_vals= Jofr_infinity(xi,kappa_inf,r_vals,q,S1,S2)

        for J_f,r_f in zip(J_vals,r_vals):        
            outfilesave.write(str(r_f)+" "+str(J_f)+"\n")
        outfilesave.close()

    #else:
    #    print "[evolve_J_infinity] Skipping. Output:", savename
    
    return savename


def evolve_J_infinity(xi_vals,kappainf_vals,r_vals,q,S1,S2):

    '''
    Wrapper of `precession.Jofr_infinity` to enable parallelization through the python `parmap` module; the number of available cores can be specified using the integer global variable `CPUs` (all available cores will be used by default). Evolve a sequence of binaries with the SAME q, S1, S2 but different xi and initial values of J and save outputs at r_vals. Output is a 2D array, where e.g. J_vals[0] is the first binary (1D array at all output separations) and J_vals[0][0] is the first binary at the first output separation (this is a scalar). We strongly reccommend using this function, even for a single binary.

    Checkpointing is implemented: results are stored in `precession.g`.
 
    **Call:**

        Jf_vals=precession.evolve_J_infinity(xi_vals,kappainf_vals,r_vals,q,S1,S2)

    **Parameters:**

    - `xi_vals`: projection of the effective spin along the orbital angular momentum (array).
    - `kappainf_vals`: asymptotic value of kappa at large separations (array).
    - `r_vals`: binary separation (array).
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.

    **Returns:**

    - `Jf_vals`: magnitude of the total angular momentum (2D array).
    '''

    global CPUs

    single_flag=False
    try: #Convert float to array if you're evolving just one binary
        len(xi_vals)
        len(kappainf_vals)
    except:
        xi_vals=[xi_vals]
        kappainf_vals=[kappainf_vals]
        single_flag=True
    try: # Set default
        CPUs
    except:
        CPUs=0
        print "[evolve_J_infinity] Default parallel computation"
    # Parallelization
    if CPUs==0: # Run on all cpus on the current machine! (default option)
        filelist=parmap.starmap(Jofr_infinity_checkpoint, zip(xi_vals,kappainf_vals),r_vals,q,S1,S2,parallel=True) 
    elif CPUs==1: # 1 cpus done by explicitely removing parallelization
        filelist=parmap.starmap(Jofr_infinity_checkpoint, zip(xi_vals,kappainf_vals),r_vals,q,S1,S2,parallel=False) 
    else: # Run on a given number of CPUs        
        p = multiprocessing.Pool(CPUs)
        filelist=parmap.starmap(Jofr_infinity_checkpoint, zip(xi_vals,kappainf_vals),r_vals,q,S1,S2,pool=p) 

    J_fvals=[]
    for index, file in enumerate(filelist):
        print "[evolve_J_infinity] Reading:", index, file
        dummy,J_f= np.loadtxt(file,unpack=True)
             
        J_fvals.append(J_f)

    if single_flag==True:    
        return J_fvals[0]
    else:
        return J_fvals


def kappa_backwards(xi,J,r,q,S1,S2):

    '''
    Single integration of the dJ/dL equation to perfom precession-averaged inspiral. Input/output are provided in J and r, but the internal integrator uses kappa and u (see `precession.dkappadu`). Integration is performed using scipy's `odeint`.
    
    This function integrates from some finite separation TO INFINITE separation (u=0) only.    

    The initial binary is specified at the input separation r through J and xi (S not needed).
    The binary is evolved backwards to r=infinity (u=0) and the asymptotic value kappa_inf is returned. If q=1, kappa_inf is degenerate with xi: the constant value of S is returned instead.

    We recommend to use this function through the wrapper `precession.evolve_J_backwards` provided.
 
    **Call:**

        kappa_inf=precession.kappa_backwards(xi,J,r,q,S1,S2)

    **Parameters:**

    - `xi`: projection of the effective spin along the orbital angular momentum.
    - `J`: magnitude of the total angular momentum.
    - `r`: binary separation.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.

    **Returns:**

    - `kappa_inf`: asymptotic value of kappa at large separations.
    '''

    L=(q/(1.+q)**2)*(r*M**3)**.5

    global flags_q1
    if q==1:
        if flags_q1[10]==False:
            print "[kappa_backwards] Warning q=1: sensible output is S, not kappa_inf."
            flags_q1[10]=True # Suppress future warnings
        S=np.sqrt(J**2-L**2-xi*L*M**2)
        return S
    
    else:
        u=1./(2.*L)
        kappa= (J**2 - L**2) / (2.*L)
        u_vals=[u,0.]# Add final condition, r=inifinty u=0
        # Numerical integration to u=0    
        res =integrate.odeint(dkappadu, kappa, u_vals, args=(xi,q,S1,S2), mxstep=50000, full_output=0, printmessg=0)#,tcrit=sing)
        kappa_inf=[x[0] for x in res][-1]
        return kappa_inf


def kappa_backwards_checkpoint(xi,J,r,q,S1,S2):

    '''
    Auxiliary function, see `precession.evolve_J_backwards`.
 
    **Call:**

        savename=precession.kappa_backwards_checkpoint(xi,J,r,q,S1,S2)

    **Parameters:**

    - `xi`: projection of the effective spin along the orbital angular momentum.
    - `J`: magnitude of the total angular momentum.
    - `r`: binary separation.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.

    **Returns:**

    - `savename`: checkpoint filename.
    '''

    os.system("mkdir -p "+storedir) 
    savename= storedir+"/evback"+'_'.join([str(x) for x in (xi,J,r,q,S1,S2)])+".dat"
        
    if not os.path.isfile(savename):
        print "[evolve_J_backwards] Transferring binary. Output:", savename
        outfilesave = open(savename,"w",0)
       
        kappa_inf=kappa_backwards(xi,J,r,q,S1,S2)
        outfilesave.write(str(kappa_inf))
        outfilesave.close()

    #else:
    #    print "[evolve_J_infinity] Skipping. Output:", savename
    
    return savename


def evolve_J_backwards(xi_vals,J_vals,r,q,S1,S2):

    '''
    Wrapper of `precession.kappa_backwards` to enable parallelization through the python `parmap` module; the number of available cores can be specified using the integer global variable `CPUs` (all available cores will be used by default). Evolve a sequence of binaries with the SAME q, S1,S2, from the SAME separation r, but different xi and initial kappa_inf.

    Checkpointing is implemented: results are stored in `precession.storedir`.
 
    **Call:**

        kappainf_vals=precession.evolve_J_backwards(xi_vals,J_vals,r,q,S1,S2)

    **Parameters:**

    - `xi_vals`: projection of the effective spin along the orbital angular momentum (array).
    - `J`: magnitude of the total angular momentum (array).
    - `r`: binary separation.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.

    **Returns:**

    - `kappainf_vals`: asymptotic value of kappa at large separations (array).
    '''



    global CPUs

    flag=False
    try: #Convert float to array, if you're evolving just one binary
        len(xi_vals)
        len(J_vals)
    except:
        xi_vals=[xi_vals]
        J_vals=[J_vals]
        flag=True
    try:
        CPUs
    except:
        CPUs=0
        print "[evolve_J_backwards] Default parallel computation"
    #Parallelization... python is cool indeed
    if CPUs==0: #Run on all cpus on the current machine! (default option)
        filelist=parmap.starmap(kappa_backwards_checkpoint, zip(xi_vals,J_vals),r,q,S1,S2,parallel=True) 
    elif CPUs==1: #1 cpus done by explicitely removing parallelization
        filelist=parmap.starmap(kappa_backwards_checkpoint, zip(xi_vals,J_vals),r,q,S1,S2,parallel=False) 
    else: # Run on a given number of CPUs        
        p = multiprocessing.Pool(CPUs)
        filelist=parmap.starmap(kappa_backwards_checkpoint, zip(xi_vals,J_vals),r,q,S1,S2,pool=p) 

    kappainf_vals=[]
    for index, file in enumerate(filelist):
        print "[evolve_J_backwards] Reading:", index, file
        kappa_inf= np.loadtxt(file,unpack=True)     
        kappainf_vals.append(kappa_inf)
    
    if flag==True:
        return kappainf_vals[0]
    else:
        return kappainf_vals




#################################
#### ORBIT-AVERAGED INSPIRAL ####
#################################


def orbav_eqs(allvars,v,q,S1,S2,eta,m1,m2,chi1,chi2):

    '''
    Right-hand side of the orbit-averaged PN equations: d[allvars]/dv=RHS, where allvars is an array with the cartesian components of the unit vectors L, S1 and S2. This function is only the actual system of equations, not the ODE solver. 
    
    Equations are the ones reported in Gerosa et al. [Phys.Rev. D87 (2013) 10, 104028](http://journals.aps.org/prd/abstract/10.1103/PhysRevD.87.104028); see references therein. In particular, the quadrupole-monopole term computed by Racine is included. The results presented in Gerosa et al. 2013 actually use additional unpublished terms, that are not listed in the published equations and are NOT included here. Radiation reaction is included up to 3.5PN. 
    
    The internal quadrupole_formula flag switches off all PN corrections in radiation reaction. 
    
    The integration is carried over in the orbital velocity v (equivalent to the separation), not in time. If an expression for v(t) is needed, the code can be easiliy modified to return time as well.
 
    **Call:**

        allders=precession.orbav_eqs(allvars,v,q,S1,S2,eta,m1,m2,chi1,chi2)

    **Parameters:**
    - `allvars`: array of lenght 9 cointaining the initial condition for numerical integration for the components of the unit vectors L, S1 and S2.
    - `v`: orbital velocity.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `eta`: symmetric mass ratio.
    - `m1`: mass of the primary BH.
    - `m2`: mass of the secondary BH.
    - `chi1`: dimensionless spin magnitude of the primary BH. Must be 0<chi1<1.
    - `chi2`: dimensionless spin magnitude of the secondary BH. Must be 0<chi1<1.

    **Returns:**

    - `allders`: array of lenght 9 cointaining the derivatives of allvars with respect to the orbital velocity v.
    '''

    # Read variables in
    Lhx=allvars[0]
    Lhy=allvars[1]
    Lhz=allvars[2]
    S1hx=allvars[3]
    S1hy=allvars[4]
    S1hz=allvars[5]
    S2hx=allvars[6]
    S2hy=allvars[7]
    S2hz=allvars[8]
    #t=allvars[9] # Uncomment if v(t) is needed

    # Useful variables
    ct1=(Lhx*S1hx+Lhy*S1hy+Lhz*S1hz)
    ct2=(Lhx*S2hx+Lhy*S2hy+Lhz*S2hz)
    ct12=(S1hx*S2hx+S1hy*S2hy+S1hz*S2hz)

    # Spin precession for S1
    Omega1x= eta*v**5*(2.+3.*q/2.)*Lhx/M  \
            + v**6*(S2*S2hx-3.*S2*ct2*Lhx-3.*q*S1*ct1*Lhx)/(2.*M**3)
    Omega1y= eta*v**5*(2.+3.*q/2.)*Lhy/M  \
            + v**6*(S2*S2hy-3.*S2*ct2*Lhy-3.*q*S1*ct1*Lhy)/(2.*M**3)
    Omega1z= eta*v**5*(2.+3.*q/2.)*Lhz/M  \
            + v**6*(S2*S2hz-3.*S2*ct2*Lhz-3.*q*S1*ct1*Lhz)/(2.*M**3)

    dS1hxdt= Omega1y*S1hz - Omega1z*S1hy
    dS1hydt= Omega1z*S1hx - Omega1x*S1hz
    dS1hzdt= Omega1x*S1hy - Omega1y*S1hx

    # Spin precession for S2
    Omega2x= eta*v**5*(2.+3./(2.*q))*Lhx/M  \
            + v**6*(S1*S1hx-3.*S1*ct1*Lhx-3.*S2*ct2*Lhx/q)/(2.*M**3)
    Omega2y= eta*v**5*(2.+3./(2.*q))*Lhy/M  \
            + v**6*(S1*S1hy-3.*S1*ct1*Lhy-3.*S2*ct2*Lhy/q)/(2.*M**3)
    Omega2z= eta*v**5*(2.+3./(2.*q))*Lhz/M  \
            + v**6*(S1*S1hz-3.*S1*ct1*Lhz-3.*S2*ct2*Lhz/q)/(2.*M**3)

    dS2hxdt= Omega2y*S2hz - Omega2z*S2hy
    dS2hydt= Omega2z*S2hx - Omega2x*S2hz
    dS2hzdt= Omega2x*S2hy - Omega2y*S2hx

    # Conservation of angular momentum
    dLhxdt= -1.*v*(S1*dS1hxdt+S2*dS2hxdt)/(eta*M**2)
    dLhydt= -1.*v*(S1*dS1hydt+S2*dS2hydt)/(eta*M**2)
    dLhzdt= -1.*v*(S1*dS1hzdt+S2*dS2hzdt)/(eta*M**2)

    # Radiation reaction
    quadrupole_formula=False
    if quadrupole_formula:
        dvdt= (32.*eta*v**9/(5.*M))
    else:
        dvdt= (32.*eta*v**9/(5.*M))* ( 1.                               \
            - v**2* (743.+924.*eta)/336.                                \
            + v**3* (4.*np.pi                                           \
                     - chi1*ct1*(113.*m1**2/(12.*M**2) + 25.*eta/4. )   \
                     - chi2*ct2*(113.*m2**2/(12.*M**2) + 25.*eta/4. ))  \
            + v**4* (34103./18144. + 13661.*eta/2016. + 59.*eta**2/18.  \
                     + eta*chi1*chi2* (721.*ct1*ct2 - 247.*ct12) /48.   \
                     + ((m1*chi1/M)**2 * (719.*ct1**2-233.))/96.        \
                     + ((m2*chi2/M)**2 * (719.*ct2**2-233.))/96.)       \
            - v**5* np.pi*(4159.+15876.*eta)/672.                       \
            + v**6* (16447322263./139708800. + 16.*np.pi**2/3.          \
                     -1712.*(0.5772156649+np.log(4.*v))/105.            \
                     +(451.*np.pi**2/48. - 56198689./217728.)*eta       \
                     +541.*eta**2/896. - 5605*eta**3/2592.)             \
            + v**7* np.pi*( -4415./4032. + 358675.*eta/6048.            \
                     + 91495.*eta**2/1512.)                             \
            )

    # Integrate in v, not in time
    dtdv=1./dvdt
    dLhxdv=dLhxdt*dtdv
    dLhydv=dLhydt*dtdv
    dLhzdv=dLhzdt*dtdv
    dS1hxdv=dS1hxdt*dtdv
    dS1hydv=dS1hydt*dtdv
    dS1hzdv=dS1hzdt*dtdv
    dS2hxdv=dS2hxdt*dtdv
    dS2hydv=dS2hydt*dtdv
    dS2hzdv=dS2hzdt*dtdv
    
    # Uncomment if v(t) is needed
    #return dLhxdv, dLhydv, dLhzdv, dS1hxdv, dS1hydv, dS1hzdv, dS2hxdv, dS2hydv, dS2hzdv , dtdv
    
    return dLhxdv, dLhydv, dLhzdv, dS1hxdv, dS1hydv, dS1hzdv, dS2hxdv, dS2hydv, dS2hzdv 


def orbav_integrator(J,xi,S,r_vals,q,S1,S2):
    
    '''
    Single orbit-averaged integration. Integrate the system of ODEs specified in `precession.orbav_eqs`. The initial configuration (at r_vals[0]) is specified through J, xi and S. The components of the unit vectors L, S1 and S2 are returned at the output separations specified by r_vals. The initial values of J and S must be compatible with the initial separation r_vals[0], otherwise an error is raised. Integration is performed in a reference frame in which the z axis is along J and L lies in the x-z plane at the initial separation. Equations are integrated in v (orbital velocity) but outputs are converted to r (separation). 
    
    Of course, this can only integrate to/from FINITE separations. 
    
    Bear in mind that orbit-averaged integrations are tpically possible from r<10000; integrations from larger separations take a very long time and can occasionally crash. If q=1, the initial binary configuration is specified through cos(varphi), not S.
    
    We recommend to use one of the wrappers `precession.orbit_averaged` and `precession.orbit_angles` provided.
 
    **Call:**

        Lhx_fvals,Lhy_fvals,Lhz_fvals,S1hx_fvals,S1hy_fvals,S1hz_fvals,S2hx_fvals,S2hy_fvals,S2hz_fvals=precession.orbav_integrator(J,xi,S,r_vals,q,S1,S2)

    **Parameters:**
    
    - `J`: magnitude of the total angular momentum.
    - `xi`: projection of the effective spin along the orbital angular momentum.
    - `S`: magnitude of the total spin.
    - `r_vals`: binary separation (array).
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.

    **Returns:**

    - `Lhx_vals`: x component of the unit vector L/|L| (array).
    - `Lhy_vals`: y component of the unit vector L/|L| (array).
    - `Lhz_vals`: z component of the unit vector L/|L| (array).
    - `S1hx_vals`: x component of the unit vector S1/|S1| (array).
    - `S1hy_vals`: y component of the unit vector S1/|S1| (array).
    - `S1hz_vals`: z component of the unit vector S1/|S1| (array).
    - `S2hx_vals`: x component of the unit vector S2/|S2| (array).
    - `S2hy_vals`: y component of the unit vector S2/|S2| (array).
    - `S2hz_vals`: z component of the unit vector S2/|S2| (array).   
    '''

    # Get initial condition in a cartesian frame. Use the frame aligned to J at the initial separation
    global flags_q1
    if q==1:
        if flags_q1[11]==False:
            print "[orbav_integrator] Warning q=1: input here is cos(varphi), not S."
            flags_q1[11]=True
    
    L_vals=[(q/(1.+q)**2)*(comp*M**3)**.5 for comp in r_vals]
    v_vals=[(M/comp)**0.5 for comp in r_vals]
    Jvec,Lvec,S1vec,S2vec,dummy=Jframe_projection(xi,S,J,q,S1,S2,r_vals[0])
    
    Lh_initial=[comp/L_vals[0] for comp in Lvec]  
    S1h_initial=[comp/S1 for comp in S1vec]
    S2h_initial=[comp/S2 for comp in S2vec]
    
    #t_initial=0 # Uncomment if v(t) is needed
    allvars_initial=list(Lh_initial)+list(S1h_initial)+list(S2h_initial) #+list([t_initial])

    #Compute these numbers only once
    eta=q/(1.+q)**2 
    m1=M/(1.+q)
    m2=q*M/(1.+q) 
    chi1=S1/m1**2
    chi2=S2/m2**2

    # Actual integration
    res =integrate.odeint(orbav_eqs, allvars_initial, v_vals, args=(q,S1,S2,eta,m1,m2,chi1,chi2), mxstep=5000000, full_output=0, printmessg=0,rtol=1e-12,atol=1e-12)#,tcrit=sing)

    # Unzip output
    traxres=zip(*res)
    Lhx_fvals=traxres[0]
    Lhy_fvals=traxres[1]
    Lhz_fvals=traxres[2]
    S1hx_fvals=traxres[3]
    S1hy_fvals=traxres[4]
    S1hz_fvals=traxres[5]
    S2hx_fvals=traxres[6]
    S2hy_fvals=traxres[7]
    S2hz_fvals=traxres[8]
    #t_fvals=traxres[9] # Uncomment if v(t) is needed
    
    return Lhx_fvals,Lhy_fvals,Lhz_fvals,S1hx_fvals,S1hy_fvals,S1hz_fvals,S2hx_fvals,S2hy_fvals,S2hz_fvals


def orbav_integrator_checkpoint(J,xi,S,r_vals,q,S1,S2):

    '''
    Auxiliary function, see `precession.orbit_averaged` and `precession.orbit_angles`.
 
    **Call:**

        savename=precession.orbav_integrator_checkpoint(J,xi,S,r_vals,q,S1,S2)

    **Parameters:**

    - `J`: magnitude of the total angular momentum.
    - `xi`: projection of the effective spin along the orbital angular momentum.
    - `S`: magnitude of the total spin.
    - `r_vals`: binary separation (array).
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.

    **Returns:**

    - `savename`: checkpoint filename.
    '''
    
    os.system("mkdir -p "+storedir) 
    savename= storedir+"/orbav_"+'_'.join([str(x) for x in (J,xi,S,max(r_vals),min(r_vals),len(r_vals),q,S1,S2)])+".dat"

    if not os.path.isfile(savename):
        print "[orbit_averaged] Transferring binary. Output:", savename
        outfilesave = open(savename,"w",0)
       
        Lhx_fvals,Lhy_fvals,Lhz_fvals,S1hx_fvals,S1hy_fvals,S1hz_fvals,S2hx_fvals,S2hy_fvals,S2hz_fvals = orbav_integrator(J,xi,S,r_vals,q,S1,S2)

        for r_f,Lhx,Lhy,Lhz,S1hx,S1hy,S1hz,S2hx,S2hy,S2hz in zip(r_vals,Lhx_fvals,Lhy_fvals,Lhz_fvals,S1hx_fvals,S1hy_fvals,S1hz_fvals,S2hx_fvals,S2hy_fvals,S2hz_fvals):        
            
            L_f=(q/(1.+q)**2)*(r_f*M**3)**.5
            J_f= ((L_f*Lhx+S1*S1hx+S2*S2hx)**2 + (L_f*Lhy+S1*S1hy+S2*S2hy)**2 + (L_f*Lhz+S1*S1hz+S2*S2hz)**2 )**0.5 
            xi_f= ((1.+q)*S1*(Lhx*S1hx+Lhy*S1hy+Lhz*S1hz)+(1.+q**-1)*S2*(Lhx*S2hx+Lhy*S2hy+Lhz*S2hz))*M**-2
            S_f= ((S1*S1hx+S2*S2hx)**2 + (S1*S1hy+S2*S2hy)**2 + (S1*S1hz+S2*S2hz)**2 )**0.5
            
            if q==1:
                A1=np.sqrt(J_f**2-(L_f-S_f)**2)
                A2=np.sqrt((L_f+S_f)**2-J_f**2)
                A3=np.sqrt(S_f**2-(S1-S2)**2)
                A4=np.sqrt((S1+S2)**2-S_f**2) 
                cosvarphi = (4*J_f*S_f**2*S1hz*S1-(S_f**2+S1**2-S2**2)*(J_f**2-L_f**2+S_f**2))/(A1*A2*A3*A4)
                S_f=cosvarphi
                
            outfilesave.write(str(r_f)+" "+str(J_f)+" "+str(xi_f)+" "+str(S_f)+"\n")
        outfilesave.close()

    #else:
    #    print "[evolve_J_infinity] Skipping. Output:", savename
    
    return savename


def orbit_averaged(J_vals,xi_vals,S_vals,r_vals,q,S1,S2):

    '''
    Wrapper of `precession.orbav_integrator` to enable parallelization through the python parmap module; the number of available cores can be specified using the integer global variable `CPUs` (all available cores will be used by default). Input/outputs are given in terms of J, xi and S. Evolve a sequence of binaries with the SAME q, S1,S2 but different xi and initial values of J and S; save outputs at r_vals. The initial configuration must be compatible with r_vals[0]. Output is a 2D array, where e.g. J_vals[0] is the first binary (1D array at all output separations) and J_vals[0][0] is the first binary at the first output separation (this is a scalar).

    Checkpointing is implemented: results are stored in `precession.storedir`.
 
    **Call:**

        Jf_vals,xif_vals,Sf_vals=precession.orbit_averaged(J_vals,xi_vals,S_vals,r_vals,q,S1,S2)

    **Parameters:**

    - `Ji_vals`: initial condition for J (array).
    - `xii_vals`: initial condition for xi (array).
    - `Si_vals`: initial condition for S (array).
    - `r_vals`: binary separation (array).
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.

    **Returns:**

    - `Jf_vals`: solutions for J (2D array).
    - `xif_vals`: solutions for xi (2D array).
    - `Sf_vals`: solutions for S (2D array).
    '''
    
    global CPUs
    
    global flags_q1 
    if q==1:
        if flags_q1[12]==False:
            print "[orbit_averaged] Warning q=1: Input/output for S is actually cos(varphi)"       
            flags_q1[12]=True

    single_flag=False
    try: #Convert float to array if you're evolving just one binary
        len(J_vals)
        len(xi_vals)
        len(S_vals)
    except:
        J_vals=[J_vals]
        xi_vals=[xi_vals]
        S_vals=[S_vals]
        single_flag=True
    try: # Set default
        CPUs
    except:
        CPUs=0
        print "[orbit_averaged] Default parallel computation"
    
    # Parallelization
    if CPUs==0: # Run on all cpus on the current machine! (default option)
        filelist=parmap.starmap(orbav_integrator_checkpoint, zip(J_vals,xi_vals,S_vals),r_vals,q,S1,S2,parallel=True) 
    elif CPUs==1: # 1 cpus done by explicitely removing parallelization
        filelist=parmap.starmap(orbav_integrator_checkpoint, zip(J_vals,xi_vals,S_vals),r_vals,q,S1,S2,parallel=False) 
    else: # Run on a given number of CPUs        
        p = multiprocessing.Pool(CPUs)
        filelist=parmap.starmap(orbav_integrator_checkpoint, zip(J_vals,xi_vals,S_vals),r_vals,q,S1,S2,pool=p) 

    J_fvals=[]
    S_fvals=[]
    xi_vals=[]
    for index, file in enumerate(filelist):
        print "[orbit_averaged] Reading:", index, file
        dummy,J_f,xi_f,S_f= np.loadtxt(file,unpack=True)
        J_fvals.append(J_f)
        S_fvals.append(S_f)
        xi_vals.append(xi_f)

    if single_flag==True:
        return J_fvals[0], xi_vals[0], S_fvals[0]
    else:
        return J_fvals, xi_vals, S_fvals


def orbit_angles_single(theta1_i,theta2_i,deltaphi_i,r_vals,q,S1,S2):

    '''
    Auxiliary function, see `orbit_angles`.
 
    **Call:**

        savename=precession.orbit_angles_single(theta1_i,theta2_i,deltaphi_i,r_vals,q,S1,S2)

    **Parameters:**
    
    - `theta1_i`: initial condition for theta1.
    - `theta2_i`: initial condition for theta2
    - `deltaphi_i`: initial condition for deltaphi.
    - `r_vals`: binary separation (array).
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.

    **Returns:**

    - `savename`: checkpoint filename.
    '''

    os.system("mkdir -p "+storedir) 
    savename= storedir+"/orbang_"+'_'.join([str(x) for x in (theta1_i,theta2_i,deltaphi_i,max(r_vals),min(r_vals),len(r_vals),q,S1,S2)])+".dat"
        
    if not os.path.isfile(savename):
        print "[orbit_angles] Transferring binary. Output:", savename
        outfilesave = open(savename,"w",0)
       
        # Step 1. Get xi and J for each intial angle. Keep S now
        xi_i,J_i,S_i= from_the_angles(theta1_i,theta2_i,deltaphi_i,q,S1,S2,r_vals[0]) 
        # Note that S_i is actually cos(varphi_i) when q=1. 
        
        # Step 2. Evolve ODE system
        Lhx_fvals,Lhy_fvals,Lhz_fvals,S1hx_fvals,S1hy_fvals,S1hz_fvals,S2hx_fvals,S2hy_fvals,S2hz_fvals = orbav_integrator(J_i,xi_i,S_i,r_vals,q,S1,S2)
        
        for r_f,Lhx,Lhy,Lhz,S1hx,S1hy,S1hz,S2hx,S2hy,S2hz in zip(r_vals,Lhx_fvals,Lhy_fvals,Lhz_fvals,S1hx_fvals,S1hy_fvals,S1hz_fvals,S2hx_fvals,S2hy_fvals,S2hz_fvals):        
            
            L_f=(q/(1.+q)**2)*(r_f*M**3)**.5
            S_f= ((S1*S1hx+S2*S2hx)**2 + (S1*S1hy+S2*S2hy)**2 + (S1*S1hz+S2*S2hz)**2 )**0.5
            J_f= ((L_f*Lhx+S1*S1hx+S2*S2hx)**2 + (L_f*Lhy+S1*S1hy+S2*S2hy)**2 + (L_f*Lhz+S1*S1hz+S2*S2hz)**2 )**0.5 
            xi_f= ((1.+q)*S1*(Lhx*S1hx+Lhy*S1hy+Lhz*S1hz)+(1.+q**-1)*S2*(Lhx*S2hx+Lhy*S2hy+Lhz*S2hz))*M**-2
            if q==1:
                A1=np.sqrt(J_f**2-(L_f-S_f)**2)
                A2=np.sqrt((L_f+S_f)**2-J_f**2)
                A3=np.sqrt(S_f**2-(S1-S2)**2)
                A4=np.sqrt((S1+S2)**2-S_f**2)  
                cosvarphi = (4*J_f*S_f**2*S1hz*S1-(S_f**2+S1**2-S2**2)*(J_f**2-L_f**2+S_f**2))/(A1*A2*A3*A4)
                S_f=cosvarphi

            # Step 3. Back to theta1, theta2, deltaphi
            theta1_f,theta2_f,deltaphi_f,dummy= parametric_angles(S_f,J_f,xi_f,q,S1,S2,r_f)
            
            # Step 4. Track the precessional phase to set the sign of DeltaPhi. In symbols, the sign of DeltaPhi must be the sign of
            #L dot [ ( S1 - (S1 dot L) dot L ) cross ( S2 - (S2 dot L) dot L ) ]
            S1px=(S1hx-theta1_f*Lhx)
            S1py=(S1hy-theta1_f*Lhy)
            S1pz=(S1hz-theta1_f*Lhz)
            S2px=(S2hx-theta2_f*Lhx)
            S2py=(S2hy-theta2_f*Lhy)
            S2pz=(S2hz-theta2_f*Lhz)
            proj=Lhx*(S1py*S2pz-S1pz*S2py) + Lhy*(S1pz*S2px-S1px*S2pz) + Lhz*(S1px*S2py-S1py*S2px)
            deltaphi_f*=math.copysign(1., proj)

            # Step 4. Store data            
            outfilesave.write(str(r_f)+" "+str(theta1_f)+" "+str(theta2_f)+" "+str(deltaphi_f)+"\n")
        outfilesave.close()

    #else:
    #    print "[evolve_angles] Skipping. Output:", savename
    
    return savename


def orbit_angles(theta1_vals,theta2_vals,deltaphi_vals,r_vals,q,S1,S2):

    '''
    Wrapper of `precession.orbav_integrator` to enable parallelization through the python parmap module; the number of available cores can be specified using the integer global variable `CPUs` (all available cores will be used by default). Input/outputs are given in terms of the angles theta1, theta2 and deltaphi. Evolve a sequence of binaries with the SAME q, S1,S2 but different initial values for the angles; save outputs at r_vals. Output is a 2D array, where e.g. theta1_vals[0] is the first binary (1D array at all output separations) and theta1_vals[0][0] is the first binary at the first output separation (this is a scalar).
    
    Checkpointing is implemented: results are stored in `precession.storedir`.
 
    **Call:**

        theta1f_vals,theta2f_vals,deltaphif_vals=precession.orbit_angles(theta1i_vals,theta2i_vals,deltaphii_vals,r_vals,q,S1,S2)
         
    **Parameters:**
    
    - `theta1i_vals`: initial condition for theta1 (array).
    - `theta2i_vals`: initial condition for theta2 (array).
    - `deltaphii_vals`: initial condition for deltaphi (array).
    - `r_vals`: binary separation (array).
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.

    **Returns:**

    - `theta1f_vals`: solutions for theta1 (2D array).
    - `theta2f_vals`: solutions for theta2 (2D array).
    - `deltaphif_vals`: solutions for deltaphi (2D array).
    '''

    global CPUs
    flag=False

    try: #Convert float to array, if you're evolving just one binary
        len(theta1_vals)
        len(theta1_vals)
        len(deltaphi_vals)
    except:
        flag=True
        theta1_vals=[theta1_vals]
        theta2_vals=[theta2_vals]
        deltaphi_vals=[deltaphi_vals]

    try:
        CPUs
    except:
        CPUs=0
        print "[orbit_angles] Default parallel computation"

    loopflag=True
    while loopflag: # Restart is some of the cores crashed. This happend if you run too many things on too many different machines. Nevermind, trash the file and do it again.
        loopflag=False

        #Parallelization... python is cool indeed
        if CPUs==0: #Run on all cpus on the current machine! (default option)
            filelist=parmap.starmap(orbit_angles_single, zip(theta1_vals,theta2_vals,deltaphi_vals),r_vals,q,S1,S2,parallel=True) 
        elif CPUs==1: #1 cpus done by explicitely removing parallelization
            filelist=parmap.starmap(orbit_angles_single, zip(theta1_vals,theta2_vals,deltaphi_vals),r_vals,q,S1,S2,parallel=False) 
        else: # Run on a given number of CPUs        
            p = multiprocessing.Pool(CPUs)
            filelist=parmap.starmap(orbit_angles_single, zip(theta1_vals,theta2_vals,deltaphi_vals),r_vals,q,S1,S2,pool=p) 

        theta1_fvals=[]
        theta2_fvals=[]
        deltaphi_fvals=[]
        for index, file in enumerate(filelist):
            print "[orbit_angles] Reading:", index, file
            numlines=sum(1 for line in open(file))
            if numlines!=0 and numlines!=len(r_vals): # Restar if core(s) crashed
                print "[orbit_angles] Error on file", file,". Jobs are being restarting!!!"
                os.system("rm "+file) 
                loopflag=True
 
            else:
                dummy,theta1_f,theta2_f,deltaphi_f= np.loadtxt(file,unpack=True)
                theta1_fvals.append(theta1_f)
                theta2_fvals.append(theta2_f)
                deltaphi_fvals.append(deltaphi_f)        
    if flag==True:
        return theta1_fvals[0], theta2_fvals[0], deltaphi_fvals[0]
    else:
        return theta1_fvals, theta2_fvals, deltaphi_fvals


def hybrid_single(xi,kappa_inf,r_vals,q,S1,S2,r_t):
    
    '''
    Auxiliary function, see `hybrid`.
 
    **Call:**

        savename=precession.hybrid_single(xi,kappa_inf,r_vals,q,S1,S2,r_t)

    **Parameters:**
    
    - `xi`: projection of the effective spin along the orbital angular momentum.
    - `kappa_inf`: asymtotic value of kappa at large separations.
    - `r_vals`: binary separation (array).
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `r_transition`: transition radius between orbit- and precession-averaged approach.

    **Returns:**

    - `savename`: checkpoint filename.
    '''

    os.system("mkdir -p "+storedir) 
    savename= storedir+"/hybrid_"+'_'.join([str(x) for x in (xi,kappa_inf,max(r_vals),min(r_vals),len(r_vals),q,S1,S2,r_t)])+".dat"

    if not os.path.isfile(savename):
        print "[hybrid] Transferring binary. Output:", savename
        outfilesave = open(savename,"w",0)

        # Split the output separations: precession-average before r_t and orbit-average after it         
        r_vals_pa=[r for r in r_vals if r>r_t]
        r_vals_oa=[r for r in r_vals if r<=r_t] # Keep r_t (if present) in the orbit-average part

        if not [r for r in r_vals_oa if r==r_t]: # If there's nothing but r_t in the orbit-averaged part
            print "[hybrid] No output required below r_t. You don't need a hybrid integration, use evolve_J_infinity instead"
            sys.exit()

        # Add the threshold at the end of the precession-average part and at the beginning of the orbit-average part
        r_vals_pa.append(r_t)
        r_vals_oa.insert(0,r_t)  

        # Evolve from r=infinity to r=r_t using precession-averaged integration
        J_vals_pa=Jofr_infinity(xi,kappa_inf,r_vals_pa,q,S1,S2)

        # Store the angles theta1, theta2 and deltaphi (need S resampling at each output separation)
        # Don't use the latest values in the arrays, because you added one value at the end earlier on
        for J_f,r_f in zip(J_vals_pa[:-1],r_vals_pa[:-1]):           
          
            S_f=samplingS(xi,J_f,q,S1,S2,r_f)
            theta1_f,theta2_f,deltaphi_f,dummy = parametric_angles(S_f,J_f,xi,q,S1,S2,r_f)
            deltaphi_f*=random.choice([-1., 1.])
            outfilesave.write(str(r_f)+" "+str(theta1_f)+" "+str(theta2_f)+" "+str(deltaphi_f)+"\n")        

        # Last S resampling at r=r_t
        S_t=samplingS(xi,J_vals_pa[-1],q,S1,S2,r_t)
        
        # Evolve from r_t to min(r_vals) using orbit-average integration
        Lhx_vals_oa,Lhy_vals_oa,Lhz_vals_oa,S1hx_vals_oa,S1hy_vals_oa,S1hz_vals_oa,S2hx_vals_oa,S2hy_vals_oa,S2hz_vals_oa = orbav_integrator(J_vals_pa[-1],xi,S_t,r_vals_oa,q,S1,S2)

        # Store the angles theta1, theta2 and deltaphi (S resampling not needed)
        # Don't use the first values in the arrays, because you added one value at on top earlier on
        for r_f,Lhx,Lhy,Lhz,S1hx,S1hy,S1hz,S2hx,S2hy,S2hz in zip(r_vals_oa[1:],Lhx_vals_oa[1:],Lhy_vals_oa[1:],Lhz_vals_oa[1:],S1hx_vals_oa[1:],S1hy_vals_oa[1:],S1hz_vals_oa[1:],S2hx_vals_oa[1:],S2hy_vals_oa[1:],S2hz_vals_oa[1:]):
            L_f=(q/(1.+q)**2)*(r_f*M**3)**.5
            S_f=((S1*S1hx+S2*S2hx)**2 + (S1*S1hy+S2*S2hy)**2 + (S1*S1hz+S2*S2hz)**2 )**0.5
            J_f=((L_f*Lhx+S1*S1hx+S2*S2hx)**2 + (L_f*Lhy+S1*S1hy+S2*S2hy)**2 + (L_f*Lhz+S1*S1hz+S2*S2hz)**2 )**0.5
            xi_f=((1.+q)*S1*(Lhx*S1hx+Lhy*S1hy+Lhz*S1hz)+(1.+q**-1)*S2*(Lhx*S2hx+Lhy*S2hy+Lhz*S2hz))*M**-2
            if q==1: # You need to compute varphi, not S
                A1=np.sqrt(J_f**2-(L_f-S_f)**2)
                A2=np.sqrt((L_f+S_f)**2-J_f**2)
                A3=np.sqrt(S_f**2-(S1-S2)**2)
                A4=np.sqrt((S1+S2)**2-S_f**2)  
                cosvarphi=(4*J_f*S_f**2*S1hz*S1-(S_f**2+S1**2-S2**2)*(J_f**2-L_f**2+S_f**2))/(A1*A2*A3*A4)
                S_f=cosvarphi 
            
            theta1_f,theta2_f,deltaphi_f,dummy= parametric_angles(S_f,J_f,xi_f,q,S1,S2,r_f)
            # Track the precessional phase to set the sign of DeltaPhi. In symbols, the sign of DeltaPhi must be the sign of
            #L dot [ ( S1 - (S1 dot L) dot L ) cross ( S2 - (S2 dot L) dot L ) ]
            S1px=(S1hx-theta1_f*Lhx)
            S1py=(S1hy-theta1_f*Lhy)
            S1pz=(S1hz-theta1_f*Lhz)
            S2px=(S2hx-theta2_f*Lhx)
            S2py=(S2hy-theta2_f*Lhy)
            S2pz=(S2hz-theta2_f*Lhz)
            proj=Lhx*(S1py*S2pz-S1pz*S2py) + Lhy*(S1pz*S2px-S1px*S2pz) + Lhz*(S1px*S2py-S1py*S2px)
            deltaphi_f*=math.copysign(1., proj)
            
            outfilesave.write(str(r_f)+" "+str(theta1_f)+" "+str(theta2_f)+" "+str(deltaphi_f)+"\n")
        outfilesave.close()
        
    return savename

def hybrid(xi_vals,kappainf_vals,r_vals,q,S1,S2,r_t):
 
    '''
    Hybrid inspiral. Evolve a binary FROM INIFINITELY large separations (as specified by kappa_inf and xi) till the threshold r_transition using the precession-averaged approach, and then from r_transition to the end of the inspiral using an orbit-averaged integration to track the precessional phase. 
    
    Parallelization is implemented through the python parmap module; the number of available cores can be specified using the integer global variable `CPUs` (all available cores will be used by default). Evolve a sequence of binaries with the SAME q, S1,S2 but different xi and kappa_inf; save outputs at r_vals. 
    
    The initial condition is NOT returned by this function. Outputs are given in terms of the angles theta1, theta2 and deltaphi as 2D arrays, where e.g theta1_fvals[0] is the first binary (1D array at all output separations) and theta1_fvals[0][0] is the first binary at the first output separation (this is a scalar).
 
    **Call:**

        theta1f_vals,theta2f_vals,deltaphif_vals=precession.hybrid(xi_vals,kappainf_vals,r_vals,q,S1,S2,r_t)

    **Parameters:**
    
    - `xi_vals`: projection of the effective spin along the orbital angular momentum (array).
    - `kappainf_vals`: asymtotic value of kappa at large separations (array).
    - `r_vals`: binary separation (array).
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `r_transition`: transition radius between orbit- and precession-averaged approach.

    **Returns:**

    - `theta1f_vals`: solutions for theta1 (2D array).
    - `theta2f_vals`: solutions for theta2 (2D array).
    - `deltaphif_vals`: solutions for deltaphi (2D array).
    '''



    global CPUs
    global flags_q1
    if q==1:
        if flags_q1[13]==False:
            print "[hybrid] Warning q=1: required intial condition is S, not kappa_inf."
            flags_q1[13]=True # Suppress future warnings

    single_flag=False

    try: #Convert float to array if you're evolving just one binary 
        len(xi_vals)
        len(kappainf_vals)
    except:
        single_flag=True
        xi_vals=[xi_vals]
        kappainf_vals=[kappainf_vals]

    try: # Set defaults
        CPUs
    except:
        CPUs=0
        print "[hybrid] Default parallel computation"

    loopflag=True
    while loopflag: # Restart is some of the cores crashed. This happend if you run too many things on too many different machines. Nevermind, trash the file and do it again. 
        loopflag=False 

        #Parallelization
        if CPUs==0: #Run on all cpus on the current machine! (default option) 
            filelist=parmap.starmap(hybrid_single, zip(xi_vals,kappainf_vals),r_vals,q,S1,S2,r_t,parallel=True)
        elif CPUs==1: #1 cpus done by explicitely removing parallelization 
            filelist=parmap.starmap(hybrid_single, zip(xi_vals,kappainf_vals),r_vals,q,S1,S2,r_t,parallel=False)
        else: # Run on a given number of CPUs
            p = multiprocessing.Pool(CPUs)
            filelist=parmap.starmap(hybrid_single, zip(xi_vals,kappainf_vals),r_vals,q,S1,S2,r_t,pool=p)

        theta1_fvals=[]
        theta2_fvals=[]
        deltaphi_fvals=[]
        for index, file in enumerate(filelist):
            print "[hybrid] Reading:", index, file
            numlines=sum(1 for line in open(file))
            if numlines!=0 and numlines!=len(r_vals): # Restart if core(s) crashed 
                print "[hybrid] Error on file", file,". Jobs are being restarted!"
                os.system("rm "+file)
                loopflag=True

            else:
                dummy,theta1_f,theta2_f,deltaphi_f= np.loadtxt(file,unpack=True)
                theta1_fvals.append(theta1_f)
                theta2_fvals.append(theta2_f)
                deltaphi_fvals.append(deltaphi_f)
    if single_flag==True:
        return theta1_fvals[0], theta2_fvals[0], deltaphi_fvals[0]
    else:
        return theta1_fvals, theta2_fvals, deltaphi_fvals




#################################
########## UTILITIES ############
#################################


def ftor(f,M_msun):
    
    '''
    Conversion between binary separation r (in mass unit) and emitted GW
    frequency f (in Hertz). We use the Newtonian expression:
    f^2 = G M / (pi^2 r^3) in cgs units. Mass units: r--> GMr/c^2
 
    **Call:**

        r=precession.ftor(f,M_msun)

    **Parameters:**
    
    - `f`: emitted GW frequency in Hertz.
    - `M_msun`: binary total mass in solar masses.

    **Returns:**

    - `r`: binary separation.
    '''

 
    
    M_cgs=M_msun*(2e33)
    c_cgs=2.99e10
    G_cgs=6.67e-8
    r=pow(pow(c_cgs,3.),2./3.)*pow(math.pi*f*G_cgs*M_cgs,-2./3.)
    return r


def rtof(r,M_msun):

    '''
    Conversion between emitted GW frequency f (in Hertz) and binary
    separation r (in mass unit). We use the Newtonian expression:
    f^2 = G M / (pi^2 r^3) in cgs units. Mass units: r--> GMr/c^2
 
    **Call:**

        f=precession.rtof(r,M_msun)

    **Parameters:**
    
    - `r`: binary separation.
    - `M_msun`: binary total mass in solar masses.

    **Returns:**
    
    - `f`: emitted GW frequency in Hertz.
    '''

    M_cgs=M_msun*(2e33)
    c_cgs=2.99e10
    G_cgs=6.67e-8
    f=pow(c_cgs,3.)/(math.pi*G_cgs*M_cgs*pow(r,3./2.))
    return f
    
    
def cutoff(detector,M_msun):

    '''
    Return the GW frequency and binary separation (in total-mass units) when
    binary enter the sensitivity window of a typical ground-based LIGO-like
    detector or a LISA-like space mission.
 
    **Call:**

        r,f=precession.cutoff(detector,M_msun)
    
    **Parameters:**
    
    - `detector`: specify either *space* or *ground*.
    - `M_msun`: binary total mass in solar masses.

    **Returns:**
    
    - `r`: binary separation.
    - `f`: emitted GW frequency in Hertz.
    '''

    if detector=="ground":
        fcut=10 # Hz
    elif detector=="space":
        fcut= 1e-5 # Hz
    else:
        print "[cutoff] Please select 'space' or 'ground'. Otherwise run ftor with the chosen frequency"
        sys.exit()
    rcut=ftor(fcut,M_msun)

    return rcut, fcut
        
        


</code></pre>
  </div>

  </header>

  <section id="section-items">
    <h2 class="section-title" id="header-variables">Module variables</h2>
      <div class="item">
      <p id="precession.M" class="name">var <span class="ident">M</span></p>
      
  
    <div class="desc"><p>The total mass is just a free scale, and we set it to 1. Please, don't change this, because I never checked that the various M factors are all right.</p></div>
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="precession.flags_q1" class="name">var <span class="ident">flags_q1</span></p>
      
  
    <div class="desc"><p>Global flags to reduce warnings in the equal-mass limit q=1.</p></div>
  <div class="source_cont">
</div>

      </div>
      <div class="item">
      <p id="precession.storedir" class="name">var <span class="ident">storedir</span></p>
      
  
    <div class="desc"><p>Directory path to store checkpoints. Deafult is <code>./precession_checkpoints</code>.</p></div>
  <div class="source_cont">
</div>

      </div>

    <h2 class="section-title" id="header-functions">Functions</h2>
      
  <div class="item">
    <div class="name def" id="precession.J_allowed">
    <p>def <span class="ident">J_allowed</span>(</p><p>xi, q, S1, S2, r)</p>
    </div>
    

    
  
    <div class="desc"><p>Find allowed values of J for fixed xi, i.e the spin-orbit resonances. See <a href="#precession.resonant_finder"><code>resonant_finder</code></a>.</p>
<p><strong>Call:</strong></p>
<pre><code>J_low,J_up=precession.J_allowed(xi,q,S1,S2,r)
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>r</code>: binary separation.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>J_low</code>: minimum allowed value of J, given the input parameters.</li>
<li><code>J_up</code>: maximum allowed value of J, given the input parameters.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.J_allowed', this);">Show source &equiv;</a></p>
  <div id="source-precession.J_allowed" class="source">
    <pre><code>def J_allowed(xi,q,S1,S2,r):

    '''
    Find allowed values of J for fixed xi, i.e the spin-orbit resonances. See `precession.resonant_finder`.

    **Call:**

        J_low,J_up=precession.J_allowed(xi,q,S1,S2,r)
    
    **Parameters:**

    - `xi`: projection of the effective spin along the orbital angular momentum.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `r`: binary separation.

    **Returns:**

    - `J_low`: minimum allowed value of J, given the input parameters.
    - `J_up`: maximum allowed value of J, given the input parameters.
    '''
    
    J_dp0, dummy, dummy, dummy, J_dp180, dummy, dummy, dummy = resonant_finder(xi,q,S1,S2,r, more=True)
    return min(J_dp0,J_dp180),max(J_dp0,J_dp180)
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.J_lim">
    <p>def <span class="ident">J_lim</span>(</p><p>q, S1, S2, r, verbose=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Compute the limits on the magnitude of the total angular momentum J, defined as J=|L+S1+S2|.    </p>
<p><strong>Call:</strong></p>
<pre><code>Jmin,Jmax=precession.J_lim(q,S1,S2,r, verbose=False)
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>r</code>: binary separation.</li>
<li><code>verbose</code>: if <code>True</code> print additional information.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>Jmin</code>: minimum value of J from geometrical constraints.</li>
<li><code>Jmax</code>: maximum value of J from geometrical constraints.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.J_lim', this);">Show source &equiv;</a></p>
  <div id="source-precession.J_lim" class="source">
    <pre><code>def J_lim(q,S1,S2,r, verbose=False):
    
    '''
    Compute the limits on the magnitude of the total angular momentum J, defined as J=|L+S1+S2|.    

    **Call:**

        Jmin,Jmax=precession.J_lim(q,S1,S2,r, verbose=False)
    
    **Parameters:**
 
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `r`: binary separation.
    - `verbose`: if `True` print additional information.

    **Returns:**
    
    - `Jmin`: minimum value of J from geometrical constraints.
    - `Jmax`: maximum value of J from geometrical constraints.
    '''

    L=(q/(1.+q)**2)*(r*M**3)**.5    
    Jmin=max(1e-20,L-S1-S2,S1-L-S2,S2-S1-L)
    Jmax=L+S1+S2
    
    if verbose:
        print "[J_lim] L=",L, " S1=",S1," S2=",S2
        print "[J_lim] Jmin=",Jmin, " Jmax=",Jmax
        if Jmin==1e-20:
            print "[J_lim] Jmin=0, Jmax=L+S1+S2"
        elif Jmin==L-S1-S2:
            print "[J_lim] Jmin=L-S1-S2, Jmax=L+S1+S2"
        if Jmin==S1-L-S2:
            print "[J_lim] Jmin=S1-L-S2, Jmax=L+S1+S2"
        if Jmin==S2-L-S1:
            print "[J_lim] Jmin=S2-L-S1, Jmax=L+S1+S2"
            
    return Jmin,Jmax    
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.Jframe_projection">
    <p>def <span class="ident">Jframe_projection</span>(</p><p>xi, S, J, q, S1, S2, r)</p>
    </div>
    

    
  
    <div class="desc"><p>Project the three momenta on the reference frame aligned with the total angular momentum J. The z axis points in the J direction, and the x axis lies in the plane spanned by J and L. The y axis complete an orthonormal triad. Note that this is not an inertial frame (not even on the precession time) because it precesses together with L.</p>
<p><strong>Call:</strong></p>
<pre><code>Jvec,Lvec,S1vec,S2vec,Svec=precession.Jframe_projection(xi,S,J,q,S1,S2,r)
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>S</code>: magnitude of the total spin.</li>
<li><code>J</code>: magnitude of the total angular momentum.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>r</code>: binary separation.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>Jvec</code>: components of J in a reference frame (3 values for x,y,z).</li>
<li><code>Lvec</code>: components of L in a reference frame (3 values for x,y,z).</li>
<li><code>S1vec</code>: components of S1 in a reference frame (3 values for x,y,z).</li>
<li><code>S2vec</code>: components of S2 in a reference frame (3 values for x,y,z).</li>
<li><code>Svec</code>: components of S in a reference frame (3 values for x,y,z).</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.Jframe_projection', this);">Show source &equiv;</a></p>
  <div id="source-precession.Jframe_projection" class="source">
    <pre><code>def Jframe_projection(xi,S,J,q,S1,S2,r):    

    '''
    Project the three momenta on the reference frame aligned with the total angular momentum J. The z axis points in the J direction, and the x axis lies in the plane spanned by J and L. The y axis complete an orthonormal triad. Note that this is not an inertial frame (not even on the precession time) because it precesses together with L.

    **Call:**

        Jvec,Lvec,S1vec,S2vec,Svec=precession.Jframe_projection(xi,S,J,q,S1,S2,r)
    
    **Parameters:**

    - `xi`: projection of the effective spin along the orbital angular momentum.
    - `S`: magnitude of the total spin.
    - `J`: magnitude of the total angular momentum.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `r`: binary separation.

    **Returns:**

    - `Jvec`: components of J in a reference frame (3 values for x,y,z).
    - `Lvec`: components of L in a reference frame (3 values for x,y,z).
    - `S1vec`: components of S1 in a reference frame (3 values for x,y,z).
    - `S2vec`: components of S2 in a reference frame (3 values for x,y,z).
    - `Svec`: components of S in a reference frame (3 values for x,y,z).
    '''
    
    global flags_q1
    L=(q/(1.+q)**2)*(r*M**3)**.5
    
    if q==1:
        if flags_q1[2]==False:
            print "[Jframe_projection] Warning q=1: input here is cos(varphi), not S."
            flags_q1[2]=True
        varphi=np.arccos(S)
        S=np.sqrt(J**2-L**2-xi*L*M**2)
    else:
        varphi=get_varphi(xi,S,J,q,S1,S2,r,sign=1)
        
    Jx = 0.
    Jy = 0.
    Jz = J # Definition!
    
    Lx = ( (((L+S)**2-J**2)**.5) * ((J**2-(L-S)**2)**.5) ) / (2.*J)
    Ly = 0. # Definition!
    Lz = (J**2+L**2-S**2) / (2.*J)
    
    S1x = (1./(4.*J*S**2))* \
          ( -1.*(S**2+S1**2-S2**2) * (((L+S)**2-J**2)**.5) * ((J**2-(L-S)**2)**.5) \
          + (J**2-L**2+S**2) * (((S1+S2)**2-S**2)**.5) * ((S**2-(S1-S2)**2)**.5) * np.cos(varphi) )
    S1y = (1./(2.*S))* \
          (((S1+S2)**2-S**2)**.5) * ((S**2-(S1-S2)**2)**.5)  * np.sin(varphi)
    S1z = (1./(4.*J*S**2))* \
          ( (S**2+S1**2-S2**2) * (J**2-L**2+S**2) \
          + (((L+S)**2-J**2)**.5) * ((J**2-(L-S)**2)**.5) *(((S1+S2)**2-S**2)**.5) * ((S**2-(S1-S2)**2)**.5) *np.cos(varphi) )

    S2x = (-1./(4.*J*S**2))* \
          ( (S**2+S2**2-S1**2) * (((L+S)**2-J**2)**.5) * ((J**2-(L-S)**2)**.5) \
          + (J**2-L**2+S**2) * (((S1+S2)**2-S**2)**.5) * ((S**2-(S1-S2)**2)**.5) * np.cos(varphi) )
    S2y = (-1./(2.*S))* \
          (((S1+S2)**2-S**2)**.5) * ((S**2-(S1-S2)**2)**.5)  * np.sin(varphi)
    S2z = (1./(4.*J*S**2))* \
          ( (S**2+S2**2-S1**2) * (J**2-L**2+S**2) \
          - (((L+S)**2-J**2)**.5) * ((J**2-(L-S)**2)**.5) *(((S1+S2)**2-S**2)**.5) * ((S**2-(S1-S2)**2)**.5) *np.cos(varphi) )    

    Jvec=np.array([Jx,Jy,Jz])
    Lvec=np.array([Lx,Ly,Lz])
    S1vec=np.array([S1x,S1y,S1z])
    S2vec=np.array([S2x,S2y,S2z])
    Svec= S1vec+S2vec

    if False: #Sanity check. These sets of numbers should really be the same
        print "[Jframe_projection] Check varphi", np.cos(varphi), np.sin(varphi)
        print "[Jframe_projection] Check J norm", np.linalg.norm(Jvec), J
        print "[Jframe_projection] Check norm", np.linalg.norm(Lvec), L
        print "[Jframe_projection] Check norm", np.linalg.norm(S1vec), S1
        print "[Jframe_projection] Check norm", np.linalg.norm(S2vec), S2
        print "[Jframe_projection] Check norm", np.linalg.norm(Svec), S

    return Jvec,Lvec,S1vec,S2vec,Svec
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.Jofr">
    <p>def <span class="ident">Jofr</span>(</p><p>xi, J_initial, r_vals, q, S1, S2)</p>
    </div>
    

    
  
    <div class="desc"><p>Single integration of the dJ/dL equation to perfom precession-averaged inspiral. Input/output are provided in J and r, but the internal integrator uses kappa and u (see <a href="#precession.dkappadu"><code>dkappadu</code></a>). Integration is performed using scipy's <code>odeint</code>.</p>
<p>This function integrates to/from FINITE separations only.</p>
<p>It takes the desired output separations r_vals, and the intial condition for the total angular momentum J_initial. The latter must be consistent with the initial separation (i.e. r_vals[0]) and the value of xi; an error is raised in case of inconsistencies. It doesn't matter if you integrate from large to small separations of the other way round, as long as J_initial is consistent with r_vals[0]. It returns a vector with the values of J at each input separation, the first item being just the initial condition.</p>
<p>We recommend to use this function through the wrapper <a href="#precession.evolve_J"><code>evolve_J</code></a> provided.</p>
<p><strong>Call:</strong></p>
<pre><code>J_vals=precession.Jofr(xi,J_initial,r_vals,q,S1,S2)
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>J_initial</code>: initial condition for numerical integration.</li>
<li><code>r_vals</code>: binary separation (array).</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>J_vals</code>: magnitude of the total angular momentum (array).</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.Jofr', this);">Show source &equiv;</a></p>
  <div id="source-precession.Jofr" class="source">
    <pre><code>def Jofr(xi,J_initial,r_vals,q,S1,S2):

    '''
    Single integration of the dJ/dL equation to perfom precession-averaged inspiral. Input/output are provided in J and r, but the internal integrator uses kappa and u (see `precession.dkappadu`). Integration is performed using scipy's `odeint`.
    
    This function integrates to/from FINITE separations only.
    
    It takes the desired output separations r_vals, and the intial condition for the total angular momentum J_initial. The latter must be consistent with the initial separation (i.e. r_vals[0]) and the value of xi; an error is raised in case of inconsistencies. It doesn't matter if you integrate from large to small separations of the other way round, as long as J_initial is consistent with r_vals[0]. It returns a vector with the values of J at each input separation, the first item being just the initial condition.
    
    We recommend to use this function through the wrapper `precession.evolve_J` provided.

    **Call:**

        J_vals=precession.Jofr(xi,J_initial,r_vals,q,S1,S2)
    
    **Parameters:**

    - `xi`: projection of the effective spin along the orbital angular momentum.
    - `J_initial`: initial condition for numerical integration.
    - `r_vals`: binary separation (array).
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.

    **Returns:**

    - `J_vals`: magnitude of the total angular momentum (array).
    '''

    L_vals=[ (q/(1.+q)**2)*(r*M**3)**.5 for r in r_vals]
    kappa_initial= (J_initial**2 - (L_vals[0])**2) / (2.*L_vals[0])
    u_vals=[ 1./(2.*L) for L in L_vals]

    # Analytical solution for q=1. S is constant on the radiation-reaction time
    if q==1:
        L_initial=L_vals[0]
        Ssq=J_initial**2-L_initial**2-xi*L_initial*M**2
        J_vals=[np.sqrt(Ssq+((q/(1.+q)**2)*(r*M**3)**.5)**2+xi*M**2*((q/(1.+q)**2)*(r*M**3)**.5)) for r in r_vals]
    
    # Numerical integration
    else:
        #sing = [ M*((1.+q)**2*(S1+S2)/(q*M**2))**2 ,  M*((1.+q)**2*(S1-S2)/(q*M**2))**2 ] # Expected singularities. Not needed
        # Increase h0 to prevent occasional slowing down of the integration
        res =integrate.odeint(dkappadu, kappa_initial, u_vals, args=(xi,q,S1,S2), mxstep=50000, full_output=0, printmessg=0)#,h0=0.001)#,tcrit=sing)
        kappa_vals=[x[0] for x in res]
        J_vals= [ (k*2.*L + L**2)**0.5 for k,L in zip(kappa_vals,L_vals)]
    return J_vals
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.Jofr_checkpoint">
    <p>def <span class="ident">Jofr_checkpoint</span>(</p><p>xi, J_initial, r_vals, q, S1, S2)</p>
    </div>
    

    
  
    <div class="desc"><p>Auxiliary function, see <a href="#precession.evolve_J"><code>evolve_J</code></a>.</p>
<p><strong>Call:</strong></p>
<pre><code>savename=precession.Jofr_checkpoint(xi,J_initial,r_vals,q,S1,S2)
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>J_initial</code>: initial condition for numerical integration.</li>
<li><code>r_vals</code>: binary separation (array).</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>savename</code>: checkpoint filename.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.Jofr_checkpoint', this);">Show source &equiv;</a></p>
  <div id="source-precession.Jofr_checkpoint" class="source">
    <pre><code>def Jofr_checkpoint(xi,J_initial,r_vals,q,S1,S2):

    '''
    Auxiliary function, see `precession.evolve_J`.

    **Call:**

        savename=precession.Jofr_checkpoint(xi,J_initial,r_vals,q,S1,S2)
    
    **Parameters:**

    - `xi`: projection of the effective spin along the orbital angular momentum.
    - `J_initial`: initial condition for numerical integration.
    - `r_vals`: binary separation (array).
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.

    **Returns:**

    - `savename`: checkpoint filename.
    '''
    
    os.system("mkdir -p "+storedir) 
    savename= storedir+"/evJ_"+'_'.join([str(x) for x in (xi,J_initial,max(r_vals),min(r_vals),len(r_vals),q,S1,S2)])+".dat"
        
    if not os.path.isfile(savename):
        print "[evolve_J] Transferring binary. Output:", savename
        outfilesave = open(savename,"w",0)
       
        J_vals= Jofr(xi,J_initial,r_vals,q,S1,S2)

        for J_f,r_f in zip(J_vals,r_vals):        
            outfilesave.write(str(r_f)+" "+str(J_f)+"\n")
        outfilesave.close()

    #else:
    #    print "[evolve_J] Skipping. Output:", savename
    
    return savename
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.Jofr_infinity">
    <p>def <span class="ident">Jofr_infinity</span>(</p><p>xi, kappa_inf, r_vals, q, S1, S2)</p>
    </div>
    

    
  
    <div class="desc"><p>Single integration of the dJ/dL equation to perfom precession-averaged inspiral. Input/output are provided in J and r, but the internal integrator uses kappa and u (see <a href="#precession.dkappadu"><code>dkappadu</code></a>). Integration is performed using scipy's <code>odeint</code>.</p>
<p>This function integrates FROM INFINITE separation (u=0) only.    </p>
<p>The latter must be consistent with <a href="#precession.kappainf_lim"><code>kappainf_lim</code></a>; an error is raised in case of inconsistencies. It assume that the array r_vals is sorted in reversed order, i.e. that you are integrating from large to small separations. It returns a vector with the values of J at each input separation. The initial condition is NOT returned by this function (unlike the <a href="#precession.Jofr"><code>Jofr</code></a> for integrations to/from finite separations). If q=1, kappa_inf is degenerate with xi: the required initial condition is assumed to be S (which is constant).</p>
<p>We recommend to use this function through the wrapper <a href="#precession.evolve_J_infinity"><code>evolve_J_infinity</code></a> provided.</p>
<p><strong>Call:</strong></p>
<pre><code>J_vals=precession.Jofr_infinity(xi,kappa_inf,r_vals,q,S1,S2)
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>kappa_inf</code>: asymptotic value of kappa at large separations.</li>
<li><code>r_vals</code>: binary separation (array).</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>J_vals</code>: magnitude of the total angular momentum (array).</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.Jofr_infinity', this);">Show source &equiv;</a></p>
  <div id="source-precession.Jofr_infinity" class="source">
    <pre><code>def Jofr_infinity(xi,kappa_inf,r_vals,q,S1,S2): 

    '''
    Single integration of the dJ/dL equation to perfom precession-averaged inspiral. Input/output are provided in J and r, but the internal integrator uses kappa and u (see `precession.dkappadu`). Integration is performed using scipy's `odeint`.
    
    This function integrates FROM INFINITE separation (u=0) only.    
    
    The latter must be consistent with `precession.kappainf_lim`; an error is raised in case of inconsistencies. It assume that the array r_vals is sorted in reversed order, i.e. that you are integrating from large to small separations. It returns a vector with the values of J at each input separation. The initial condition is NOT returned by this function (unlike the `precession.Jofr` for integrations to/from finite separations). If q=1, kappa_inf is degenerate with xi: the required initial condition is assumed to be S (which is constant).

    We recommend to use this function through the wrapper `precession.evolve_J_infinity` provided.
 
    **Call:**

        J_vals=precession.Jofr_infinity(xi,kappa_inf,r_vals,q,S1,S2)

    **Parameters:**

    - `xi`: projection of the effective spin along the orbital angular momentum.
    - `kappa_inf`: asymptotic value of kappa at large separations.
    - `r_vals`: binary separation (array).
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.

    **Returns:**

    - `J_vals`: magnitude of the total angular momentum (array).
    '''

    # ASSUMES r_vals is sorted in reversed order!!!
    L_vals=[ (q/(1.+q)**2)*(r*M**3)**.5 for r in r_vals]

    global flags_q1 
    if q==1:
        if flags_q1[9]==False:
            print "[Jofr_infinity] Warning q=1: required intial condition is S, not kappa_inf."
            flags_q1[9]=True # Suppress future warnings
        S=kappa_inf
        J_vals=[np.sqrt(L**2+S**2+xi*L*M**2) for L in L_vals]
    else:
        u_vals=[ 1./(2.*L) for L in L_vals]
        u_vals.insert(0, 0.) # Add initial condition, r=inifinty u=0
    
        # Numerical integration from u=0   
        # Increase h0 to prevent occasional slowing down of the integration
        res =integrate.odeint(dkappadu, kappa_inf, u_vals, args=(xi,q,S1,S2), mxstep=50000, full_output=0, printmessg=0,h0=2e-4)

        kappa_vals=[x[0] for x in res][1:] # Remove initial condition (not present in r_vals...)
        J_vals= [ (k*2.*L + L**2)**0.5 for k,L in zip(kappa_vals,L_vals)]
    
    return J_vals
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.Jofr_infinity_checkpoint">
    <p>def <span class="ident">Jofr_infinity_checkpoint</span>(</p><p>xi, kappa_inf, r_vals, q, S1, S2)</p>
    </div>
    

    
  
    <div class="desc"><p>Auxiliary function, see <a href="#precession.evolve_J_infinity"><code>evolve_J_infinity</code></a>.</p>
<p><strong>Call:</strong></p>
<pre><code>savename=precession.Jofr_infinity_checkpoint(xi,kappa_inf,r_vals,q,S1,S2)
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>kappa_inf</code>: asymptotic value of kappa at large separations.</li>
<li><code>r_vals</code>: binary separation (array).</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>savename</code>: checkpoint filename.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.Jofr_infinity_checkpoint', this);">Show source &equiv;</a></p>
  <div id="source-precession.Jofr_infinity_checkpoint" class="source">
    <pre><code>def Jofr_infinity_checkpoint(xi,kappa_inf,r_vals,q,S1,S2):
    
    '''
    Auxiliary function, see `precession.evolve_J_infinity`.
 
    **Call:**

        savename=precession.Jofr_infinity_checkpoint(xi,kappa_inf,r_vals,q,S1,S2)

    **Parameters:**

    - `xi`: projection of the effective spin along the orbital angular momentum.
    - `kappa_inf`: asymptotic value of kappa at large separations.
    - `r_vals`: binary separation (array).
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.

    **Returns:**

    - `savename`: checkpoint filename.
    '''
    
    os.system("mkdir -p "+storedir) 
    savename= storedir+"/evJinf_"+'_'.join([str(x) for x in (xi,kappa_inf,max(r_vals),min(r_vals),len(r_vals),q,S1,S2)])+".dat"
        
    if not os.path.isfile(savename):
        print "[evolve_J_infinity] Transferring binary. Output:", savename
        outfilesave = open(savename,"w",0)
       
        J_vals= Jofr_infinity(xi,kappa_inf,r_vals,q,S1,S2)

        for J_f,r_f in zip(J_vals,r_vals):        
            outfilesave.write(str(r_f)+" "+str(J_f)+"\n")
        outfilesave.close()

    #else:
    #    print "[evolve_J_infinity] Skipping. Output:", savename
    
    return savename
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.Omegaz">
    <p>def <span class="ident">Omegaz</span>(</p><p>S, xi, J, q, S1, S2, r)</p>
    </div>
    

    
  
    <div class="desc"><p>Compute the (azimuthal) precessional frequency of the orbital angular momentum L about the total angular momentum J.</p>
<p><strong>Call:</strong></p>
<pre><code>Omega=precession.Omegaz(S,xi,J,q,S1,S2,r)
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>S</code>: magnitude of the total spin.</li>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>J</code>: magnitude of the total angular momentum.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>r</code>: binary separation.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>Omega</code>: precessional frequency of L about J.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.Omegaz', this);">Show source &equiv;</a></p>
  <div id="source-precession.Omegaz" class="source">
    <pre><code>def Omegaz(S,xi,J,q,S1,S2,r):

    '''
    Compute the (azimuthal) precessional frequency of the orbital angular momentum L about the total angular momentum J.

    **Call:**

        Omega=precession.Omegaz(S,xi,J,q,S1,S2,r)
    
    **Parameters:**
    
    - `S`: magnitude of the total spin.
    - `xi`: projection of the effective spin along the orbital angular momentum.
    - `J`: magnitude of the total angular momentum.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `r`: binary separation.

    **Returns:**

    - `Omega`: precessional frequency of L about J.
    '''

    L=(q/(1.+q)**2)*(r*M**3)**.5
    eta=q/(1.+q)**2
    t1=(J/2.)*((eta**2*M**3/L**2)**3)
    t2=(3./(2.*eta))*(1.-(eta*M**2*xi/L))
    t3=(3.*(1.+q)/(2.*q*(J**2-(L-S)**2)*((L+S)**2-J**2)))*(1.-(eta*M**2*xi/L))
    t4=4.*(1.-q)*L**2*(S1**2-S2**2)
    t5=(1.+q)*(J**2-L**2-S**2)*(J**2-L**2-S**2-4.*eta*M**2*L*xi)
    
    return t1*(1.+t2-t3*(t4-t5))
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.OmegazdtdS">
    <p>def <span class="ident">OmegazdtdS</span>(</p><p>S, xi, J, q, S1, S2, r, sign=1.0)</p>
    </div>
    

    
  
    <div class="desc"><p>Auxiliary function Omega_z * dt/dS. See <a href="#precession.Omegaz"><code>Omegaz</code></a> and <a href="#precession.dSdt"><code>dSdt</code></a>.</p>
<p><strong>Call:</strong></p>
<pre><code>OmegadtdS=precession.OmegazdtdS(S,xi,J,q,S1,S2,r,sign=1.):
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>S</code>: magnitude of the total spin.</li>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>J</code>: magnitude of the total angular momentum.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>r</code>: binary separation.</li>
<li><code>sign</code>: if 1 return angle in [0,pi], if -1 return angle in [-pi,0].</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>OmegadtdS</code>: Omega_z * dt/dS.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.OmegazdtdS', this);">Show source &equiv;</a></p>
  <div id="source-precession.OmegazdtdS" class="source">
    <pre><code>def OmegazdtdS(S,xi,J,q,S1,S2,r,sign=1.):
    
    '''
    Auxiliary function Omega_z * dt/dS. See `precession.Omegaz` and `precession.dSdt`.

    **Call:**

        OmegadtdS=precession.OmegazdtdS(S,xi,J,q,S1,S2,r,sign=1.):
    
    **Parameters:**
    
    - `S`: magnitude of the total spin.
    - `xi`: projection of the effective spin along the orbital angular momentum.
    - `J`: magnitude of the total angular momentum.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `r`: binary separation.
    - `sign`: if 1 return angle in [0,pi], if -1 return angle in [-pi,0].

    **Returns:**

    - `OmegadtdS`: Omega_z * dt/dS.
    '''

    global flags_q1
    if q==1:
        if flags_q1[5]==False:
            print "[OmegazdtdS] Warning q=1: input here is cos(varphi), not S; now computing Omegaz * dt / d(cos(varphi))"
            flags_q1[5]=True
        cosvarphi=S # The input variable is actually cos(varphi)
        L=(q/(1.+q)**2)*(r*M**3)**.5
        S=np.sqrt(J**2-L**2-xi*L*M**2)
        return Omegaz(S,xi,J,q,S1,S2,r)/np.abs(dSdt(cosvarphi,xi,J,q,S1,S2,r,sign))
    
    else:
        return Omegaz(S,xi,J,q,S1,S2,r)/np.abs(dSdt(S,xi,J,q,S1,S2,r,sign)) 
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.S3sines_comp">
    <p>def <span class="ident">S3sines_comp</span>(</p><p>S, xi, kappa, q, S1, S2, u)</p>
    </div>
    

    
  
    <div class="desc"><p>Auxiliary function, see <a href="#precession.dkappadu"><code>dkappadu</code></a>.</p>
<p><strong>Call:</strong></p>
<pre><code>denominator=precession.S3sines_comp(S,xi,kappa,q,S1,S2,u)
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>S</code>: magnitude of the total spin.</li>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>kappa</code>: rescaling of the total angular momentum to compactify the inspiral domain.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>u</code>: rescaling of the orbital angular momentum to compactify the inspiral domain.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>denominator</code>: denominator in integrand <code>precession.dkappapu</code>.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.S3sines_comp', this);">Show source &equiv;</a></p>
  <div id="source-precession.S3sines_comp" class="source">
    <pre><code>def S3sines_comp(S,xi,kappa,q,S1,S2,u):

    '''
    Auxiliary function, see `precession.dkappadu`.
        
    **Call:**

        denominator=precession.S3sines_comp(S,xi,kappa,q,S1,S2,u)

    **Parameters:**
    
    - `S`: magnitude of the total spin.
    - `xi`: projection of the effective spin along the orbital angular momentum.
    - `kappa`: rescaling of the total angular momentum to compactify the inspiral domain.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `u`: rescaling of the orbital angular momentum to compactify the inspiral domain.

    **Returns:**

    - `denominator`: denominator in integrand `precession.dkappapu`.
    '''

    ct1= ( kappa - u*S**2  - q*M**2*xi/(1.+q) )/((1.-q)*S1)
    ct2= q*( -kappa + u*S**2  + M**2*xi/(1.+q) )/((1.-q)*S2)
    ct12=(S**2-S1**2-S2**2)/(2.*S1*S2)
    t3=max( (np.abs(1.-ct1**2-ct2**2-ct12**2 +2.*ct1*ct2*ct12))**.5, 1e-20) # I know abs is dirty, but does the job 
    if t3==0: # prevent occasional crash
        t3=1e-20
    return S**3/t3
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.Sb_limits">
    <p>def <span class="ident">Sb_limits</span>(</p><p>xi, J, q, S1, S2, r)</p>
    </div>
    

    
  
    <div class="desc"><p>Compute the <em>bounded</em> limits on S, using xi as a constant of motion. The routine first guesses where the extrema are expected to be, then brakets the solution, and finally runs root finder. In some cases the braketing may fail: this typically happens if the two roots are very close (DeltaS&lt;1e-8) and cannot be distinguished numerically. In this case, assume Sb_min=Sb_max.</p>
<p>WARNING: This function is critical. It is well tested, but is tricky numerical issues may still be present.</p>
<p><strong>Call:</strong></p>
<pre><code>Sb_min,Sb_max=precession.Sb_limits(xi,J,q,S1,S2,r)
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>J</code>: magnitude of the total angular momentum.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>r</code>: binary separation.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>Sb_min</code>: minimum value of S from geometrical constraints. This is S- in our papers.</li>
<li><code>Sb_max</code>: maximum value of S from geometrical constraints. This is S+ in our papers.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.Sb_limits', this);">Show source &equiv;</a></p>
  <div id="source-precession.Sb_limits" class="source">
    <pre><code>def Sb_limits(xi,J,q,S1,S2,r):
    
    '''
    Compute the *bounded* limits on S, using xi as a constant of motion. The routine first guesses where the extrema are expected to be, then brakets the solution, and finally runs root finder. In some cases the braketing may fail: this typically happens if the two roots are very close (DeltaS<1e-8) and cannot be distinguished numerically. In this case, assume Sb_min=Sb_max.

    WARNING: This function is critical. It is well tested, but is tricky numerical issues may still be present.

    **Call:**

        Sb_min,Sb_max=precession.Sb_limits(xi,J,q,S1,S2,r)

    **Parameters:**
    
    - `xi`: projection of the effective spin along the orbital angular momentum.
    - `J`: magnitude of the total angular momentum.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `r`: binary separation.

    **Returns:**

    - `Sb_min`: minimum value of S from geometrical constraints. This is S- in our papers.
    - `Sb_max`: maximum value of S from geometrical constraints. This is S+ in our papers.   
    '''
 
    St_min,St_max=St_limits(J,q,S1,S2,r)
    if St_max<St_min:
        print "[Sb_limits] Problem in the absolute limits at r="+str(r)+". Assume Sb_min=Sb_max=mean(St_min,St_max)"        
        return np.mean([St_min,St_max]), np.mean([St_min,St_max])

    if q==1: # if q=1 the effective potential loop shrinks to a lime (Sb_min=Sb_max) and the equations xi_/pm(S)=xi can be solved analytically.
        L=(q/(1.+q)**2)*(r*M**3)**.5
        Sb_both=np.sqrt(J**2-L**2-xi*L*M**2)
        return Sb_both,Sb_both

    # Remember: xi_minus=xi_plus at St_min and St_max
    xi_low=xi_minus(St_min,J,q,S1,S2,r) 
    xi_up=xi_minus(St_max,J,q,S1,S2,r)
 
    #Debug option: print the parameter-space region of the initial guess
    whereareyou=False
 
    # Both roots on xi_plus. Split the interval first
    if xi > xi_low and xi > xi_up:    
        if whereareyou:
            print "[Sb_limits] Both roots on xi_plus"
        
        resmax= sp.optimize.fminbound(lambda S: -1.*xi_plus(S,J,q,S1,S2,r), St_min, St_max,full_output=1)
        S_up=resmax[0]
        xi_max=-1.*resmax[1]
        
        if xi_max<xi: #Braket failed!
            print "[Sb_limits] Braket failed on xi_plus at r="+str(r)+". Assume Sb_min=Sb_max"
            #print  xi_plus(S_up,J,q,S1,S2,r), xi
            Sb_min=S_up
            Sb_max=S_up  
        else: #Braket succeeded!
            Sb_min= sp.optimize.brentq(lambda S: xi_plus(S,J,q,S1,S2,r)-xi, St_min, S_up)
            Sb_max= sp.optimize.brentq(lambda S: xi_plus(S,J,q,S1,S2,r)-xi, S_up, St_max)

    # Both roots on xi_minus. Split the interval first
    elif xi < xi_low and xi < xi_up:    
        if whereareyou:
            print "[Sb_limits] Both roots on xi_minus"
            
        resmin= sp.optimize.fminbound(lambda S: xi_minus(S,J,q,S1,S2,r), St_min, St_max,full_output=1)
        S_low=resmin[0]
        xi_min=resmin[1]
                 
        if xi_min>xi: #Braket failed! 
            print "[Sb_limits] Braket failed on xi_minus at r="+str(r)+". Assume Sb_min=Sb_max"
            Sb_min=S_low
            Sb_max=S_low  
        else: #Braket succeeded!
            Sb_min= sp.optimize.brentq(lambda S: xi_minus(S,J,q,S1,S2,r)-xi, St_min, S_low)
            Sb_max= sp.optimize.brentq(lambda S: xi_minus(S,J,q,S1,S2,r)-xi, S_low, St_max)

    # One root on xi_plus and the other one on xi_plus. No additional maximization is neeeded
    elif xi >= xi_low and xi <= xi_up:    
        if whereareyou:
            print "[Sb_limits] Sb_min on xi_plus, Sb_max on xi_minus"

        Sb_min= sp.optimize.brentq(lambda S: xi_plus(S,J,q,S1,S2,r)-xi, St_min, St_max)
        Sb_max= sp.optimize.brentq(lambda S: xi_minus(S,J,q,S1,S2,r)-xi, St_min, St_max)
    
    elif xi <= xi_low and xi >= xi_up:    
        if whereareyou:
            print "[Sb_limits] Sb_min on xi_minus, Sb_max on xi_plus"

        Sb_min= sp.optimize.brentq(lambda S: xi_minus(S,J,q,S1,S2,r)-xi, St_min, St_max)
        Sb_max= sp.optimize.brentq(lambda S: xi_plus(S,J,q,S1,S2,r)-xi, St_min, St_max)
                    
    else:
        print "[Sb_limits] Erorr in case selection"
        print "xi=", xi
        print "xi(Stmin)=", xi_low
        print "xi(Stmax)=", xi_up
        print "Stmin=", St_min
        print "Stmax", St_max
        print "J=", J
        print "L=", (q/(1.+q)**2)*(r*M**3)**.5
        print "r=", r
        sys.exit()

    btol=1e-8 # Never go to close to the actual limits, because of numerical stabilty
    Sb_min+=btol
    Sb_max-=btol

    if whereareyou:
        print "[Sb_limits] Results:", Sb_min,Sb_max
    
    if Sb_min>Sb_max: # This may happen (numerically) if they're too close to each other. Assume they're the same.
        return np.mean([Sb_min,Sb_max]), np.mean([Sb_min,Sb_max])
    else: 
        return Sb_min, Sb_max
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.Sb_limits_comp">
    <p>def <span class="ident">Sb_limits_comp</span>(</p><p>xi, kappa, q, S1, S2, u)</p>
    </div>
    

    
  
    <div class="desc"><p>Auxiliary function, see <a href="#precession.Sb_limits"><code>Sb_limits</code></a>.</p>
<p><strong>Call:</strong></p>
<pre><code>Sb_min,Sb_max=precession.Sb_limits_comp(xi,kappa,q,S1,S2,u)
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>kappa</code>: rescaling of the total angular momentum to compactify the inspiral domain.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>u</code>: rescaling of the orbital angular momentum to compactify the inspiral domain.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>Sb_min</code>: minimum value of S from geometrical constraints. This is S- in our papers.</li>
<li><code>Sb_max</code>: maximum value of S from geometrical constraints. This is S+ in our papers.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.Sb_limits_comp', this);">Show source &equiv;</a></p>
  <div id="source-precession.Sb_limits_comp" class="source">
    <pre><code>def Sb_limits_comp(xi,kappa,q,S1,S2,u):

    '''
    Auxiliary function, see `precession.Sb_limits`.
        
    **Call:**

        Sb_min,Sb_max=precession.Sb_limits_comp(xi,kappa,q,S1,S2,u)

    **Parameters:**
    
    - `xi`: projection of the effective spin along the orbital angular momentum.
    - `kappa`: rescaling of the total angular momentum to compactify the inspiral domain.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `u`: rescaling of the orbital angular momentum to compactify the inspiral domain.

    **Returns:**

    - `Sb_min`: minimum value of S from geometrical constraints. This is S- in our papers.
    - `Sb_max`: maximum value of S from geometrical constraints. This is S+ in our papers.   
    '''

    global flags_q1
    if q==1:
        if u==0:
            if flags_q1[8]==False:
                print "[Sb_limits_comp] Warning q=1,u=0: input for kappa means S"
                flags_q1[8]=True
            Sb_both=kappa
        else:
           Sb_both=np.sqrt(kappa/u-0.5*xi*M**2/u)
        return Sb_both,Sb_both

    St_min,St_max=St_limits_comp(kappa,q,S1,S2,u)
    xi_low=xi_minus_comp(St_min,kappa,q,S1,S2,u) 
    xi_up=xi_minus_comp(St_max,kappa,q,S1,S2,u)
 
    #Debug option: print the parameter-space region of the initial guess
    whereareyou=False
 
    # Both roots on xi_plus. Split the interval first
    if xi > xi_low and xi > xi_up:    

        if whereareyou:
            print "[Sb_limits_comp] Both roots on xi_plus"

        resmax= sp.optimize.fminbound(lambda S: -1.*xi_plus_comp(S,kappa,q,S1,S2,u), St_min, St_max,full_output=1)
        S_up=resmax[0]
        xi_max=-1.*resmax[1]
        if xi_max<xi: #Braket failed!
            print "[Sb_limits_comp] Braket failed on xi_plus at u="+str(u)+". Assume Sb_min=Sb_max"
            #print  xi_plus(S_up,J,q,S1,S2,r), xi
            Sb_min=S_up
            Sb_max=S_up  
        else: #Braket succeeded!
                    
            Sb_min= sp.optimize.brentq(lambda S: xi_plus_comp(S,kappa,q,S1,S2,u)-xi, St_min, S_up)
            Sb_max= sp.optimize.brentq(lambda S: xi_plus_comp(S,kappa,q,S1,S2,u)-xi, S_up, St_max)

    # Both roots on xi_minus. Split the interval first
    elif xi < xi_low and xi < xi_up:    
        
        if whereareyou:
            print "[Sb_limits_comp] Both roots on xi_minus"
            
        resmin= sp.optimize.fminbound(lambda S: xi_minus_comp(S,kappa,q,S1,S2,u), St_min, St_max,full_output=1)
        S_low=resmin[0]
        xi_min=resmin[1]
                 
        if xi_min>xi: #Braket failed! 
            print "[Sb_limits_comp] Braket failed on xi_minus at u="+str(u)+". Assume Sb_min=Sb_max"
            Sb_min=S_low
            Sb_max=S_low  
        else: #Braket succeeded!
            Sb_min= sp.optimize.brentq(lambda S: xi_minus_comp(S,kappa,q,S1,S2,u)-xi, St_min, S_low)
            Sb_max= sp.optimize.brentq(lambda S: xi_minus_comp(S,kappa,q,S1,S2,u)-xi, S_low, St_max)

    # One root on xi_plus and the other one on xi_plus. No additional maximization is neeeded
    elif xi >= xi_low and xi <= xi_up:    

        if whereareyou:
            print "[Sb_limits_comp] Sb_min on xi_plus, Sb_max on xi_minus"

        Sb_min= sp.optimize.brentq(lambda S: xi_plus_comp(S,kappa,q,S1,S2,u)-xi, St_min, St_max)
        Sb_max= sp.optimize.brentq(lambda S: xi_minus_comp(S,kappa,q,S1,S2,u)-xi, St_min, St_max)
    elif xi <= xi_low and xi >= xi_up:    
    
        if whereareyou:
            print "[Sb_limits_comp] Sb_min on xi_minus, Sb_max on xi_plus"

        Sb_min= sp.optimize.brentq(lambda S: xi_minus_comp(S,kappa,q,S1,S2,u)-xi, St_min, St_max)
        Sb_max= sp.optimize.brentq(lambda S: xi_plus_comp(S,kappa,q,S1,S2,u)-xi, St_min, St_max)
                    
    else:
        print "[Sb_limits_comp] Erorr in case selection"
        print "xi=", xi
        print "xi(stmin)=", xi_low
        print "xi(stmax)=", xi_up
        print "Stmin=", St_min
        print "Stmax", St_max
        print "kappa=", kappa
        print "u=", u
        sys.exit()

    btol=1e-8 # Never go to close to the actual limits, because everything blows up there
    Sb_min+=btol
    Sb_max-=btol
    
    if whereareyou:
        print "[Sb_limits_comp] Results:", Sb_min,Sb_max
    
    
    if Sb_min>Sb_max: # This may happen (numerically) if they're too close to each other. Assume they're the same.
        return np.mean([Sb_min,Sb_max]), np.mean([Sb_min,Sb_max])
    else: 
        return Sb_min, Sb_max
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.Ssines_comp">
    <p>def <span class="ident">Ssines_comp</span>(</p><p>S, xi, kappa, q, S1, S2, u)</p>
    </div>
    

    
  
    <div class="desc"><p>Auxiliary function, see <a href="#precession.dkappadu"><code>dkappadu</code></a>.</p>
<p><strong>Call:</strong></p>
<pre><code>numerator=precession.Ssines_comp(S,xi,kappa,q,S1,S2,u)
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>S</code>: magnitude of the total spin.</li>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>kappa</code>: rescaling of the total angular momentum to compactify the inspiral domain.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>u</code>: rescaling of the orbital angular momentum to compactify the inspiral domain.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>numerator</code>: numerator in integrand <code>precession.dkappapu</code>.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.Ssines_comp', this);">Show source &equiv;</a></p>
  <div id="source-precession.Ssines_comp" class="source">
    <pre><code>def Ssines_comp(S,xi,kappa,q,S1,S2,u):
    
    '''
    Auxiliary function, see `precession.dkappadu`.

    **Call:**

        numerator=precession.Ssines_comp(S,xi,kappa,q,S1,S2,u)

    **Parameters:**
    
    - `S`: magnitude of the total spin.
    - `xi`: projection of the effective spin along the orbital angular momentum.
    - `kappa`: rescaling of the total angular momentum to compactify the inspiral domain.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `u`: rescaling of the orbital angular momentum to compactify the inspiral domain.

    **Returns:**

    - `numerator`: numerator in integrand `precession.dkappapu`.
    '''
    
    ct1= ( kappa - u*S**2  - q*M**2*xi/(1.+q) )/((1.-q)*S1)
    ct2= q*( -kappa + u*S**2  + M**2*xi/(1.+q) )/((1.-q)*S2)
    ct12=(S**2-S1**2-S2**2)/(2.*S1*S2)
    t3=max( (np.abs(1.-ct1**2-ct2**2-ct12**2 +2.*ct1*ct2*ct12))**.5, 1e-20) # I know abs is dirty, but does the job 
    return S/t3
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.Sso_limits">
    <p>def <span class="ident">Sso_limits</span>(</p><p>S1, S2)</p>
    </div>
    

    
  
    <div class="desc"><p>Compute the <em>spin-only</em> limits on the magnitude of the total spin S, considering the single constraint S=S1+S2.  This is needed e.g. to provide initial condition to
precession-averaged integration from infinity in the q=1 limit.</p>
<p><strong>Call:</strong></p>
<pre><code>Sso_min,Sso_max=precession.Sso_limits(S1,S2)
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>Sso_min</code>: minimum value of S from the spin constraint only.</li>
<li><code>Sso_max</code>: maximum value of S from the spin constraint only.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.Sso_limits', this);">Show source &equiv;</a></p>
  <div id="source-precession.Sso_limits" class="source">
    <pre><code>def Sso_limits(S1,S2):
    
    '''
    Compute the *spin-only* limits on the magnitude of the total spin S, considering the single constraint S=S1+S2.  This is needed e.g. to provide initial condition to
    precession-averaged integration from infinity in the q=1 limit.

    **Call:**

        Sso_min,Sso_max=precession.Sso_limits(S1,S2)

    **Parameters:**
    
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.

    **Returns:**
    
    - `Sso_min`: minimum value of S from the spin constraint only.
    - `Sso_max`: maximum value of S from the spin constraint only.
    '''
    
    return np.abs(S1-S2), S1+S2
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.St_limits">
    <p>def <span class="ident">St_limits</span>(</p><p>J, q, S1, S2, r, verbose=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Compute the <em>total</em> limits on the magnitude of the total spin S. S has to satisfy both S=S1+S2 and S=J-L.</p>
<p><strong>Call:</strong></p>
<pre><code>St_min,St_max=precession.St_limits(J,q,S1,S2,r,verbose=False)
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>J</code>: magnitude of the total angular momentum.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>r</code>: binary separation.</li>
<li><code>verbose</code>: if <code>True</code> print additional information.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>St_min</code>: minimum value of S from geometrical constraints. This is S_min in our papers.</li>
<li><code>St_max</code>: maximum value of S from geometrical constraints. This is S_max in our papers.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.St_limits', this);">Show source &equiv;</a></p>
  <div id="source-precession.St_limits" class="source">
    <pre><code>def St_limits(J,q,S1,S2,r,verbose=False):
     
    '''
    Compute the *total* limits on the magnitude of the total spin S. S has to satisfy both S=S1+S2 and S=J-L.

    **Call:**

        St_min,St_max=precession.St_limits(J,q,S1,S2,r,verbose=False)
    
    **Parameters:**
    
    - `J`: magnitude of the total angular momentum.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `r`: binary separation.
    - `verbose`: if `True` print additional information.

    **Returns:**
    
    - `St_min`: minimum value of S from geometrical constraints. This is S_min in our papers.
    - `St_max`: maximum value of S from geometrical constraints. This is S_max in our papers.
    '''

    ttol=0.0
    L=(q/(1.+q)**2)*(r*M**3)**.5
    St_min=float(max(np.abs(J-L),np.abs(S1-S2)))
    St_max=min(J+L,S1+S2)
    if verbose:
        print "[S_lim] L=",L, " J",J, " S1=",S1," S2=",S2
        print "[S_lim] St_min=",St_min, " St_max=",St_max
        if St_min==np.abs(J-L) and St_max==J+L:
            print "[S_lim] St_min=|J-L|, St_max=J+L"
        elif St_min==np.abs(J-L) and St_max==S1+S2:
            print "[S_lim] St_min=|J-L|, St_max=S1+S2"
        elif St_min==np.abs(S1-S2) and St_max==J+L:
            print "[S_lim] St_min=|S1-S2|, St_max=J+L"
        elif St_min==np.abs(S1-S2) and St_max==S1+S2:
            print "[S_lim] St_min=|S1-S2|, St_max=S1+S2"

    return St_min+ttol,St_max-ttol
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.St_limits_comp">
    <p>def <span class="ident">St_limits_comp</span>(</p><p>kappa, q, S1, S2, u)</p>
    </div>
    

    
  
    <div class="desc"><p>Auxiliary function, see <a href="#precession.St_limits"><code>St_limits</code></a>.</p>
<p><strong>Call:</strong></p>
<pre><code>St_min,St_max=precession.St_limits_comp(kappa,q,S1,S2,u)
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>kappa</code>: rescaling of the total angular momentum to compactify the inspiral domain.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>u</code>: rescaling of the orbital angular momentum to compactify the inspiral domain.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>St_min</code>: minimum value of S from geometrical constraints. This is S_min in our papers.</li>
<li><code>St_max</code>: maximum value of S from geometrical constraints. This is S_max in our papers.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.St_limits_comp', this);">Show source &equiv;</a></p>
  <div id="source-precession.St_limits_comp" class="source">
    <pre><code>def St_limits_comp(kappa,q,S1,S2,u):

    '''
    Auxiliary function, see `precession.St_limits`.
    
    **Call:**

        St_min,St_max=precession.St_limits_comp(kappa,q,S1,S2,u)

    **Parameters:**
    
    - `kappa`: rescaling of the total angular momentum to compactify the inspiral domain.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `u`: rescaling of the orbital angular momentum to compactify the inspiral domain.

    **Returns:**
    
    - `St_min`: minimum value of S from geometrical constraints. This is S_min in our papers.
    - `St_max`: maximum value of S from geometrical constraints. This is S_max in our papers.
    '''

    if u==0:
        St_min=max(np.abs(S1-S2),np.abs(kappa))
        St_max=S1+S2
    else:
        St_min=max(np.abs(S1-S2),np.abs( ((1.+4*kappa*u)**0.5-1)/(2.*u)))
        St_max=min(S1+S2,np.abs( ((1.+4*kappa*u)**0.5+1)/(2.*u)))

    return float(St_min),float(St_max)
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.alpha_of_S">
    <p>def <span class="ident">alpha_of_S</span>(</p><p>S_initial, S_final, Sb_min, Sb_max, xi, J, q, S1, S2, r, alpha_initial=0, sign=1.0)</p>
    </div>
    

    
  
    <div class="desc"><p>Integrate `precession.Omegaz' to find the precession angle spanned by L about J, phiL, as a function of S. Sb_min and Sb_max are passed to this function (and not computed in it) to speed things up. This function can only integrate over half precession period (i.e. from Sb_min to Sb_max at most). If you want phiL(S) over more precession periods you should stich different solutions together, consistently with the argument sign (in particular, flip sign every half period).</p>
<p><strong>Call:</strong></p>
<pre><code>phiL=precession.alpha_of_S(S_initial,S_final,Sb_min,Sb_max,xi,J,q,S1,S2,r,alpha_initial=0,sign=1.):
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>S_initial</code>: lower edge of the integration domain.</li>
<li><code>S_final</code>: upper edge of the integration domain.</li>
<li><code>Sb_min</code>: minimum value of S from geometrical constraints. This is S- in our papers.</li>
<li><code>Sb_max</code>: maximum value of S from geometrical constraints. This is S+ in our papers.</li>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>J</code>: magnitude of the total angular momentum.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>r</code>: binary separation.</li>
<li><code>alpha_initial</code>: initial integration angle.</li>
<li><code>sign</code>: if 1 return angle in [0,pi], if -1 return angle in [-pi,0].</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>phiL</code>: azimuthal angle spanned by L about J.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.alpha_of_S', this);">Show source &equiv;</a></p>
  <div id="source-precession.alpha_of_S" class="source">
    <pre><code>def alpha_of_S( S_initial,S_final ,Sb_min,Sb_max ,xi,J,q,S1,S2,r, alpha_initial=0, sign=1.):
    
    '''
    Integrate `precession.Omegaz' to find the precession angle spanned by L about J, phiL, as a function of S. Sb_min and Sb_max are passed to this function (and not computed in it) to speed things up. This function can only integrate over half precession period (i.e. from Sb_min to Sb_max at most). If you want phiL(S) over more precession periods you should stich different solutions together, consistently with the argument sign (in particular, flip sign every half period).

    **Call:**

        phiL=precession.alpha_of_S(S_initial,S_final,Sb_min,Sb_max,xi,J,q,S1,S2,r,alpha_initial=0,sign=1.):
    
    **Parameters:**
    
    - `S_initial`: lower edge of the integration domain.
    - `S_final`: upper edge of the integration domain.
    - `Sb_min`: minimum value of S from geometrical constraints. This is S- in our papers.
    - `Sb_max`: maximum value of S from geometrical constraints. This is S+ in our papers.
    - `xi`: projection of the effective spin along the orbital angular momentum.
    - `J`: magnitude of the total angular momentum.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `r`: binary separation.
    - `alpha_initial`: initial integration angle.
    - `sign`: if 1 return angle in [0,pi], if -1 return angle in [-pi,0].

    **Returns:**

    - `phiL`: azimuthal angle spanned by L about J.
    '''

    global flags_q1
    if q==1:
        if flags_q1[6]==False:
            print "[alpha_of_S] Warning q=1: input here is cos(varphi), not S; now computing alpha(cosvarphi)"
            flags_q1[6]=True
        
        L=(q/(1.+q)**2)*(r*M**3)**.5
        S = np.sqrt(J**2-L**2-xi*L*M**2)
        S_min,S_max=St_limits(J,q,S1,S2,r)
        
        if np.abs(S-S_min)<1e-8 or np.abs(S-S_max)<1e-8:
            print "[alpha_of_S] Warning: you are at resonance, varphi is ill defined here."
            return 0.
        elif min(S_initial,S_final) < -1 or max(S_initial,S_final) > 1:
            print "[alpha_of_S] Error. You're trying to integrate over more than one (half)period"
            sys.exit()
        else:
            # If q=1, S is constant and therefore Omegaz is also constant. It can be taken out of the integral.
            deltat=t_of_S(S_initial,S_final,Sb_min,Sb_max,xi,J,q,S1,S2,r)
            return alpha_initial + Omegaz(S,xi,J,q,S1,S2,r) *deltat            
    
    if np.abs(Sb_min-Sb_max)<1e-8: # This typically happen when [Sb_limits] fails in bracketing of the solutions. In practice, this is a resonant binary.
        return 0.
    elif min(S_initial,S_final) < Sb_min or max(S_initial,S_final) > Sb_max:
        print "[alpha_of_S] Error. You're trying to integrate over more than one (half)period"
        print Sb_min,Sb_max
        sys.exit()
    else:
        # Actual integration
        res=sp.integrate.quad(OmegazdtdS, S_initial, S_final, args=(xi,J,q,S1,S2,r,sign),full_output=1)               
        return alpha_initial + res[0]
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.alphaz">
    <p>def <span class="ident">alphaz</span>(</p><p>xi, J, q, S1, S2, r)</p>
    </div>
    

    
  
    <div class="desc"><p>Angle spanned by L about J in a single precession cycle. This is <a href="#precession.alpha_of_S"><code>alpha_of_S</code></a> integrated from Sb_min to Sb_max times 2.</p>
<p><strong>Call:</strong></p>
<pre><code>alpha=precession.alphaz(xi,J,q,S1,S2,r)
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>J</code>: magnitude of the total angular momentum.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>r</code>: binary separation.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>alpha</code>: azimuthal angle spanned by L about J in an entire precession cycle.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.alphaz', this);">Show source &equiv;</a></p>
  <div id="source-precession.alphaz" class="source">
    <pre><code>def alphaz(xi,J,q,S1,S2,r):

    '''
    Angle spanned by L about J in a single precession cycle. This is `precession.alpha_of_S` integrated from Sb_min to Sb_max times 2.

    **Call:**

        alpha=precession.alphaz(xi,J,q,S1,S2,r)
    
    **Parameters:**
    
    - `xi`: projection of the effective spin along the orbital angular momentum.
    - `J`: magnitude of the total angular momentum.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `r`: binary separation.

    **Returns:**

    - `alpha`: azimuthal angle spanned by L about J in an entire precession cycle.
    '''

    if q==1: # If q=1, the limits must be specified in cos(varphi)
        Sb_min=-1
        Sb_max=1
        return 2*alpha_of_S(Sb_min,Sb_max,Sb_min,Sb_max,xi,J,q,S1,S2,r) 
        
    else:
        Sb_min,Sb_max=Sb_limits(xi,J,q,S1,S2,r)
        if np.abs(Sb_min-Sb_max)<1e-8: # This typically happen when [Sb_limits] fails in bracketing of the solutions. In practice, this is a resonant binary.
            return 0.
        else:
            res=sp.integrate.quad(OmegazdtdS, Sb_min, Sb_max, args=(xi,J,q,S1,S2,r), full_output=1)
        return 2*res[0]
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.cutoff">
    <p>def <span class="ident">cutoff</span>(</p><p>detector, M_msun)</p>
    </div>
    

    
  
    <div class="desc"><p>Return the GW frequency and binary separation (in total-mass units) when
binary enter the sensitivity window of a typical ground-based LIGO-like
detector or a LISA-like space mission.</p>
<p><strong>Call:</strong></p>
<pre><code>r,f=precession.cutoff(detector,M_msun)
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>detector</code>: specify either <em>space</em> or <em>ground</em>.</li>
<li><code>M_msun</code>: binary total mass in solar masses.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>r</code>: binary separation.</li>
<li><code>f</code>: emitted GW frequency in Hertz.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.cutoff', this);">Show source &equiv;</a></p>
  <div id="source-precession.cutoff" class="source">
    <pre><code>def cutoff(detector,M_msun):

    '''
    Return the GW frequency and binary separation (in total-mass units) when
    binary enter the sensitivity window of a typical ground-based LIGO-like
    detector or a LISA-like space mission.
 
    **Call:**

        r,f=precession.cutoff(detector,M_msun)
    
    **Parameters:**
    
    - `detector`: specify either *space* or *ground*.
    - `M_msun`: binary total mass in solar masses.

    **Returns:**
    
    - `r`: binary separation.
    - `f`: emitted GW frequency in Hertz.
    '''

    if detector=="ground":
        fcut=10 # Hz
    elif detector=="space":
        fcut= 1e-5 # Hz
    else:
        print "[cutoff] Please select 'space' or 'ground'. Otherwise run ftor with the chosen frequency"
        sys.exit()
    rcut=ftor(fcut,M_msun)

    return rcut, fcut
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.dJdL">
    <p>def <span class="ident">dJdL</span>(</p><p>J, r, xi, q, S1, S2)</p>
    </div>
    

    
  
    <div class="desc"><p>Inspiral ODE describing the evolution of the magnitude of the total angular momentum vs. the separation r. This function is NOT used by the ODE solvers (see <a href="#precession.dkappadu"><code>dkappadu</code></a>).</p>
<p><strong>Call:</strong></p>
<pre><code>dJdL=precession.dJdL(J,r,xi,q,S1,S2)
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>J</code>: magnitude of the total angular momentum.</li>
<li><code>r</code>: binary separation.</li>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>dJdL</code>: precession-averaged derivative of J with respect to L.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.dJdL', this);">Show source &equiv;</a></p>
  <div id="source-precession.dJdL" class="source">
    <pre><code>def dJdL(J,r,xi,q,S1,S2):

    '''
    Inspiral ODE describing the evolution of the magnitude of the total angular momentum vs. the separation r. This function is NOT used by the ODE solvers (see `precession.dkappadu`).

    **Call:**

        dJdL=precession.dJdL(J,r,xi,q,S1,S2)
    
    **Parameters:**

    - `J`: magnitude of the total angular momentum.
    - `r`: binary separation.
    - `xi`: projection of the effective spin along the orbital angular momentum.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.

    **Returns:**

    - `dJdL`: precession-averaged derivative of J with respect to L.
    '''

    L=(q/(1.+q)**2)*(r*M**3)**.5    
    kappa=(J**2-L**2)/(2.*L)
    u=1./(2.*L)
    S2pre=dkappadu(kappa,u,xi,q,S1,S2)
    dJdL=(1./(2.*L*J))*(J**2+L**2-S2pre)
    return dJdL
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.dJdr">
    <p>def <span class="ident">dJdr</span>(</p><p>J, r, xi, q, S1, S2)</p>
    </div>
    

    
  
    <div class="desc"><p>Inspiral ODE describing the evolution of the magnitude of the total angular momentum vs. the separation r. This function is NOT used by the ODE solvers (see <a href="#precession.dkappadu"><code>dkappadu</code></a>).</p>
<p><strong>Call:</strong></p>
<pre><code>dJdr=precession.dJdr(J,r,xi,q,S1,S2)
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>J</code>: magnitude of the total angular momentum.</li>
<li><code>r</code>: binary separation.</li>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>dJdr</code>: precession-averaged derivative of J with respect to r.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.dJdr', this);">Show source &equiv;</a></p>
  <div id="source-precession.dJdr" class="source">
    <pre><code>def dJdr(J,r,xi,q,S1,S2):

    '''
    Inspiral ODE describing the evolution of the magnitude of the total angular momentum vs. the separation r. This function is NOT used by the ODE solvers (see `precession.dkappadu`).

    **Call:**

        dJdr=precession.dJdr(J,r,xi,q,S1,S2)
    
    **Parameters:**

    - `J`: magnitude of the total angular momentum.
    - `r`: binary separation.
    - `xi`: projection of the effective spin along the orbital angular momentum.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.

    **Returns:**

    - `dJdr`: precession-averaged derivative of J with respect to r.
    '''

    L=(q/(1.+q)**2)*(r*M**3)**.5    
    kappa=(J**2-L**2)/(2.*L)
    u=1./(2.*L)
    S2pre=dkappadu(kappa,u,xi,q,S1,S2)
    dJdL=(1./(2.*L*J))*(J**2+L**2-S2pre)
    dLdr=L/(2.*r)

    return dJdL*dLdr
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.dSdt">
    <p>def <span class="ident">dSdt</span>(</p><p>S, xi, J, q, S1, S2, r, sign=1.0)</p>
    </div>
    

    
  
    <div class="desc"><p>Compute the derivative of S with respect to t (on the precessional time only, i.e. assuming J is constant). Uses the spin-precession equations, but not the radiation reaction equation. The additional sign lets you specifiy the sign of the angle deltaphi: for consistency with what presented in our papers, use sign=1 if you are in the second half of the precession cycle (deltaphi is in [0,pi]) and sign=-1 if you are in the first half of the precession cycle (deltaphi is in [-pi,0]). If q=1, this function computes d(cos(varphi))/dt.</p>
<p><strong>Call:</strong></p>
<pre><code>dSdt=precession.dSdt(S,xi,J,q,S1,S2,r,sign=1.)
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>S</code>: magnitude of the total spin.</li>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>J</code>: magnitude of the total angular momentum.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>r</code>: binary separation.</li>
<li><code>sign</code>: if 1 return angle in [0,pi], if -1 return angle in [-pi,0].</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>dSdt</code>: precessional-cycle speed.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.dSdt', this);">Show source &equiv;</a></p>
  <div id="source-precession.dSdt" class="source">
    <pre><code>def dSdt(S,xi,J,q,S1,S2,r,sign=1.):

    '''
    Compute the derivative of S with respect to t (on the precessional time only, i.e. assuming J is constant). Uses the spin-precession equations, but not the radiation reaction equation. The additional sign lets you specifiy the sign of the angle deltaphi: for consistency with what presented in our papers, use sign=1 if you are in the second half of the precession cycle (deltaphi is in [0,pi]) and sign=-1 if you are in the first half of the precession cycle (deltaphi is in [-pi,0]). If q=1, this function computes d(cos(varphi))/dt.

    **Call:**

        dSdt=precession.dSdt(S,xi,J,q,S1,S2,r,sign=1.)
    
    **Parameters:**
    
    - `S`: magnitude of the total spin.
    - `xi`: projection of the effective spin along the orbital angular momentum.
    - `J`: magnitude of the total angular momentum.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `r`: binary separation.
    - `sign`: if 1 return angle in [0,pi], if -1 return angle in [-pi,0].

    **Returns:**

    - `dSdt`: precessional-cycle speed.
    '''

    global flags_q1   

    L=(q/(1.+q)**2)*(r*M**3)**.5
    eta=q/(1.+q)**2

    if q==1:
        if flags_q1[3]==False:
            print "[dSdt] Warning q=1: input here is cos(varphi), not S; now computing d(cos(varphi))/dt "
            flags_q1[3]=True
        
        cosvarphi = S # The input variable is actually cos(varphi)
        S = np.sqrt(J**2-L**2-xi*L*M**2)
        S_min,S_max=St_limits(J,q,S1,S2,r)
        
        if np.abs(S-S_min)<1e-8 or np.abs(S-S_max)<1e-8:
            print "[dSdt] Warning: you are at resonance, varphi is ill-defined here."
            return 0.
        
        # Compute d(cos(varphi))/dt
        t6=((S1+S2)**2-S**2)
        t7=(S**2-(S1-S2)**2)        
        B=(4*S**2-xi**2*M**4)*t6*t7
        #B=max(0.0,B)
        t1= (12*S**2*S1*S2)/(np.sqrt(B))
        t2= (eta**2*M**3)**3/L**6
        t3= 1-(eta*M**2*xi)/L
        ct1= (1/(4*S1*S**2))*(xi*M**2*(S**2+S1**2-S2**2)+np.sqrt(B)*cosvarphi)
        ct2= (1/(4*S2*S**2))*(xi*M**2*(S**2+S2**2-S1**2)-np.sqrt(B)*cosvarphi)
        ct12=(S**2-S1**2-S2**2)/(2.*S1*S2)
        t4=(np.abs(1.-ct1**2-ct2**2-ct12**2 +2.*ct1*ct2*ct12))**.5        
        der=sign*t1*t2*t3*t4

    else:
        
        # Compute dS/dt
        t1= (-3. * (1.-q**2) *S1*S2*eta**6*M**9)/(2.*q*S*L**5)
        t2= 1.-((eta*M**2*xi)/L)
        #It's faster if you don't call [parametric_angles] here. Equivalent to 
            #theta1,theta2,deltaphi,theta12 = parametric_angles(S,J,xi,q,S1,S2,r)    
            #der=sign*t1*t2*np.sin(theta1)*np.sin(theta2)*np.sin(deltaphi)
        ct1= ( ((J**2-L**2-S**2)/L) - (2.*q*M**2*xi)/(1.+q) )/(2.*(1.-q)*S1)
        ct2= ( ((J**2-L**2-S**2)*(-q/L)) + (2.*q*M**2*xi)/(1.+q) )/(2.*(1.-q)*S2)
        ct12=(S**2-S1**2-S2**2)/(2.*S1*S2)
        t3=(np.abs(1.-ct1**2-ct2**2-ct12**2 +2.*ct1*ct2*ct12))**.5 # I know abs is dirty, but does the job
        der=sign*t1*t2*t3
        
    return der
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.dkappadu">
    <p>def <span class="ident">dkappadu</span>(</p><p>kappa, u, xi, q, S1, S2)</p>
    </div>
    

    
  
    <div class="desc"><p>Inspiral ODE to perform precession-averaged inspiral: dkappa/du = S^2_pre. We use variables kappa and u (rather than J and L, see <a href="#precession.dJdL"><code>dJdL</code></a>) because this formulation naturally allows for integration from infinitely large separations, i.e. u=0. This function is only the actual equation, not the ODE solver.</p>
<p><strong>Call:</strong></p>
<pre><code>dkappadu=precession.dkappadu(kappa,u,xi,q,S1,S2)
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>kappa</code>: rescaling of the total angular momentum to compactify the inspiral domain.</li>
<li><code>u</code>: rescaling of the orbital angular momentum to compactify the inspiral domain.</li>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>dkappadu</code>: precession-averaged derivative of kappa with respect to u.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.dkappadu', this);">Show source &equiv;</a></p>
  <div id="source-precession.dkappadu" class="source">
    <pre><code>def dkappadu(kappa,u,xi,q,S1,S2):    
      
    '''
    Inspiral ODE to perform precession-averaged inspiral: dkappa/du = S^2_pre. We use variables kappa and u (rather than J and L, see `precession.dJdL`) because this formulation naturally allows for integration from infinitely large separations, i.e. u=0. This function is only the actual equation, not the ODE solver.

    **Call:**

        dkappadu=precession.dkappadu(kappa,u,xi,q,S1,S2)
    
    **Parameters:**

    - `kappa`: rescaling of the total angular momentum to compactify the inspiral domain.
    - `u`: rescaling of the orbital angular momentum to compactify the inspiral domain.
    - `xi`: projection of the effective spin along the orbital angular momentum.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.

    **Returns:**

    - `dkappadu`: precession-averaged derivative of kappa with respect to u.
    '''
  
    dkappadu_debug=False #Debug option
    if dkappadu_debug:
        print "[dkappadu] ODE int: u="+str(u)+"\t\tkappa="+str(float(kappa))
    
    Sb_min,Sb_max = Sb_limits_comp(xi,kappa,q,S1,S2,u)

    if np.abs(Sb_min-Sb_max)<1e-8:
        if dkappadu_debug:
            print "[dkappadu] Warning. Applyting analytical approximation. u=",u
        return (np.mean([Sb_min,Sb_max]))**2
    else:      
        up=sp.integrate.quad(S3sines_comp, Sb_min, Sb_max, args=(xi,kappa,q,S1,S2,u), full_output=1)
        down=sp.integrate.quad(Ssines_comp , Sb_min, Sb_max, args=(xi,kappa,q,S1,S2,u), full_output=1)
        return up[0]/down[0]
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.dtdS">
    <p>def <span class="ident">dtdS</span>(</p><p>S, xi, J, q, S1, S2, r, sign=1.0)</p>
    </div>
    

    
  
    <div class="desc"><p>Auxiliary function dt/dS=(dS/dt)^-1. <code>See precession.dSdt</code>.</p>
<p><strong>Call:</strong></p>
<pre><code>dtdS=precession.dtdS(S,xi,J,q,S1,S2,r,sign=1.)
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>S</code>: magnitude of the total spin.</li>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>J</code>: magnitude of the total angular momentum.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>r</code>: binary separation.</li>
<li><code>sign</code>: if 1 return angle in [0,pi], if -1 return angle in [-pi,0].</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>dtdS</code>: inverse of the precessional-cycle speed.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.dtdS', this);">Show source &equiv;</a></p>
  <div id="source-precession.dtdS" class="source">
    <pre><code>def dtdS(S,xi,J,q,S1,S2,r,sign=1.):

    '''
    Auxiliary function dt/dS=(dS/dt)^-1. `See precession.dSdt`.

    **Call:**

        dtdS=precession.dtdS(S,xi,J,q,S1,S2,r,sign=1.)
    
    **Parameters:**
    
    - `S`: magnitude of the total spin.
    - `xi`: projection of the effective spin along the orbital angular momentum.
    - `J`: magnitude of the total angular momentum.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `r`: binary separation.
    - `sign`: if 1 return angle in [0,pi], if -1 return angle in [-pi,0].

    **Returns:**

    - `dtdS`: inverse of the precessional-cycle speed.
    '''

    return 1./(dSdt(S,xi,J,q,S1,S2,r,sign))
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.dxidS_minus">
    <p>def <span class="ident">dxidS_minus</span>(</p><p>S, J, q, S1, S2, r)</p>
    </div>
    

    
  
    <div class="desc"><p>Derivative of the effective potential xi_minus with respect to S.    </p>
<p><strong>Call:</strong></p>
<pre><code>dxidS=precession.dxidS_minus(S,J,q,S1,S2,r)
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>S</code>: magnitude of the total spin.</li>
<li><code>J</code>: magnitude of the total angular momentum.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>r</code>: binary separation.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>dxidS</code>: derivative of effective potential with respect to S.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.dxidS_minus', this);">Show source &equiv;</a></p>
  <div id="source-precession.dxidS_minus" class="source">
    <pre><code>def dxidS_minus(S,J,q,S1,S2,r):
    
    '''
    Derivative of the effective potential xi_minus with respect to S.    

    **Call:**

        dxidS=precession.dxidS_minus(S,J,q,S1,S2,r)
    
    **Parameters:**
    
    - `S`: magnitude of the total spin.
    - `J`: magnitude of the total angular momentum.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `r`: binary separation.

    **Returns:**

    - `dxidS`: derivative of effective potential with respect to S.
    '''

    L=(q/(1.+q)**2)*(r*M**3)**.5
    A1=np.sqrt(J**2-(L-S)**2)
    A2=np.sqrt((L+S)**2-J**2)
    A3=np.sqrt(S**2-(S1-S2)**2)
    A4=np.sqrt((S1+S2)**2-S**2)
    Fm = (J**2-L**2-S**2)*(S**2*(1+q)**2-(S1**2-S2**2)*(1-q**2))-(1-q**2)*A1*A2*A3*A4
    G=4*q*M**2*S**2*L
    dFmdS = -2*S*(S**2*(1+q)**2-(S1**2-S2**2)*(1-q**2))+2*S*(1+q)**2*(J**2-L**2-S**2)-(1-q**2)*(((L-S)*A2*A3*A4)/A1+((L+S)*A3*A4*A1)/A2+(S*A4*A1*A2)/A3-(S*A1*A2*A3)/A4)
    dGdS=8*q*M**2*S*L
    dximdS=(dFmdS*G-dGdS*Fm)/(G**2)
    return dximdS
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.dxidS_plus">
    <p>def <span class="ident">dxidS_plus</span>(</p><p>S, J, q, S1, S2, r)</p>
    </div>
    

    
  
    <div class="desc"><p>Derivative of the effective potential xi_plus with respect to S.    </p>
<p><strong>Call:</strong></p>
<pre><code>dxidS=precession.dxidS_plus(S,J,q,S1,S2,r)
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>S</code>: magnitude of the total spin.</li>
<li><code>J</code>: magnitude of the total angular momentum.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>r</code>: binary separation.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>dxidS</code>: derivative of effective potential with respect to S.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.dxidS_plus', this);">Show source &equiv;</a></p>
  <div id="source-precession.dxidS_plus" class="source">
    <pre><code>def dxidS_plus(S,J,q,S1,S2,r):

    '''
    Derivative of the effective potential xi_plus with respect to S.    

    **Call:**

        dxidS=precession.dxidS_plus(S,J,q,S1,S2,r)
    
    **Parameters:**
    
    - `S`: magnitude of the total spin.
    - `J`: magnitude of the total angular momentum.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `r`: binary separation.

    **Returns:**

    - `dxidS`: derivative of effective potential with respect to S.
    '''
    
    L=(q/(1.+q)**2)*(r*M**3)**.5
    A1=np.sqrt(J**2-(L-S)**2)
    A2=np.sqrt((L+S)**2-J**2)
    A3=np.sqrt(S**2-(S1-S2)**2)
    A4=np.sqrt((S1+S2)**2-S**2)
    Fp = (J**2-L**2-S**2)*(S**2*(1+q)**2-(S1**2-S2**2)*(1-q**2))+(1-q**2)*A1*A2*A3*A4
    G=4*q*M**2*S**2*L
    dFpdS = -2*S*(S**2*(1+q)**2-(S1**2-S2**2)*(1-q**2))+2*S*(1+q)**2*(J**2-L**2-S**2)+(1-q**2)*(((L-S)*A2*A3*A4)/A1+((L+S)*A3*A4*A1)/A2+(S*A4*A1*A2)/A3-(S*A1*A2*A3)/A4)
    dGdS=8*q*M**2*S*L
    dxipdS=(dFpdS*G-dGdS*Fp)/(G**2)
    return dxipdS
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.empty_temp">
    <p>def <span class="ident">empty_temp</span>(</p><p>)</p>
    </div>
    

    
  
    <div class="desc"><p>Remove all checkpoints.</p>
<p><strong>Call:</strong></p>
<pre><code>precession.empty_temp()
</code></pre></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.empty_temp', this);">Show source &equiv;</a></p>
  <div id="source-precession.empty_temp" class="source">
    <pre><code>def empty_temp():

    '''
    Remove all checkpoints.

    **Call:**

        precession.empty_temp()
    '''
    
    global storedir
    print "[empty_temp] Removing temp files from directory: "+storedir
    os.system("rm -rf "+storedir) 
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.evolve_J">
    <p>def <span class="ident">evolve_J</span>(</p><p>xi_vals, J_vals, r_vals, q, S1, S2)</p>
    </div>
    

    
  
    <div class="desc"><p>Wrapper of <a href="#precession.Jofr"><code>Jofr</code></a> to enable parallelization through the python <code>parmap</code> module; the number of available cores can be specified using the integer global variable <code>CPUs</code> (all available cores will be used by default). Evolve a sequence of binaries with the SAME q, S1, S2 but different xi and initial values of J and save outputs at r_vals. Output is a 2D array, where e.g. J_vals[0] is the first binary (1D array at all output separations) and J_vals[0][0] is the first binary at the first output separation (this is a scalar). We strongly reccommend using this function, even for a single binary.</p>
<p>Checkpointing is implemented: results are stored in <a href="#precession.storedir"><code>storedir</code></a>.</p>
<p><strong>Call:</strong></p>
<pre><code>Jf_vals=precession.evolve_J(xi_vals,Ji_vals,r_vals,q,S1,S2)
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>xi_vals</code>: projection of the effective spin along the orbital angular momentum (array).</li>
<li><code>Ji_vals</code>: initial condition for numerical integration (array).</li>
<li><code>r_vals</code>: binary separation (array).</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>Jf_vals</code>: magnitude of the total angular momentum (2D array).</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.evolve_J', this);">Show source &equiv;</a></p>
  <div id="source-precession.evolve_J" class="source">
    <pre><code>def evolve_J(xi_vals,J_vals,r_vals,q,S1,S2):

    '''
    Wrapper of `precession.Jofr` to enable parallelization through the python `parmap` module; the number of available cores can be specified using the integer global variable `CPUs` (all available cores will be used by default). Evolve a sequence of binaries with the SAME q, S1, S2 but different xi and initial values of J and save outputs at r_vals. Output is a 2D array, where e.g. J_vals[0] is the first binary (1D array at all output separations) and J_vals[0][0] is the first binary at the first output separation (this is a scalar). We strongly reccommend using this function, even for a single binary.

    Checkpointing is implemented: results are stored in `precession.storedir`.
 
    **Call:**

        Jf_vals=precession.evolve_J(xi_vals,Ji_vals,r_vals,q,S1,S2)
     
    **Parameters:**

    - `xi_vals`: projection of the effective spin along the orbital angular momentum (array).
    - `Ji_vals`: initial condition for numerical integration (array).
    - `r_vals`: binary separation (array).
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.

    **Returns:**

    - `Jf_vals`: magnitude of the total angular momentum (2D array).
    '''

    global CPUs

    single_flag=False
    try: # Convert float to array if you're evolving just one binary
        len(xi_vals)
        len(J_vals)
    except:
        xi_vals=[xi_vals]
        J_vals=[J_vals]
        single_flag=True
    try: # Set default
        CPUs
    except:
        CPUs=0
        print "[evolve_J] Default parallel computation"
    # Parallelization.
    if CPUs==0: # Run on all cpus on the current machine! (default option)
        filelist=parmap.starmap(Jofr_checkpoint, zip(xi_vals,J_vals),r_vals,q,S1,S2,parallel=True) 
    elif CPUs==1: # 1 cpus done by explicitely switching parallelization off
        filelist=parmap.starmap(Jofr_checkpoint, zip(xi_vals,J_vals),r_vals,q,S1,S2,parallel=False) 
    else: # Run on a given number of CPUs        
        p = multiprocessing.Pool(CPUs)
        filelist=parmap.starmap(Jofr_checkpoint, zip(xi_vals,J_vals),r_vals,q,S1,S2,pool=p) 

    J_fvals=[]
    for index, file in enumerate(filelist):
        print "[evolve_J] Reading:", index, file
        dummy,J_f= np.loadtxt(file,unpack=True)
             
        J_fvals.append(J_f)

    if single_flag==True:
        return J_fvals[0]
    else:
        return J_fvals
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.evolve_J_backwards">
    <p>def <span class="ident">evolve_J_backwards</span>(</p><p>xi_vals, J_vals, r, q, S1, S2)</p>
    </div>
    

    
  
    <div class="desc"><p>Wrapper of <a href="#precession.kappa_backwards"><code>kappa_backwards</code></a> to enable parallelization through the python <code>parmap</code> module; the number of available cores can be specified using the integer global variable <code>CPUs</code> (all available cores will be used by default). Evolve a sequence of binaries with the SAME q, S1,S2, from the SAME separation r, but different xi and initial kappa_inf.</p>
<p>Checkpointing is implemented: results are stored in <a href="#precession.storedir"><code>storedir</code></a>.</p>
<p><strong>Call:</strong></p>
<pre><code>kappainf_vals=precession.evolve_J_backwards(xi_vals,J_vals,r,q,S1,S2)
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>xi_vals</code>: projection of the effective spin along the orbital angular momentum (array).</li>
<li><code>J</code>: magnitude of the total angular momentum (array).</li>
<li><code>r</code>: binary separation.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>kappainf_vals</code>: asymptotic value of kappa at large separations (array).</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.evolve_J_backwards', this);">Show source &equiv;</a></p>
  <div id="source-precession.evolve_J_backwards" class="source">
    <pre><code>def evolve_J_backwards(xi_vals,J_vals,r,q,S1,S2):

    '''
    Wrapper of `precession.kappa_backwards` to enable parallelization through the python `parmap` module; the number of available cores can be specified using the integer global variable `CPUs` (all available cores will be used by default). Evolve a sequence of binaries with the SAME q, S1,S2, from the SAME separation r, but different xi and initial kappa_inf.

    Checkpointing is implemented: results are stored in `precession.storedir`.
 
    **Call:**

        kappainf_vals=precession.evolve_J_backwards(xi_vals,J_vals,r,q,S1,S2)

    **Parameters:**

    - `xi_vals`: projection of the effective spin along the orbital angular momentum (array).
    - `J`: magnitude of the total angular momentum (array).
    - `r`: binary separation.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.

    **Returns:**

    - `kappainf_vals`: asymptotic value of kappa at large separations (array).
    '''



    global CPUs

    flag=False
    try: #Convert float to array, if you're evolving just one binary
        len(xi_vals)
        len(J_vals)
    except:
        xi_vals=[xi_vals]
        J_vals=[J_vals]
        flag=True
    try:
        CPUs
    except:
        CPUs=0
        print "[evolve_J_backwards] Default parallel computation"
    #Parallelization... python is cool indeed
    if CPUs==0: #Run on all cpus on the current machine! (default option)
        filelist=parmap.starmap(kappa_backwards_checkpoint, zip(xi_vals,J_vals),r,q,S1,S2,parallel=True) 
    elif CPUs==1: #1 cpus done by explicitely removing parallelization
        filelist=parmap.starmap(kappa_backwards_checkpoint, zip(xi_vals,J_vals),r,q,S1,S2,parallel=False) 
    else: # Run on a given number of CPUs        
        p = multiprocessing.Pool(CPUs)
        filelist=parmap.starmap(kappa_backwards_checkpoint, zip(xi_vals,J_vals),r,q,S1,S2,pool=p) 

    kappainf_vals=[]
    for index, file in enumerate(filelist):
        print "[evolve_J_backwards] Reading:", index, file
        kappa_inf= np.loadtxt(file,unpack=True)     
        kappainf_vals.append(kappa_inf)
    
    if flag==True:
        return kappainf_vals[0]
    else:
        return kappainf_vals
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.evolve_J_infinity">
    <p>def <span class="ident">evolve_J_infinity</span>(</p><p>xi_vals, kappainf_vals, r_vals, q, S1, S2)</p>
    </div>
    

    
  
    <div class="desc"><p>Wrapper of <a href="#precession.Jofr_infinity"><code>Jofr_infinity</code></a> to enable parallelization through the python <code>parmap</code> module; the number of available cores can be specified using the integer global variable <code>CPUs</code> (all available cores will be used by default). Evolve a sequence of binaries with the SAME q, S1, S2 but different xi and initial values of J and save outputs at r_vals. Output is a 2D array, where e.g. J_vals[0] is the first binary (1D array at all output separations) and J_vals[0][0] is the first binary at the first output separation (this is a scalar). We strongly reccommend using this function, even for a single binary.</p>
<p>Checkpointing is implemented: results are stored in <code>precession.g</code>.</p>
<p><strong>Call:</strong></p>
<pre><code>Jf_vals=precession.evolve_J_infinity(xi_vals,kappainf_vals,r_vals,q,S1,S2)
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>xi_vals</code>: projection of the effective spin along the orbital angular momentum (array).</li>
<li><code>kappainf_vals</code>: asymptotic value of kappa at large separations (array).</li>
<li><code>r_vals</code>: binary separation (array).</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>Jf_vals</code>: magnitude of the total angular momentum (2D array).</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.evolve_J_infinity', this);">Show source &equiv;</a></p>
  <div id="source-precession.evolve_J_infinity" class="source">
    <pre><code>def evolve_J_infinity(xi_vals,kappainf_vals,r_vals,q,S1,S2):

    '''
    Wrapper of `precession.Jofr_infinity` to enable parallelization through the python `parmap` module; the number of available cores can be specified using the integer global variable `CPUs` (all available cores will be used by default). Evolve a sequence of binaries with the SAME q, S1, S2 but different xi and initial values of J and save outputs at r_vals. Output is a 2D array, where e.g. J_vals[0] is the first binary (1D array at all output separations) and J_vals[0][0] is the first binary at the first output separation (this is a scalar). We strongly reccommend using this function, even for a single binary.

    Checkpointing is implemented: results are stored in `precession.g`.
 
    **Call:**

        Jf_vals=precession.evolve_J_infinity(xi_vals,kappainf_vals,r_vals,q,S1,S2)

    **Parameters:**

    - `xi_vals`: projection of the effective spin along the orbital angular momentum (array).
    - `kappainf_vals`: asymptotic value of kappa at large separations (array).
    - `r_vals`: binary separation (array).
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.

    **Returns:**

    - `Jf_vals`: magnitude of the total angular momentum (2D array).
    '''

    global CPUs

    single_flag=False
    try: #Convert float to array if you're evolving just one binary
        len(xi_vals)
        len(kappainf_vals)
    except:
        xi_vals=[xi_vals]
        kappainf_vals=[kappainf_vals]
        single_flag=True
    try: # Set default
        CPUs
    except:
        CPUs=0
        print "[evolve_J_infinity] Default parallel computation"
    # Parallelization
    if CPUs==0: # Run on all cpus on the current machine! (default option)
        filelist=parmap.starmap(Jofr_infinity_checkpoint, zip(xi_vals,kappainf_vals),r_vals,q,S1,S2,parallel=True) 
    elif CPUs==1: # 1 cpus done by explicitely removing parallelization
        filelist=parmap.starmap(Jofr_infinity_checkpoint, zip(xi_vals,kappainf_vals),r_vals,q,S1,S2,parallel=False) 
    else: # Run on a given number of CPUs        
        p = multiprocessing.Pool(CPUs)
        filelist=parmap.starmap(Jofr_infinity_checkpoint, zip(xi_vals,kappainf_vals),r_vals,q,S1,S2,pool=p) 

    J_fvals=[]
    for index, file in enumerate(filelist):
        print "[evolve_J_infinity] Reading:", index, file
        dummy,J_f= np.loadtxt(file,unpack=True)
             
        J_fvals.append(J_f)

    if single_flag==True:    
        return J_fvals[0]
    else:
        return J_fvals
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.evolve_angles">
    <p>def <span class="ident">evolve_angles</span>(</p><p>theta1_vals, theta2_vals, deltaphi_vals, r_vals, q, S1, S2)</p>
    </div>
    

    
  
    <div class="desc"><p>Binary evolution from the angles theta1, theta2 and deltaphi as initial data (to/from FINITE separations only). This is our so-called <em>transfer function</em>. The transfer procedure is implemented as follows:</p>
<ol>
<li>Convert theta1,theta2, deltaphi into J, xi and S.</li>
<li>Forget S and evolve J.</li>
<li>Resample S at the final separation according to dt/dS. </li>
<li>Covert J, xi and S back to theta1, theta2 and deltaphi; assign a random sign to deltaphi.</li>
</ol>
<p>Parallelization through the python <code>parmap</code> module is implemented; the number of available cores can be specified using the integer global variable <code>CPUs</code> (all available cores will be used by default). Evolve a sequence of binaries with the SAME q, S1,S2 but different theta1, theta2, deltaphi (assumed to be specified at r_vals[0]) and save outputs at r_vals. Outputs are 2D arrays, where e.g theta1_fvals[0] is the first binary (1D array at all output separations) and theta1_fvals[0][0] is the first binary at the first output separation (this is a scalar).</p>
<p>Checkpointing is implemented: results are stored in <a href="#precession.storedir"><code>storedir</code></a>.</p>
<p><strong>Call:</strong></p>
<pre><code>theta1f_vals,theta2f_vals,deltaphif_vals=precession.evolve_angles(theta1i_vals,theta2i_vals,deltaphii_vals,r_vals,q,S1,S2)
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>theta1i_vals</code>: initial condition for theta1 (array).</li>
<li><code>theta2i_vals</code>: initial condition for theta2 (array).</li>
<li><code>deltaphii_vals</code>: initial condition for deltaphi (array).</li>
<li><code>r_vals</code>: binary separation (array).</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>theta1f_vals</code>: solutions for theta1 (2D array).</li>
<li><code>theta2f_vals</code>: solutions for theta2 (2D array).</li>
<li><code>deltaphif_vals</code>: solutions for deltaphi (2D array).</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.evolve_angles', this);">Show source &equiv;</a></p>
  <div id="source-precession.evolve_angles" class="source">
    <pre><code>def evolve_angles(theta1_vals,theta2_vals,deltaphi_vals,r_vals,q,S1,S2):

    '''
    Binary evolution from the angles theta1, theta2 and deltaphi as initial data (to/from FINITE separations only). This is our so-called *transfer function*. The transfer procedure is implemented as follows:
    
    1. Convert theta1,theta2, deltaphi into J, xi and S.
    2. Forget S and evolve J.
    3. Resample S at the final separation according to dt/dS. 
    4. Covert J, xi and S back to theta1, theta2 and deltaphi; assign a random sign to deltaphi.

    Parallelization through the python `parmap` module is implemented; the number of available cores can be specified using the integer global variable `CPUs` (all available cores will be used by default). Evolve a sequence of binaries with the SAME q, S1,S2 but different theta1, theta2, deltaphi (assumed to be specified at r_vals[0]) and save outputs at r_vals. Outputs are 2D arrays, where e.g theta1_fvals[0] is the first binary (1D array at all output separations) and theta1_fvals[0][0] is the first binary at the first output separation (this is a scalar).

    Checkpointing is implemented: results are stored in `precession.storedir`.
 
    **Call:**

        theta1f_vals,theta2f_vals,deltaphif_vals=precession.evolve_angles(theta1i_vals,theta2i_vals,deltaphii_vals,r_vals,q,S1,S2)
         
    **Parameters:**
    
    - `theta1i_vals`: initial condition for theta1 (array).
    - `theta2i_vals`: initial condition for theta2 (array).
    - `deltaphii_vals`: initial condition for deltaphi (array).
    - `r_vals`: binary separation (array).
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.

    **Returns:**

    - `theta1f_vals`: solutions for theta1 (2D array).
    - `theta2f_vals`: solutions for theta2 (2D array).
    - `deltaphif_vals`: solutions for deltaphi (2D array).
    '''

    global CPUs
    single_flag=False

    try: # Convert float to array if you're evolving just one binary
        len(theta1_vals)
        len(theta1_vals)
        len(deltaphi_vals)
    except:
        single_flag=True
        theta1_vals=[theta1_vals]
        theta2_vals=[theta2_vals]
        deltaphi_vals=[deltaphi_vals]

    try: # Set default
        CPUs
    except:
        CPUs=0
        print "[evolve_angles] Default parallel computation"

    loopflag=True
    while loopflag: # Restart is some of the cores crashed. This happend if you run too many binaries on too many different machines. Nevermind, trash the file and do it again.
        loopflag=False

        #Parallelization
        if CPUs==0: #Run on all cpus on the current machine! (default option)
            filelist=parmap.starmap(evolve_angles_single, zip(theta1_vals,theta2_vals,deltaphi_vals),r_vals,q,S1,S2,parallel=True) 
        elif CPUs==1: #1 cpus done by explicitely removing parallelization
            filelist=parmap.starmap(evolve_angles_single, zip(theta1_vals,theta2_vals,deltaphi_vals),r_vals,q,S1,S2,parallel=False) 
        else: # Run on a given number of CPUs        
            p = multiprocessing.Pool(CPUs)
            filelist=parmap.starmap(evolve_angles_single, zip(theta1_vals,theta2_vals,deltaphi_vals),r_vals,q,S1,S2,pool=p) 

        theta1_fvals=[]
        theta2_fvals=[]
        deltaphi_fvals=[]
        for index, file in enumerate(filelist):
            print "[evolve_angles] Reading:", index, file
            numlines=sum(1 for line in open(file))
            if numlines!=0 and numlines!=len(r_vals): # Restart if core(s) crashed
                print "[evolve_angles] Error on file", file,". Jobs are being restarted!"
                os.system("rm "+file) 
                loopflag=True
 
            else:
                dummy,theta1_f,theta2_f,deltaphi_f= np.loadtxt(file,unpack=True)
                theta1_fvals.append(theta1_f)
                theta2_fvals.append(theta2_f)
                deltaphi_fvals.append(deltaphi_f)        
        
    if single_flag==True:
        return theta1_fvals[0], theta2_fvals[0], deltaphi_fvals[0]
    else:
        return theta1_fvals, theta2_fvals, deltaphi_fvals
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.evolve_angles_single">
    <p>def <span class="ident">evolve_angles_single</span>(</p><p>theta1_i, theta2_i, deltaphi_i, r_vals, q, S1, S2)</p>
    </div>
    

    
  
    <div class="desc"><p>Auxiliary function, see <code>evolve_angles</code>.</p>
<p><strong>Call:</strong></p>
<pre><code>savename=precession.evolve_angles(theta1_i,theta2_i,deltaphi_i,r_vals,q,S1,S2)
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>theta1_i</code>: initial condition for theta1.</li>
<li><code>theta2_i</code>: initial condition for theta2</li>
<li><code>deltaphi_i</code>: initial condition for deltaphi.</li>
<li><code>r_vals</code>: binary separation (array).</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>savename</code>: checkpoint filename.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.evolve_angles_single', this);">Show source &equiv;</a></p>
  <div id="source-precession.evolve_angles_single" class="source">
    <pre><code>def evolve_angles_single(theta1_i,theta2_i,deltaphi_i,r_vals,q,S1,S2):

    '''
    Auxiliary function, see `evolve_angles`.

    **Call:**

        savename=precession.evolve_angles(theta1_i,theta2_i,deltaphi_i,r_vals,q,S1,S2)

    **Parameters:**
    
    - `theta1_i`: initial condition for theta1.
    - `theta2_i`: initial condition for theta2
    - `deltaphi_i`: initial condition for deltaphi.
    - `r_vals`: binary separation (array).
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.

    **Returns:**

    - `savename`: checkpoint filename.
    '''


    os.system("mkdir -p "+storedir) 
    savename= storedir+"/eva_"+'_'.join([str(x) for x in (theta1_i,theta2_i,deltaphi_i,max(r_vals),min(r_vals),len(r_vals),q,S1,S2)])+".dat"
        
    if not os.path.isfile(savename):
        print "[evolve_angles] Transferring binary. Output:", savename
        outfilesave = open(savename,"w",0)
       
        # Step 1. Get xi and J for each intial angle. Forget S    
        xi,J_i,dummy= from_the_angles(theta1_i,theta2_i,deltaphi_i,q,S1,S2,r_vals[0]) 
                
        # Step 2. Evolve binaires with the dJ/dr ODE.
        J_vals= Jofr(xi,J_i,r_vals,q,S1,S2)

        for J_f,r_f in zip(J_vals,r_vals):
            # Step 3. Select S at the final separation with weight dt/dS
            S_f=samplingS(xi,J_f,q,S1,S2,r_f)
            # Step 4. Back to theta1, theta2, deltaphi
            theta1_f,theta2_f,deltaphi_f,dummy= parametric_angles(S_f,J_f,xi,q,S1,S2,r_f)
            deltaphi_f*=random.choice([-1., 1.])
            # Step 5. Store data            
            #outfilesave.write(str(r_f)+" "+str(xi)+" "+str(J_f)+" "+str(S_f)+" "+str(theta1_f)+" "+str(theta2_f)+" "+str(deltaphi_f)+"\n")
            outfilesave.write(str(r_f)+" "+str(theta1_f)+" "+str(theta2_f)+" "+str(deltaphi_f)+"\n")
        outfilesave.close()

    #else:
    #    print "[evolve_angles] Skipping. Output:", savename
    
    return savename
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.find_morphology">
    <p>def <span class="ident">find_morphology</span>(</p><p>xi, J, q, S1, S2, r)</p>
    </div>
    

    
  
    <div class="desc"><p>Compute the precessional morphology in DeltaPhi. Returns:</p>
<ul>
<li>-1 if librating about DeltaPhi=0;</li>
<li>0 if circulating in the whole DeltaPhi range [-pi,pi];</li>
<li>+1 if librating about DeltaPhi=pi.</li>
</ul>
<p><strong>Call:</strong></p>
<pre><code>morphology=precession.find_morphology(xi,J,q,S1,S2,r)
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>J</code>: magnitude of the total angular momentum.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>r</code>: binary separation.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li>morphology: precessional morphology in DeltaPhi: -1 if librating about DeltaPhi=0; 0 if circulating; +1 if librating about DeltaPhi=pi.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.find_morphology', this);">Show source &equiv;</a></p>
  <div id="source-precession.find_morphology" class="source">
    <pre><code>def find_morphology(xi,J,q,S1,S2,r):

    '''
    Compute the precessional morphology in DeltaPhi. Returns:
    
    - -1 if librating about DeltaPhi=0;
    - 0 if circulating in the whole DeltaPhi range [-pi,pi];
    - +1 if librating about DeltaPhi=pi.

    **Call:**

        morphology=precession.find_morphology(xi,J,q,S1,S2,r)

    **Parameters:**

    - `xi`: projection of the effective spin along the orbital angular momentum.
    - `J`: magnitude of the total angular momentum.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `r`: binary separation.

    **Returns:**

    - morphology: precessional morphology in DeltaPhi: -1 if librating about DeltaPhi=0; 0 if circulating; +1 if librating about DeltaPhi=pi.
    '''
  
    if q==1: # If q=1, the limits must be specified in cos(varphi)
        Sb_min=-1
        Sb_max=1
    else:    
        Sb_min,Sb_max=Sb_limits(xi,J,q,S1,S2,r)      
    
    dummy,dummy,deltaphi_Sbmin,dummy = parametric_angles(Sb_min,J,xi,q,S1,S2,r)
    dummy,dummy,deltaphi_Sbmax,dummy = parametric_angles(Sb_max,J,xi,q,S1,S2,r)

    # Both the initial and the final point in a precession cycle are <pi/2. This is a libration about DeltaPhi=0
    if deltaphi_Sbmin<np.pi/2. and deltaphi_Sbmax<np.pi/2.:
        return -1.
    # Both the initial and the final point in a precession cycle are >pi/2. This is a libration about DeltaPhi=180
    elif deltaphi_Sbmin>np.pi/2. and deltaphi_Sbmax>np.pi/2.:
        return 1.
    # The precession orbit crosses both DeltaPhi=0 and DeltaPhi=180. This is  circulation
    else:
        return 0.
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.from_the_angles">
    <p>def <span class="ident">from_the_angles</span>(</p><p>theta1, theta2, deltaphi, q, S1, S2, r)</p>
    </div>
    

    
  
    <div class="desc"><p>Convert a set of angles theta1,theta2,deltaphi into values of J,xi,S.
This function can be seen as the inverse of <a href="#precession.parametric_angles"><code>parametric_angles</code></a>. In the
equal-mass limit q=1, S doesn't parametrize the precessional motion; we
track the binary precession using varphi explicitly.</p>
<p><strong>Call:</strong></p>
<pre><code>xi,J,S=precession.from_the_angles(theta1,theta2,deltaphi,q,S1,S2,r)
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>theta1</code>: angle between the spin of the primary and the orbital angular momentum.</li>
<li><code>theta2</code>: angle between the spin of the secondary and the orbital angular momentum.</li>
<li><code>deltaphi</code>: angle between the projection of the two spins on the orbital plane.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>r</code>: binary separation.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>J</code>: magnitude of the total angular momentum.</li>
<li><code>S</code>: magnitude of the total spin.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.from_the_angles', this);">Show source &equiv;</a></p>
  <div id="source-precession.from_the_angles" class="source">
    <pre><code>def from_the_angles(theta1,theta2,deltaphi,q,S1,S2,r):

    '''
    Convert a set of angles theta1,theta2,deltaphi into values of J,xi,S.
    This function can be seen as the inverse of `precession.parametric_angles`. In the
    equal-mass limit q=1, S doesn't parametrize the precessional motion; we
    track the binary precession using varphi explicitly.

    **Call:**

        xi,J,S=precession.from_the_angles(theta1,theta2,deltaphi,q,S1,S2,r)

    **Parameters:**

    - `theta1`: angle between the spin of the primary and the orbital angular momentum.
    - `theta2`: angle between the spin of the secondary and the orbital angular momentum.
    - `deltaphi`: angle between the projection of the two spins on the orbital plane.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `r`: binary separation.

    **Returns:**
    
    - `xi`: projection of the effective spin along the orbital angular momentum.
    - `J`: magnitude of the total angular momentum.
    - `S`: magnitude of the total spin.   
    '''

    L=(q/(1.+q)**2)*(r*M**3)**.5
    
    global flags_q1
    if q==1:
        if flags_q1[1]==False:
            print "[from_the_angles] Warning q=1: output here is cos(varphi), not S."
            flags_q1[1]=True # Suppress future warnings
        xi = (2/M**2)*(S1 *np.cos(theta1)+S2*np.cos(theta2))
        Ssq = S1**2 + S2**2 +2*S1*S2*(np.cos(theta1)*np.cos(theta2)+np.sin(theta1)*np.sin(theta2)*np.cos(deltaphi))
        J=np.sqrt(Ssq+L**2+xi*L*M**2)
        t6=((S1+S2)**2-Ssq)
        t7=(Ssq-(S1-S2)**2)        
        B=(4*Ssq-xi**2*M**4)*t6*t7
        cosvarphi= (4*S1*Ssq*np.cos(theta1)-xi*M**2*(Ssq+S1**2-S2**2))/(np.sqrt(B))
        return xi,J,cosvarphi # The output variable is actually cos(varphi)
    
    else:
        xi= ((1.+q)*S1*np.cos(theta1)+(1.+q**-1)*S2*np.cos(theta2))*M**-2
        S= (S1**2+S2**2+2.*S1*S2*(np.sin(theta1)*np.sin(theta2)*np.cos(deltaphi)+np.cos(theta1)*np.cos(theta2)))**.5
        J= (L**2+S**2+2.*L*(S1*np.cos(theta1)+S2*np.cos(theta2)))**.5
        return xi,J,S
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.from_the_angles_inf">
    <p>def <span class="ident">from_the_angles_inf</span>(</p><p>theta1_inf, theta2_inf, q, S1, S2)</p>
    </div>
    

    
  
    <div class="desc"><p>Find xi and kappa_inf given the asymptotic (constant) values of theta1 and theta2.</p>
<p><strong>Call:</strong></p>
<pre><code>xi,kappa_inf=precession.from_the_angles_inf(theta1_inf,theta2_inf,q,S1,S2)
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>theta1_inf</code>: asymptotic value of theta1 at large separations.</li>
<li><code>theta2_inf</code>: asymptotic value of theta2 at large separations.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>kappa_inf</code>: asymptotic value of kappa at large separations.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.from_the_angles_inf', this);">Show source &equiv;</a></p>
  <div id="source-precession.from_the_angles_inf" class="source">
    <pre><code>def from_the_angles_inf(theta1_inf,theta2_inf,q,S1,S2):
    
    '''
    Find xi and kappa_inf given the asymptotic (constant) values of theta1 and theta2.

    **Call:**

        xi,kappa_inf=precession.from_the_angles_inf(theta1_inf,theta2_inf,q,S1,S2)
    
    **Parameters:**

    - `theta1_inf`: asymptotic value of theta1 at large separations.
    - `theta2_inf`: asymptotic value of theta2 at large separations.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    
    **Returns:**

    - `xi`: projection of the effective spin along the orbital angular momentum.
    - `kappa_inf`: asymptotic value of kappa at large separations.
    '''
    
    if q==1:
        print "[from_the_angles_inf] Error: I'm sorry, can't run for q=1. The angles theta1 and theta2 are not constant at large separations."
        sys.exit()
    else:
        xi= ((1.+q)*S1*np.cos(theta1_inf)+(1.+q**-1)*S2*np.cos(theta2_inf))*M**-2
        kappa_inf= (S1*np.cos(theta1_inf)+S2*np.cos(theta2_inf))*M**-2
        return xi,kappa_inf
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.ftor">
    <p>def <span class="ident">ftor</span>(</p><p>f, M_msun)</p>
    </div>
    

    
  
    <div class="desc"><p>Conversion between binary separation r (in mass unit) and emitted GW
frequency f (in Hertz). We use the Newtonian expression:
f^2 = G M / (pi^2 r^3) in cgs units. Mass units: r--&gt; GMr/c^2</p>
<p><strong>Call:</strong></p>
<pre><code>r=precession.ftor(f,M_msun)
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>f</code>: emitted GW frequency in Hertz.</li>
<li><code>M_msun</code>: binary total mass in solar masses.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>r</code>: binary separation.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.ftor', this);">Show source &equiv;</a></p>
  <div id="source-precession.ftor" class="source">
    <pre><code>def ftor(f,M_msun):
    
    '''
    Conversion between binary separation r (in mass unit) and emitted GW
    frequency f (in Hertz). We use the Newtonian expression:
    f^2 = G M / (pi^2 r^3) in cgs units. Mass units: r--> GMr/c^2
 
    **Call:**

        r=precession.ftor(f,M_msun)

    **Parameters:**
    
    - `f`: emitted GW frequency in Hertz.
    - `M_msun`: binary total mass in solar masses.

    **Returns:**

    - `r`: binary separation.
    '''

 
    
    M_cgs=M_msun*(2e33)
    c_cgs=2.99e10
    G_cgs=6.67e-8
    r=pow(pow(c_cgs,3.),2./3.)*pow(math.pi*f*G_cgs*M_cgs,-2./3.)
    return r
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.get_fixed">
    <p>def <span class="ident">get_fixed</span>(</p><p>q, chi1, chi2)</p>
    </div>
    

    
  
    <div class="desc"><p>Compute individual masses and spins, from mass ratio (q&lt;1) and
dimensionless spins (0&lt;chi&lt;1).</p>
<p><strong>Call:</strong></p>
<pre><code>M,m1,m2,S1,S2=precession.get_fixed(q,chi1,chi2)
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>chi1</code>: dimensionless spin magnitude of the primary BH. Must be 0&lt;chi1&lt;1.</li>
<li><code>chi2</code>: dimensionless spin magnitude of the secondary BH. Must be 0&lt;chi2&lt;1.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>M</code>: total mass of the binary (set to 1).</li>
<li><code>m1</code>: mass of the primary BH.</li>
<li><code>m2</code>: mass of the secondary BH.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.get_fixed', this);">Show source &equiv;</a></p>
  <div id="source-precession.get_fixed" class="source">
    <pre><code>def get_fixed(q,chi1,chi2):
    
    '''
    Compute individual masses and spins, from mass ratio (q<1) and
    dimensionless spins (0<chi<1).

    **Call:**

        M,m1,m2,S1,S2=precession.get_fixed(q,chi1,chi2)
    
    **Parameters:**
    
    - `q`: binary mass ratio. Must be q<=1.
    - `chi1`: dimensionless spin magnitude of the primary BH. Must be 0<chi1<1.
    - `chi2`: dimensionless spin magnitude of the secondary BH. Must be 0<chi2<1.

    **Returns:**
    
    - `M`: total mass of the binary (set to 1).
    - `m1`: mass of the primary BH.
    - `m2`: mass of the secondary BH.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    '''
    
    global M
    m1=M/(1.+q) # Primary mass
    m2=q*M/(1.+q) # Secondary mass
    S1=chi1*m1**2 # Primary spin magnitude
    S2=chi2*m2**2 # Secondary spin magnitude
    return M,m1,m2,S1,S2
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.get_varphi">
    <p>def <span class="ident">get_varphi</span>(</p><p>xi, S, J, q, S1, S2, r, sign=1)</p>
    </div>
    

    
  
    <div class="desc"><p>Compute varphi from a given xi. This can be seen as the inverse of xi_contour. If phase==1 (default) return varphi in [0,pi], if sign==-1 return varphi in [-pi,0].    </p>
<p>WARKNING: Don't run for q=1, as varphi is independent of S in this limit.</p>
<p><strong>Call:</strong></p>
<pre><code>varphi=precession.get_varphi(xi,S,J,q,S1,S2,r,sign=1)
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>S</code>: magnitude of the total spin.</li>
<li><code>J</code>: magnitude of the total angular momentum.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>r</code>: binary separation.</li>
<li><code>sign</code>: if 1 return angle in [0,pi], if -1 return angle in [-pi,0].</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>varphi</code>: angle describing the rotation of S1 and S2 about S, in a frame aligned with J.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.get_varphi', this);">Show source &equiv;</a></p>
  <div id="source-precession.get_varphi" class="source">
    <pre><code>def get_varphi(xi,S,J,q,S1,S2,r,sign=1):

    '''
    Compute varphi from a given xi. This can be seen as the inverse of xi_contour. If phase==1 (default) return varphi in [0,pi], if sign==-1 return varphi in [-pi,0].    

    WARKNING: Don't run for q=1, as varphi is independent of S in this limit.

    **Call:**

        varphi=precession.get_varphi(xi,S,J,q,S1,S2,r,sign=1)
    
    **Parameters:**
    
    - `xi`: projection of the effective spin along the orbital angular momentum.
    - `S`: magnitude of the total spin.
    - `J`: magnitude of the total angular momentum.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `r`: binary separation.
    - `sign`: if 1 return angle in [0,pi], if -1 return angle in [-pi,0].

    **Returns:**

    - `varphi`: angle describing the rotation of S1 and S2 about S, in a frame aligned with J.
    '''

    if q==1:
        print "[get_varphi] Error: I'm sorry, can't run for q=1. S is degenerate with varphi."
        sys.exit()

    L=(q/(1.+q)**2)*(r*M**3)**.5
    t1=(1.+q)/(4.*q*M**2*S**2*L)
    t2=J**2-L**2-S**2
    t3=S**2*(1.+q)-(S1**2-S2**2)*(1.-q)
    t4=(1.-q)*((L+S)**2-J**2)**.5
    t5=(J**2-(L-S)**2)**.5             
    t6=((S1+S2)**2-S**2)**.5
    t7=(S**2-(S1-S2)**2)**.5
    cosvarphi= ((t2*t3)-(xi/t1))/(t4*t5*t6*t7)
    
    return np.arccos(cosvarphi)*sign
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.hybrid">
    <p>def <span class="ident">hybrid</span>(</p><p>xi_vals, kappainf_vals, r_vals, q, S1, S2, r_t)</p>
    </div>
    

    
  
    <div class="desc"><p>Hybrid inspiral. Evolve a binary FROM INIFINITELY large separations (as specified by kappa_inf and xi) till the threshold r_transition using the precession-averaged approach, and then from r_transition to the end of the inspiral using an orbit-averaged integration to track the precessional phase. </p>
<p>Parallelization is implemented through the python parmap module; the number of available cores can be specified using the integer global variable <code>CPUs</code> (all available cores will be used by default). Evolve a sequence of binaries with the SAME q, S1,S2 but different xi and kappa_inf; save outputs at r_vals. </p>
<p>The initial condition is NOT returned by this function. Outputs are given in terms of the angles theta1, theta2 and deltaphi as 2D arrays, where e.g theta1_fvals[0] is the first binary (1D array at all output separations) and theta1_fvals[0][0] is the first binary at the first output separation (this is a scalar).</p>
<p><strong>Call:</strong></p>
<pre><code>theta1f_vals,theta2f_vals,deltaphif_vals=precession.hybrid(xi_vals,kappainf_vals,r_vals,q,S1,S2,r_t)
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>xi_vals</code>: projection of the effective spin along the orbital angular momentum (array).</li>
<li><code>kappainf_vals</code>: asymtotic value of kappa at large separations (array).</li>
<li><code>r_vals</code>: binary separation (array).</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>r_transition</code>: transition radius between orbit- and precession-averaged approach.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>theta1f_vals</code>: solutions for theta1 (2D array).</li>
<li><code>theta2f_vals</code>: solutions for theta2 (2D array).</li>
<li><code>deltaphif_vals</code>: solutions for deltaphi (2D array).</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.hybrid', this);">Show source &equiv;</a></p>
  <div id="source-precession.hybrid" class="source">
    <pre><code>def hybrid(xi_vals,kappainf_vals,r_vals,q,S1,S2,r_t):
 
    '''
    Hybrid inspiral. Evolve a binary FROM INIFINITELY large separations (as specified by kappa_inf and xi) till the threshold r_transition using the precession-averaged approach, and then from r_transition to the end of the inspiral using an orbit-averaged integration to track the precessional phase. 
    
    Parallelization is implemented through the python parmap module; the number of available cores can be specified using the integer global variable `CPUs` (all available cores will be used by default). Evolve a sequence of binaries with the SAME q, S1,S2 but different xi and kappa_inf; save outputs at r_vals. 
    
    The initial condition is NOT returned by this function. Outputs are given in terms of the angles theta1, theta2 and deltaphi as 2D arrays, where e.g theta1_fvals[0] is the first binary (1D array at all output separations) and theta1_fvals[0][0] is the first binary at the first output separation (this is a scalar).
 
    **Call:**

        theta1f_vals,theta2f_vals,deltaphif_vals=precession.hybrid(xi_vals,kappainf_vals,r_vals,q,S1,S2,r_t)

    **Parameters:**
    
    - `xi_vals`: projection of the effective spin along the orbital angular momentum (array).
    - `kappainf_vals`: asymtotic value of kappa at large separations (array).
    - `r_vals`: binary separation (array).
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `r_transition`: transition radius between orbit- and precession-averaged approach.

    **Returns:**

    - `theta1f_vals`: solutions for theta1 (2D array).
    - `theta2f_vals`: solutions for theta2 (2D array).
    - `deltaphif_vals`: solutions for deltaphi (2D array).
    '''



    global CPUs
    global flags_q1
    if q==1:
        if flags_q1[13]==False:
            print "[hybrid] Warning q=1: required intial condition is S, not kappa_inf."
            flags_q1[13]=True # Suppress future warnings

    single_flag=False

    try: #Convert float to array if you're evolving just one binary 
        len(xi_vals)
        len(kappainf_vals)
    except:
        single_flag=True
        xi_vals=[xi_vals]
        kappainf_vals=[kappainf_vals]

    try: # Set defaults
        CPUs
    except:
        CPUs=0
        print "[hybrid] Default parallel computation"

    loopflag=True
    while loopflag: # Restart is some of the cores crashed. This happend if you run too many things on too many different machines. Nevermind, trash the file and do it again. 
        loopflag=False 

        #Parallelization
        if CPUs==0: #Run on all cpus on the current machine! (default option) 
            filelist=parmap.starmap(hybrid_single, zip(xi_vals,kappainf_vals),r_vals,q,S1,S2,r_t,parallel=True)
        elif CPUs==1: #1 cpus done by explicitely removing parallelization 
            filelist=parmap.starmap(hybrid_single, zip(xi_vals,kappainf_vals),r_vals,q,S1,S2,r_t,parallel=False)
        else: # Run on a given number of CPUs
            p = multiprocessing.Pool(CPUs)
            filelist=parmap.starmap(hybrid_single, zip(xi_vals,kappainf_vals),r_vals,q,S1,S2,r_t,pool=p)

        theta1_fvals=[]
        theta2_fvals=[]
        deltaphi_fvals=[]
        for index, file in enumerate(filelist):
            print "[hybrid] Reading:", index, file
            numlines=sum(1 for line in open(file))
            if numlines!=0 and numlines!=len(r_vals): # Restart if core(s) crashed 
                print "[hybrid] Error on file", file,". Jobs are being restarted!"
                os.system("rm "+file)
                loopflag=True

            else:
                dummy,theta1_f,theta2_f,deltaphi_f= np.loadtxt(file,unpack=True)
                theta1_fvals.append(theta1_f)
                theta2_fvals.append(theta2_f)
                deltaphi_fvals.append(deltaphi_f)
    if single_flag==True:
        return theta1_fvals[0], theta2_fvals[0], deltaphi_fvals[0]
    else:
        return theta1_fvals, theta2_fvals, deltaphi_fvals
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.hybrid_single">
    <p>def <span class="ident">hybrid_single</span>(</p><p>xi, kappa_inf, r_vals, q, S1, S2, r_t)</p>
    </div>
    

    
  
    <div class="desc"><p>Auxiliary function, see <code>hybrid</code>.</p>
<p><strong>Call:</strong></p>
<pre><code>savename=precession.hybrid_single(xi,kappa_inf,r_vals,q,S1,S2,r_t)
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>kappa_inf</code>: asymtotic value of kappa at large separations.</li>
<li><code>r_vals</code>: binary separation (array).</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>r_transition</code>: transition radius between orbit- and precession-averaged approach.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>savename</code>: checkpoint filename.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.hybrid_single', this);">Show source &equiv;</a></p>
  <div id="source-precession.hybrid_single" class="source">
    <pre><code>def hybrid_single(xi,kappa_inf,r_vals,q,S1,S2,r_t):
    
    '''
    Auxiliary function, see `hybrid`.
 
    **Call:**

        savename=precession.hybrid_single(xi,kappa_inf,r_vals,q,S1,S2,r_t)

    **Parameters:**
    
    - `xi`: projection of the effective spin along the orbital angular momentum.
    - `kappa_inf`: asymtotic value of kappa at large separations.
    - `r_vals`: binary separation (array).
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `r_transition`: transition radius between orbit- and precession-averaged approach.

    **Returns:**

    - `savename`: checkpoint filename.
    '''

    os.system("mkdir -p "+storedir) 
    savename= storedir+"/hybrid_"+'_'.join([str(x) for x in (xi,kappa_inf,max(r_vals),min(r_vals),len(r_vals),q,S1,S2,r_t)])+".dat"

    if not os.path.isfile(savename):
        print "[hybrid] Transferring binary. Output:", savename
        outfilesave = open(savename,"w",0)

        # Split the output separations: precession-average before r_t and orbit-average after it         
        r_vals_pa=[r for r in r_vals if r>r_t]
        r_vals_oa=[r for r in r_vals if r<=r_t] # Keep r_t (if present) in the orbit-average part

        if not [r for r in r_vals_oa if r==r_t]: # If there's nothing but r_t in the orbit-averaged part
            print "[hybrid] No output required below r_t. You don't need a hybrid integration, use evolve_J_infinity instead"
            sys.exit()

        # Add the threshold at the end of the precession-average part and at the beginning of the orbit-average part
        r_vals_pa.append(r_t)
        r_vals_oa.insert(0,r_t)  

        # Evolve from r=infinity to r=r_t using precession-averaged integration
        J_vals_pa=Jofr_infinity(xi,kappa_inf,r_vals_pa,q,S1,S2)

        # Store the angles theta1, theta2 and deltaphi (need S resampling at each output separation)
        # Don't use the latest values in the arrays, because you added one value at the end earlier on
        for J_f,r_f in zip(J_vals_pa[:-1],r_vals_pa[:-1]):           
          
            S_f=samplingS(xi,J_f,q,S1,S2,r_f)
            theta1_f,theta2_f,deltaphi_f,dummy = parametric_angles(S_f,J_f,xi,q,S1,S2,r_f)
            deltaphi_f*=random.choice([-1., 1.])
            outfilesave.write(str(r_f)+" "+str(theta1_f)+" "+str(theta2_f)+" "+str(deltaphi_f)+"\n")        

        # Last S resampling at r=r_t
        S_t=samplingS(xi,J_vals_pa[-1],q,S1,S2,r_t)
        
        # Evolve from r_t to min(r_vals) using orbit-average integration
        Lhx_vals_oa,Lhy_vals_oa,Lhz_vals_oa,S1hx_vals_oa,S1hy_vals_oa,S1hz_vals_oa,S2hx_vals_oa,S2hy_vals_oa,S2hz_vals_oa = orbav_integrator(J_vals_pa[-1],xi,S_t,r_vals_oa,q,S1,S2)

        # Store the angles theta1, theta2 and deltaphi (S resampling not needed)
        # Don't use the first values in the arrays, because you added one value at on top earlier on
        for r_f,Lhx,Lhy,Lhz,S1hx,S1hy,S1hz,S2hx,S2hy,S2hz in zip(r_vals_oa[1:],Lhx_vals_oa[1:],Lhy_vals_oa[1:],Lhz_vals_oa[1:],S1hx_vals_oa[1:],S1hy_vals_oa[1:],S1hz_vals_oa[1:],S2hx_vals_oa[1:],S2hy_vals_oa[1:],S2hz_vals_oa[1:]):
            L_f=(q/(1.+q)**2)*(r_f*M**3)**.5
            S_f=((S1*S1hx+S2*S2hx)**2 + (S1*S1hy+S2*S2hy)**2 + (S1*S1hz+S2*S2hz)**2 )**0.5
            J_f=((L_f*Lhx+S1*S1hx+S2*S2hx)**2 + (L_f*Lhy+S1*S1hy+S2*S2hy)**2 + (L_f*Lhz+S1*S1hz+S2*S2hz)**2 )**0.5
            xi_f=((1.+q)*S1*(Lhx*S1hx+Lhy*S1hy+Lhz*S1hz)+(1.+q**-1)*S2*(Lhx*S2hx+Lhy*S2hy+Lhz*S2hz))*M**-2
            if q==1: # You need to compute varphi, not S
                A1=np.sqrt(J_f**2-(L_f-S_f)**2)
                A2=np.sqrt((L_f+S_f)**2-J_f**2)
                A3=np.sqrt(S_f**2-(S1-S2)**2)
                A4=np.sqrt((S1+S2)**2-S_f**2)  
                cosvarphi=(4*J_f*S_f**2*S1hz*S1-(S_f**2+S1**2-S2**2)*(J_f**2-L_f**2+S_f**2))/(A1*A2*A3*A4)
                S_f=cosvarphi 
            
            theta1_f,theta2_f,deltaphi_f,dummy= parametric_angles(S_f,J_f,xi_f,q,S1,S2,r_f)
            # Track the precessional phase to set the sign of DeltaPhi. In symbols, the sign of DeltaPhi must be the sign of
            #L dot [ ( S1 - (S1 dot L) dot L ) cross ( S2 - (S2 dot L) dot L ) ]
            S1px=(S1hx-theta1_f*Lhx)
            S1py=(S1hy-theta1_f*Lhy)
            S1pz=(S1hz-theta1_f*Lhz)
            S2px=(S2hx-theta2_f*Lhx)
            S2py=(S2hy-theta2_f*Lhy)
            S2pz=(S2hz-theta2_f*Lhz)
            proj=Lhx*(S1py*S2pz-S1pz*S2py) + Lhy*(S1pz*S2px-S1px*S2pz) + Lhz*(S1px*S2py-S1py*S2px)
            deltaphi_f*=math.copysign(1., proj)
            
            outfilesave.write(str(r_f)+" "+str(theta1_f)+" "+str(theta2_f)+" "+str(deltaphi_f)+"\n")
        outfilesave.close()
        
    return savename
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.kappa_backwards">
    <p>def <span class="ident">kappa_backwards</span>(</p><p>xi, J, r, q, S1, S2)</p>
    </div>
    

    
  
    <div class="desc"><p>Single integration of the dJ/dL equation to perfom precession-averaged inspiral. Input/output are provided in J and r, but the internal integrator uses kappa and u (see <a href="#precession.dkappadu"><code>dkappadu</code></a>). Integration is performed using scipy's <code>odeint</code>.</p>
<p>This function integrates from some finite separation TO INFINITE separation (u=0) only.    </p>
<p>The initial binary is specified at the input separation r through J and xi (S not needed).
The binary is evolved backwards to r=infinity (u=0) and the asymptotic value kappa_inf is returned. If q=1, kappa_inf is degenerate with xi: the constant value of S is returned instead.</p>
<p>We recommend to use this function through the wrapper <a href="#precession.evolve_J_backwards"><code>evolve_J_backwards</code></a> provided.</p>
<p><strong>Call:</strong></p>
<pre><code>kappa_inf=precession.kappa_backwards(xi,J,r,q,S1,S2)
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>J</code>: magnitude of the total angular momentum.</li>
<li><code>r</code>: binary separation.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>kappa_inf</code>: asymptotic value of kappa at large separations.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.kappa_backwards', this);">Show source &equiv;</a></p>
  <div id="source-precession.kappa_backwards" class="source">
    <pre><code>def kappa_backwards(xi,J,r,q,S1,S2):

    '''
    Single integration of the dJ/dL equation to perfom precession-averaged inspiral. Input/output are provided in J and r, but the internal integrator uses kappa and u (see `precession.dkappadu`). Integration is performed using scipy's `odeint`.
    
    This function integrates from some finite separation TO INFINITE separation (u=0) only.    

    The initial binary is specified at the input separation r through J and xi (S not needed).
    The binary is evolved backwards to r=infinity (u=0) and the asymptotic value kappa_inf is returned. If q=1, kappa_inf is degenerate with xi: the constant value of S is returned instead.

    We recommend to use this function through the wrapper `precession.evolve_J_backwards` provided.
 
    **Call:**

        kappa_inf=precession.kappa_backwards(xi,J,r,q,S1,S2)

    **Parameters:**

    - `xi`: projection of the effective spin along the orbital angular momentum.
    - `J`: magnitude of the total angular momentum.
    - `r`: binary separation.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.

    **Returns:**

    - `kappa_inf`: asymptotic value of kappa at large separations.
    '''

    L=(q/(1.+q)**2)*(r*M**3)**.5

    global flags_q1
    if q==1:
        if flags_q1[10]==False:
            print "[kappa_backwards] Warning q=1: sensible output is S, not kappa_inf."
            flags_q1[10]=True # Suppress future warnings
        S=np.sqrt(J**2-L**2-xi*L*M**2)
        return S
    
    else:
        u=1./(2.*L)
        kappa= (J**2 - L**2) / (2.*L)
        u_vals=[u,0.]# Add final condition, r=inifinty u=0
        # Numerical integration to u=0    
        res =integrate.odeint(dkappadu, kappa, u_vals, args=(xi,q,S1,S2), mxstep=50000, full_output=0, printmessg=0)#,tcrit=sing)
        kappa_inf=[x[0] for x in res][-1]
        return kappa_inf
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.kappa_backwards_checkpoint">
    <p>def <span class="ident">kappa_backwards_checkpoint</span>(</p><p>xi, J, r, q, S1, S2)</p>
    </div>
    

    
  
    <div class="desc"><p>Auxiliary function, see <a href="#precession.evolve_J_backwards"><code>evolve_J_backwards</code></a>.</p>
<p><strong>Call:</strong></p>
<pre><code>savename=precession.kappa_backwards_checkpoint(xi,J,r,q,S1,S2)
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>J</code>: magnitude of the total angular momentum.</li>
<li><code>r</code>: binary separation.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>savename</code>: checkpoint filename.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.kappa_backwards_checkpoint', this);">Show source &equiv;</a></p>
  <div id="source-precession.kappa_backwards_checkpoint" class="source">
    <pre><code>def kappa_backwards_checkpoint(xi,J,r,q,S1,S2):

    '''
    Auxiliary function, see `precession.evolve_J_backwards`.
 
    **Call:**

        savename=precession.kappa_backwards_checkpoint(xi,J,r,q,S1,S2)

    **Parameters:**

    - `xi`: projection of the effective spin along the orbital angular momentum.
    - `J`: magnitude of the total angular momentum.
    - `r`: binary separation.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.

    **Returns:**

    - `savename`: checkpoint filename.
    '''

    os.system("mkdir -p "+storedir) 
    savename= storedir+"/evback"+'_'.join([str(x) for x in (xi,J,r,q,S1,S2)])+".dat"
        
    if not os.path.isfile(savename):
        print "[evolve_J_backwards] Transferring binary. Output:", savename
        outfilesave = open(savename,"w",0)
       
        kappa_inf=kappa_backwards(xi,J,r,q,S1,S2)
        outfilesave.write(str(kappa_inf))
        outfilesave.close()

    #else:
    #    print "[evolve_J_infinity] Skipping. Output:", savename
    
    return savename
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.kappainf_allowed">
    <p>def <span class="ident">kappainf_allowed</span>(</p><p>xi, q, S1, S2)</p>
    </div>
    

    
  
    <div class="desc"><p>Limits on kappa_inf for a given value of xi, obtained forcing -1&lt;cos(theta_i)&lt;1.</p>
<p><strong>Call:</strong></p>
<pre><code>kappainf_low,kappainf_up=precession.kappainf_allowed(xi,q,S1,S2)
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>kappainf_low</code>: minimum allowed value of kappa_inf, given the input parameters.</li>
<li><code>kappainf_up</code>: maximum allowed value of kappa_inf, given the input parameters.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.kappainf_allowed', this);">Show source &equiv;</a></p>
  <div id="source-precession.kappainf_allowed" class="source">
    <pre><code>def kappainf_allowed(xi,q,S1,S2):

    '''
    Limits on kappa_inf for a given value of xi, obtained forcing -1<cos(theta_i)<1.
 
    **Call:**

        kappainf_low,kappainf_up=precession.kappainf_allowed(xi,q,S1,S2)
    
    **Parameters:**
    
    - `xi`: projection of the effective spin along the orbital angular momentum.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.

    **Returns:**

    - `kappainf_low`: minimum allowed value of kappa_inf, given the input parameters.
    - `kappainf_up`: maximum allowed value of kappa_inf, given the input parameters.
    '''
    
    kappainf_low = max( (xi - (q**-1-q)*S2)/(1+q) , (xi - (q**-1-q)*S1)/(1+q**-1) )
    kappainf_up = min( (xi + (q**-1-q)*S2)/(1+q) , (xi + (q**-1-q)*S1)/(1+q**-1) )
    return kappainf_low,kappainf_up
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.kappainf_lim">
    <p>def <span class="ident">kappainf_lim</span>(</p><p>S1, S2)</p>
    </div>
    

    
  
    <div class="desc"><p>Absolute limits in kappa_inf (asymptotic value of kappa). At large separations, kappa is the projection of the total spin along L.</p>
<p><strong>Call:</strong></p>
<pre><code>kappainf_min,kappainf_max=precession.kappainf_lim(S1,S2)
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>kappainf_min</code>: minimum value of kappa at infinitely large separations.</li>
<li><code>kappainf_max</code>: maximum value of kappa at infinitely large separations.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.kappainf_lim', this);">Show source &equiv;</a></p>
  <div id="source-precession.kappainf_lim" class="source">
    <pre><code>def kappainf_lim(S1,S2):
    
    '''
    Absolute limits in kappa_inf (asymptotic value of kappa). At large separations, kappa is the projection of the total spin along L.

    **Call:**

        kappainf_min,kappainf_max=precession.kappainf_lim(S1,S2)
     
    **Parameters:**
    
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.

    **Returns:**

    - `kappainf_min`: minimum value of kappa at infinitely large separations.
    - `kappainf_max`: maximum value of kappa at infinitely large separations.
    '''
    
    return -(S1+S2), S1+S2
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.make_temp">
    <p>def <span class="ident">make_temp</span>(</p><p>)</p>
    </div>
    

    
  
    <div class="desc"><p>Make an empty directory to store checkpoints. Calling this function is typically not necessary, because the checkpoint directory is created when needed.</p>
<p><strong>Call:</strong></p>
<pre><code>precession.empty_temp()
</code></pre></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.make_temp', this);">Show source &equiv;</a></p>
  <div id="source-precession.make_temp" class="source">
    <pre><code>def make_temp():

    '''
    Make an empty directory to store checkpoints. Calling this function is typically not necessary, because the checkpoint directory is created when needed.

    **Call:**

        precession.empty_temp()
    '''
    
    global storedir
    print "[make_temp] Creating temp directory: "+storedir
    os.system("mkdir -p "+storedir) 
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.orbav_eqs">
    <p>def <span class="ident">orbav_eqs</span>(</p><p>allvars, v, q, S1, S2, eta, m1, m2, chi1, chi2)</p>
    </div>
    

    
  
    <div class="desc"><p>Right-hand side of the orbit-averaged PN equations: d[allvars]/dv=RHS, where allvars is an array with the cartesian components of the unit vectors L, S1 and S2. This function is only the actual system of equations, not the ODE solver. </p>
<p>Equations are the ones reported in Gerosa et al. <a href="http://journals.aps.org/prd/abstract/10.1103/PhysRevD.87.104028">Phys.Rev. D87 (2013) 10, 104028</a>; see references therein. In particular, the quadrupole-monopole term computed by Racine is included. The results presented in Gerosa et al. 2013 actually use additional unpublished terms, that are not listed in the published equations and are NOT included here. Radiation reaction is included up to 3.5PN. </p>
<p>The internal quadrupole_formula flag switches off all PN corrections in radiation reaction. </p>
<p>The integration is carried over in the orbital velocity v (equivalent to the separation), not in time. If an expression for v(t) is needed, the code can be easiliy modified to return time as well.</p>
<p><strong>Call:</strong></p>
<pre><code>allders=precession.orbav_eqs(allvars,v,q,S1,S2,eta,m1,m2,chi1,chi2)
</code></pre>
<p><strong>Parameters:</strong>
- <code>allvars</code>: array of lenght 9 cointaining the initial condition for numerical integration for the components of the unit vectors L, S1 and S2.
- <code>v</code>: orbital velocity.
- <code>q</code>: binary mass ratio. Must be q&lt;=1.
- <code>S1</code>: spin magnitude of the primary BH.
- <code>S2</code>: spin magnitude of the secondary BH.
- <code>eta</code>: symmetric mass ratio.
- <code>m1</code>: mass of the primary BH.
- <code>m2</code>: mass of the secondary BH.
- <code>chi1</code>: dimensionless spin magnitude of the primary BH. Must be 0&lt;chi1&lt;1.
- <code>chi2</code>: dimensionless spin magnitude of the secondary BH. Must be 0&lt;chi1&lt;1.</p>
<p><strong>Returns:</strong></p>
<ul>
<li><code>allders</code>: array of lenght 9 cointaining the derivatives of allvars with respect to the orbital velocity v.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.orbav_eqs', this);">Show source &equiv;</a></p>
  <div id="source-precession.orbav_eqs" class="source">
    <pre><code>def orbav_eqs(allvars,v,q,S1,S2,eta,m1,m2,chi1,chi2):

    '''
    Right-hand side of the orbit-averaged PN equations: d[allvars]/dv=RHS, where allvars is an array with the cartesian components of the unit vectors L, S1 and S2. This function is only the actual system of equations, not the ODE solver. 
    
    Equations are the ones reported in Gerosa et al. [Phys.Rev. D87 (2013) 10, 104028](http://journals.aps.org/prd/abstract/10.1103/PhysRevD.87.104028); see references therein. In particular, the quadrupole-monopole term computed by Racine is included. The results presented in Gerosa et al. 2013 actually use additional unpublished terms, that are not listed in the published equations and are NOT included here. Radiation reaction is included up to 3.5PN. 
    
    The internal quadrupole_formula flag switches off all PN corrections in radiation reaction. 
    
    The integration is carried over in the orbital velocity v (equivalent to the separation), not in time. If an expression for v(t) is needed, the code can be easiliy modified to return time as well.
 
    **Call:**

        allders=precession.orbav_eqs(allvars,v,q,S1,S2,eta,m1,m2,chi1,chi2)

    **Parameters:**
    - `allvars`: array of lenght 9 cointaining the initial condition for numerical integration for the components of the unit vectors L, S1 and S2.
    - `v`: orbital velocity.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `eta`: symmetric mass ratio.
    - `m1`: mass of the primary BH.
    - `m2`: mass of the secondary BH.
    - `chi1`: dimensionless spin magnitude of the primary BH. Must be 0<chi1<1.
    - `chi2`: dimensionless spin magnitude of the secondary BH. Must be 0<chi1<1.

    **Returns:**

    - `allders`: array of lenght 9 cointaining the derivatives of allvars with respect to the orbital velocity v.
    '''

    # Read variables in
    Lhx=allvars[0]
    Lhy=allvars[1]
    Lhz=allvars[2]
    S1hx=allvars[3]
    S1hy=allvars[4]
    S1hz=allvars[5]
    S2hx=allvars[6]
    S2hy=allvars[7]
    S2hz=allvars[8]
    #t=allvars[9] # Uncomment if v(t) is needed

    # Useful variables
    ct1=(Lhx*S1hx+Lhy*S1hy+Lhz*S1hz)
    ct2=(Lhx*S2hx+Lhy*S2hy+Lhz*S2hz)
    ct12=(S1hx*S2hx+S1hy*S2hy+S1hz*S2hz)

    # Spin precession for S1
    Omega1x= eta*v**5*(2.+3.*q/2.)*Lhx/M  \
            + v**6*(S2*S2hx-3.*S2*ct2*Lhx-3.*q*S1*ct1*Lhx)/(2.*M**3)
    Omega1y= eta*v**5*(2.+3.*q/2.)*Lhy/M  \
            + v**6*(S2*S2hy-3.*S2*ct2*Lhy-3.*q*S1*ct1*Lhy)/(2.*M**3)
    Omega1z= eta*v**5*(2.+3.*q/2.)*Lhz/M  \
            + v**6*(S2*S2hz-3.*S2*ct2*Lhz-3.*q*S1*ct1*Lhz)/(2.*M**3)

    dS1hxdt= Omega1y*S1hz - Omega1z*S1hy
    dS1hydt= Omega1z*S1hx - Omega1x*S1hz
    dS1hzdt= Omega1x*S1hy - Omega1y*S1hx

    # Spin precession for S2
    Omega2x= eta*v**5*(2.+3./(2.*q))*Lhx/M  \
            + v**6*(S1*S1hx-3.*S1*ct1*Lhx-3.*S2*ct2*Lhx/q)/(2.*M**3)
    Omega2y= eta*v**5*(2.+3./(2.*q))*Lhy/M  \
            + v**6*(S1*S1hy-3.*S1*ct1*Lhy-3.*S2*ct2*Lhy/q)/(2.*M**3)
    Omega2z= eta*v**5*(2.+3./(2.*q))*Lhz/M  \
            + v**6*(S1*S1hz-3.*S1*ct1*Lhz-3.*S2*ct2*Lhz/q)/(2.*M**3)

    dS2hxdt= Omega2y*S2hz - Omega2z*S2hy
    dS2hydt= Omega2z*S2hx - Omega2x*S2hz
    dS2hzdt= Omega2x*S2hy - Omega2y*S2hx

    # Conservation of angular momentum
    dLhxdt= -1.*v*(S1*dS1hxdt+S2*dS2hxdt)/(eta*M**2)
    dLhydt= -1.*v*(S1*dS1hydt+S2*dS2hydt)/(eta*M**2)
    dLhzdt= -1.*v*(S1*dS1hzdt+S2*dS2hzdt)/(eta*M**2)

    # Radiation reaction
    quadrupole_formula=False
    if quadrupole_formula:
        dvdt= (32.*eta*v**9/(5.*M))
    else:
        dvdt= (32.*eta*v**9/(5.*M))* ( 1.                               \
            - v**2* (743.+924.*eta)/336.                                \
            + v**3* (4.*np.pi                                           \
                     - chi1*ct1*(113.*m1**2/(12.*M**2) + 25.*eta/4. )   \
                     - chi2*ct2*(113.*m2**2/(12.*M**2) + 25.*eta/4. ))  \
            + v**4* (34103./18144. + 13661.*eta/2016. + 59.*eta**2/18.  \
                     + eta*chi1*chi2* (721.*ct1*ct2 - 247.*ct12) /48.   \
                     + ((m1*chi1/M)**2 * (719.*ct1**2-233.))/96.        \
                     + ((m2*chi2/M)**2 * (719.*ct2**2-233.))/96.)       \
            - v**5* np.pi*(4159.+15876.*eta)/672.                       \
            + v**6* (16447322263./139708800. + 16.*np.pi**2/3.          \
                     -1712.*(0.5772156649+np.log(4.*v))/105.            \
                     +(451.*np.pi**2/48. - 56198689./217728.)*eta       \
                     +541.*eta**2/896. - 5605*eta**3/2592.)             \
            + v**7* np.pi*( -4415./4032. + 358675.*eta/6048.            \
                     + 91495.*eta**2/1512.)                             \
            )

    # Integrate in v, not in time
    dtdv=1./dvdt
    dLhxdv=dLhxdt*dtdv
    dLhydv=dLhydt*dtdv
    dLhzdv=dLhzdt*dtdv
    dS1hxdv=dS1hxdt*dtdv
    dS1hydv=dS1hydt*dtdv
    dS1hzdv=dS1hzdt*dtdv
    dS2hxdv=dS2hxdt*dtdv
    dS2hydv=dS2hydt*dtdv
    dS2hzdv=dS2hzdt*dtdv
    
    # Uncomment if v(t) is needed
    #return dLhxdv, dLhydv, dLhzdv, dS1hxdv, dS1hydv, dS1hzdv, dS2hxdv, dS2hydv, dS2hzdv , dtdv
    
    return dLhxdv, dLhydv, dLhzdv, dS1hxdv, dS1hydv, dS1hzdv, dS2hxdv, dS2hydv, dS2hzdv 
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.orbav_integrator">
    <p>def <span class="ident">orbav_integrator</span>(</p><p>J, xi, S, r_vals, q, S1, S2)</p>
    </div>
    

    
  
    <div class="desc"><p>Single orbit-averaged integration. Integrate the system of ODEs specified in <a href="#precession.orbav_eqs"><code>orbav_eqs</code></a>. The initial configuration (at r_vals[0]) is specified through J, xi and S. The components of the unit vectors L, S1 and S2 are returned at the output separations specified by r_vals. The initial values of J and S must be compatible with the initial separation r_vals[0], otherwise an error is raised. Integration is performed in a reference frame in which the z axis is along J and L lies in the x-z plane at the initial separation. Equations are integrated in v (orbital velocity) but outputs are converted to r (separation). </p>
<p>Of course, this can only integrate to/from FINITE separations. </p>
<p>Bear in mind that orbit-averaged integrations are tpically possible from r&lt;10000; integrations from larger separations take a very long time and can occasionally crash. If q=1, the initial binary configuration is specified through cos(varphi), not S.</p>
<p>We recommend to use one of the wrappers <a href="#precession.orbit_averaged"><code>orbit_averaged</code></a> and <a href="#precession.orbit_angles"><code>orbit_angles</code></a> provided.</p>
<p><strong>Call:</strong></p>
<pre><code>Lhx_fvals,Lhy_fvals,Lhz_fvals,S1hx_fvals,S1hy_fvals,S1hz_fvals,S2hx_fvals,S2hy_fvals,S2hz_fvals=precession.orbav_integrator(J,xi,S,r_vals,q,S1,S2)
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>J</code>: magnitude of the total angular momentum.</li>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>S</code>: magnitude of the total spin.</li>
<li><code>r_vals</code>: binary separation (array).</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>Lhx_vals</code>: x component of the unit vector L/|L| (array).</li>
<li><code>Lhy_vals</code>: y component of the unit vector L/|L| (array).</li>
<li><code>Lhz_vals</code>: z component of the unit vector L/|L| (array).</li>
<li><code>S1hx_vals</code>: x component of the unit vector S1/|S1| (array).</li>
<li><code>S1hy_vals</code>: y component of the unit vector S1/|S1| (array).</li>
<li><code>S1hz_vals</code>: z component of the unit vector S1/|S1| (array).</li>
<li><code>S2hx_vals</code>: x component of the unit vector S2/|S2| (array).</li>
<li><code>S2hy_vals</code>: y component of the unit vector S2/|S2| (array).</li>
<li><code>S2hz_vals</code>: z component of the unit vector S2/|S2| (array).</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.orbav_integrator', this);">Show source &equiv;</a></p>
  <div id="source-precession.orbav_integrator" class="source">
    <pre><code>def orbav_integrator(J,xi,S,r_vals,q,S1,S2):
    
    '''
    Single orbit-averaged integration. Integrate the system of ODEs specified in `precession.orbav_eqs`. The initial configuration (at r_vals[0]) is specified through J, xi and S. The components of the unit vectors L, S1 and S2 are returned at the output separations specified by r_vals. The initial values of J and S must be compatible with the initial separation r_vals[0], otherwise an error is raised. Integration is performed in a reference frame in which the z axis is along J and L lies in the x-z plane at the initial separation. Equations are integrated in v (orbital velocity) but outputs are converted to r (separation). 
    
    Of course, this can only integrate to/from FINITE separations. 
    
    Bear in mind that orbit-averaged integrations are tpically possible from r<10000; integrations from larger separations take a very long time and can occasionally crash. If q=1, the initial binary configuration is specified through cos(varphi), not S.
    
    We recommend to use one of the wrappers `precession.orbit_averaged` and `precession.orbit_angles` provided.
 
    **Call:**

        Lhx_fvals,Lhy_fvals,Lhz_fvals,S1hx_fvals,S1hy_fvals,S1hz_fvals,S2hx_fvals,S2hy_fvals,S2hz_fvals=precession.orbav_integrator(J,xi,S,r_vals,q,S1,S2)

    **Parameters:**
    
    - `J`: magnitude of the total angular momentum.
    - `xi`: projection of the effective spin along the orbital angular momentum.
    - `S`: magnitude of the total spin.
    - `r_vals`: binary separation (array).
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.

    **Returns:**

    - `Lhx_vals`: x component of the unit vector L/|L| (array).
    - `Lhy_vals`: y component of the unit vector L/|L| (array).
    - `Lhz_vals`: z component of the unit vector L/|L| (array).
    - `S1hx_vals`: x component of the unit vector S1/|S1| (array).
    - `S1hy_vals`: y component of the unit vector S1/|S1| (array).
    - `S1hz_vals`: z component of the unit vector S1/|S1| (array).
    - `S2hx_vals`: x component of the unit vector S2/|S2| (array).
    - `S2hy_vals`: y component of the unit vector S2/|S2| (array).
    - `S2hz_vals`: z component of the unit vector S2/|S2| (array).   
    '''

    # Get initial condition in a cartesian frame. Use the frame aligned to J at the initial separation
    global flags_q1
    if q==1:
        if flags_q1[11]==False:
            print "[orbav_integrator] Warning q=1: input here is cos(varphi), not S."
            flags_q1[11]=True
    
    L_vals=[(q/(1.+q)**2)*(comp*M**3)**.5 for comp in r_vals]
    v_vals=[(M/comp)**0.5 for comp in r_vals]
    Jvec,Lvec,S1vec,S2vec,dummy=Jframe_projection(xi,S,J,q,S1,S2,r_vals[0])
    
    Lh_initial=[comp/L_vals[0] for comp in Lvec]  
    S1h_initial=[comp/S1 for comp in S1vec]
    S2h_initial=[comp/S2 for comp in S2vec]
    
    #t_initial=0 # Uncomment if v(t) is needed
    allvars_initial=list(Lh_initial)+list(S1h_initial)+list(S2h_initial) #+list([t_initial])

    #Compute these numbers only once
    eta=q/(1.+q)**2 
    m1=M/(1.+q)
    m2=q*M/(1.+q) 
    chi1=S1/m1**2
    chi2=S2/m2**2

    # Actual integration
    res =integrate.odeint(orbav_eqs, allvars_initial, v_vals, args=(q,S1,S2,eta,m1,m2,chi1,chi2), mxstep=5000000, full_output=0, printmessg=0,rtol=1e-12,atol=1e-12)#,tcrit=sing)

    # Unzip output
    traxres=zip(*res)
    Lhx_fvals=traxres[0]
    Lhy_fvals=traxres[1]
    Lhz_fvals=traxres[2]
    S1hx_fvals=traxres[3]
    S1hy_fvals=traxres[4]
    S1hz_fvals=traxres[5]
    S2hx_fvals=traxres[6]
    S2hy_fvals=traxres[7]
    S2hz_fvals=traxres[8]
    #t_fvals=traxres[9] # Uncomment if v(t) is needed
    
    return Lhx_fvals,Lhy_fvals,Lhz_fvals,S1hx_fvals,S1hy_fvals,S1hz_fvals,S2hx_fvals,S2hy_fvals,S2hz_fvals
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.orbav_integrator_checkpoint">
    <p>def <span class="ident">orbav_integrator_checkpoint</span>(</p><p>J, xi, S, r_vals, q, S1, S2)</p>
    </div>
    

    
  
    <div class="desc"><p>Auxiliary function, see <a href="#precession.orbit_averaged"><code>orbit_averaged</code></a> and <a href="#precession.orbit_angles"><code>orbit_angles</code></a>.</p>
<p><strong>Call:</strong></p>
<pre><code>savename=precession.orbav_integrator_checkpoint(J,xi,S,r_vals,q,S1,S2)
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>J</code>: magnitude of the total angular momentum.</li>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>S</code>: magnitude of the total spin.</li>
<li><code>r_vals</code>: binary separation (array).</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>savename</code>: checkpoint filename.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.orbav_integrator_checkpoint', this);">Show source &equiv;</a></p>
  <div id="source-precession.orbav_integrator_checkpoint" class="source">
    <pre><code>def orbav_integrator_checkpoint(J,xi,S,r_vals,q,S1,S2):

    '''
    Auxiliary function, see `precession.orbit_averaged` and `precession.orbit_angles`.
 
    **Call:**

        savename=precession.orbav_integrator_checkpoint(J,xi,S,r_vals,q,S1,S2)

    **Parameters:**

    - `J`: magnitude of the total angular momentum.
    - `xi`: projection of the effective spin along the orbital angular momentum.
    - `S`: magnitude of the total spin.
    - `r_vals`: binary separation (array).
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.

    **Returns:**

    - `savename`: checkpoint filename.
    '''
    
    os.system("mkdir -p "+storedir) 
    savename= storedir+"/orbav_"+'_'.join([str(x) for x in (J,xi,S,max(r_vals),min(r_vals),len(r_vals),q,S1,S2)])+".dat"

    if not os.path.isfile(savename):
        print "[orbit_averaged] Transferring binary. Output:", savename
        outfilesave = open(savename,"w",0)
       
        Lhx_fvals,Lhy_fvals,Lhz_fvals,S1hx_fvals,S1hy_fvals,S1hz_fvals,S2hx_fvals,S2hy_fvals,S2hz_fvals = orbav_integrator(J,xi,S,r_vals,q,S1,S2)

        for r_f,Lhx,Lhy,Lhz,S1hx,S1hy,S1hz,S2hx,S2hy,S2hz in zip(r_vals,Lhx_fvals,Lhy_fvals,Lhz_fvals,S1hx_fvals,S1hy_fvals,S1hz_fvals,S2hx_fvals,S2hy_fvals,S2hz_fvals):        
            
            L_f=(q/(1.+q)**2)*(r_f*M**3)**.5
            J_f= ((L_f*Lhx+S1*S1hx+S2*S2hx)**2 + (L_f*Lhy+S1*S1hy+S2*S2hy)**2 + (L_f*Lhz+S1*S1hz+S2*S2hz)**2 )**0.5 
            xi_f= ((1.+q)*S1*(Lhx*S1hx+Lhy*S1hy+Lhz*S1hz)+(1.+q**-1)*S2*(Lhx*S2hx+Lhy*S2hy+Lhz*S2hz))*M**-2
            S_f= ((S1*S1hx+S2*S2hx)**2 + (S1*S1hy+S2*S2hy)**2 + (S1*S1hz+S2*S2hz)**2 )**0.5
            
            if q==1:
                A1=np.sqrt(J_f**2-(L_f-S_f)**2)
                A2=np.sqrt((L_f+S_f)**2-J_f**2)
                A3=np.sqrt(S_f**2-(S1-S2)**2)
                A4=np.sqrt((S1+S2)**2-S_f**2) 
                cosvarphi = (4*J_f*S_f**2*S1hz*S1-(S_f**2+S1**2-S2**2)*(J_f**2-L_f**2+S_f**2))/(A1*A2*A3*A4)
                S_f=cosvarphi
                
            outfilesave.write(str(r_f)+" "+str(J_f)+" "+str(xi_f)+" "+str(S_f)+"\n")
        outfilesave.close()

    #else:
    #    print "[evolve_J_infinity] Skipping. Output:", savename
    
    return savename
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.orbit_angles">
    <p>def <span class="ident">orbit_angles</span>(</p><p>theta1_vals, theta2_vals, deltaphi_vals, r_vals, q, S1, S2)</p>
    </div>
    

    
  
    <div class="desc"><p>Wrapper of <a href="#precession.orbav_integrator"><code>orbav_integrator</code></a> to enable parallelization through the python parmap module; the number of available cores can be specified using the integer global variable <code>CPUs</code> (all available cores will be used by default). Input/outputs are given in terms of the angles theta1, theta2 and deltaphi. Evolve a sequence of binaries with the SAME q, S1,S2 but different initial values for the angles; save outputs at r_vals. Output is a 2D array, where e.g. theta1_vals[0] is the first binary (1D array at all output separations) and theta1_vals[0][0] is the first binary at the first output separation (this is a scalar).</p>
<p>Checkpointing is implemented: results are stored in <a href="#precession.storedir"><code>storedir</code></a>.</p>
<p><strong>Call:</strong></p>
<pre><code>theta1f_vals,theta2f_vals,deltaphif_vals=precession.orbit_angles(theta1i_vals,theta2i_vals,deltaphii_vals,r_vals,q,S1,S2)
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>theta1i_vals</code>: initial condition for theta1 (array).</li>
<li><code>theta2i_vals</code>: initial condition for theta2 (array).</li>
<li><code>deltaphii_vals</code>: initial condition for deltaphi (array).</li>
<li><code>r_vals</code>: binary separation (array).</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>theta1f_vals</code>: solutions for theta1 (2D array).</li>
<li><code>theta2f_vals</code>: solutions for theta2 (2D array).</li>
<li><code>deltaphif_vals</code>: solutions for deltaphi (2D array).</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.orbit_angles', this);">Show source &equiv;</a></p>
  <div id="source-precession.orbit_angles" class="source">
    <pre><code>def orbit_angles(theta1_vals,theta2_vals,deltaphi_vals,r_vals,q,S1,S2):

    '''
    Wrapper of `precession.orbav_integrator` to enable parallelization through the python parmap module; the number of available cores can be specified using the integer global variable `CPUs` (all available cores will be used by default). Input/outputs are given in terms of the angles theta1, theta2 and deltaphi. Evolve a sequence of binaries with the SAME q, S1,S2 but different initial values for the angles; save outputs at r_vals. Output is a 2D array, where e.g. theta1_vals[0] is the first binary (1D array at all output separations) and theta1_vals[0][0] is the first binary at the first output separation (this is a scalar).
    
    Checkpointing is implemented: results are stored in `precession.storedir`.
 
    **Call:**

        theta1f_vals,theta2f_vals,deltaphif_vals=precession.orbit_angles(theta1i_vals,theta2i_vals,deltaphii_vals,r_vals,q,S1,S2)
         
    **Parameters:**
    
    - `theta1i_vals`: initial condition for theta1 (array).
    - `theta2i_vals`: initial condition for theta2 (array).
    - `deltaphii_vals`: initial condition for deltaphi (array).
    - `r_vals`: binary separation (array).
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.

    **Returns:**

    - `theta1f_vals`: solutions for theta1 (2D array).
    - `theta2f_vals`: solutions for theta2 (2D array).
    - `deltaphif_vals`: solutions for deltaphi (2D array).
    '''

    global CPUs
    flag=False

    try: #Convert float to array, if you're evolving just one binary
        len(theta1_vals)
        len(theta1_vals)
        len(deltaphi_vals)
    except:
        flag=True
        theta1_vals=[theta1_vals]
        theta2_vals=[theta2_vals]
        deltaphi_vals=[deltaphi_vals]

    try:
        CPUs
    except:
        CPUs=0
        print "[orbit_angles] Default parallel computation"

    loopflag=True
    while loopflag: # Restart is some of the cores crashed. This happend if you run too many things on too many different machines. Nevermind, trash the file and do it again.
        loopflag=False

        #Parallelization... python is cool indeed
        if CPUs==0: #Run on all cpus on the current machine! (default option)
            filelist=parmap.starmap(orbit_angles_single, zip(theta1_vals,theta2_vals,deltaphi_vals),r_vals,q,S1,S2,parallel=True) 
        elif CPUs==1: #1 cpus done by explicitely removing parallelization
            filelist=parmap.starmap(orbit_angles_single, zip(theta1_vals,theta2_vals,deltaphi_vals),r_vals,q,S1,S2,parallel=False) 
        else: # Run on a given number of CPUs        
            p = multiprocessing.Pool(CPUs)
            filelist=parmap.starmap(orbit_angles_single, zip(theta1_vals,theta2_vals,deltaphi_vals),r_vals,q,S1,S2,pool=p) 

        theta1_fvals=[]
        theta2_fvals=[]
        deltaphi_fvals=[]
        for index, file in enumerate(filelist):
            print "[orbit_angles] Reading:", index, file
            numlines=sum(1 for line in open(file))
            if numlines!=0 and numlines!=len(r_vals): # Restar if core(s) crashed
                print "[orbit_angles] Error on file", file,". Jobs are being restarting!!!"
                os.system("rm "+file) 
                loopflag=True
 
            else:
                dummy,theta1_f,theta2_f,deltaphi_f= np.loadtxt(file,unpack=True)
                theta1_fvals.append(theta1_f)
                theta2_fvals.append(theta2_f)
                deltaphi_fvals.append(deltaphi_f)        
    if flag==True:
        return theta1_fvals[0], theta2_fvals[0], deltaphi_fvals[0]
    else:
        return theta1_fvals, theta2_fvals, deltaphi_fvals
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.orbit_angles_single">
    <p>def <span class="ident">orbit_angles_single</span>(</p><p>theta1_i, theta2_i, deltaphi_i, r_vals, q, S1, S2)</p>
    </div>
    

    
  
    <div class="desc"><p>Auxiliary function, see <code>orbit_angles</code>.</p>
<p><strong>Call:</strong></p>
<pre><code>savename=precession.orbit_angles_single(theta1_i,theta2_i,deltaphi_i,r_vals,q,S1,S2)
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>theta1_i</code>: initial condition for theta1.</li>
<li><code>theta2_i</code>: initial condition for theta2</li>
<li><code>deltaphi_i</code>: initial condition for deltaphi.</li>
<li><code>r_vals</code>: binary separation (array).</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>savename</code>: checkpoint filename.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.orbit_angles_single', this);">Show source &equiv;</a></p>
  <div id="source-precession.orbit_angles_single" class="source">
    <pre><code>def orbit_angles_single(theta1_i,theta2_i,deltaphi_i,r_vals,q,S1,S2):

    '''
    Auxiliary function, see `orbit_angles`.
 
    **Call:**

        savename=precession.orbit_angles_single(theta1_i,theta2_i,deltaphi_i,r_vals,q,S1,S2)

    **Parameters:**
    
    - `theta1_i`: initial condition for theta1.
    - `theta2_i`: initial condition for theta2
    - `deltaphi_i`: initial condition for deltaphi.
    - `r_vals`: binary separation (array).
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.

    **Returns:**

    - `savename`: checkpoint filename.
    '''

    os.system("mkdir -p "+storedir) 
    savename= storedir+"/orbang_"+'_'.join([str(x) for x in (theta1_i,theta2_i,deltaphi_i,max(r_vals),min(r_vals),len(r_vals),q,S1,S2)])+".dat"
        
    if not os.path.isfile(savename):
        print "[orbit_angles] Transferring binary. Output:", savename
        outfilesave = open(savename,"w",0)
       
        # Step 1. Get xi and J for each intial angle. Keep S now
        xi_i,J_i,S_i= from_the_angles(theta1_i,theta2_i,deltaphi_i,q,S1,S2,r_vals[0]) 
        # Note that S_i is actually cos(varphi_i) when q=1. 
        
        # Step 2. Evolve ODE system
        Lhx_fvals,Lhy_fvals,Lhz_fvals,S1hx_fvals,S1hy_fvals,S1hz_fvals,S2hx_fvals,S2hy_fvals,S2hz_fvals = orbav_integrator(J_i,xi_i,S_i,r_vals,q,S1,S2)
        
        for r_f,Lhx,Lhy,Lhz,S1hx,S1hy,S1hz,S2hx,S2hy,S2hz in zip(r_vals,Lhx_fvals,Lhy_fvals,Lhz_fvals,S1hx_fvals,S1hy_fvals,S1hz_fvals,S2hx_fvals,S2hy_fvals,S2hz_fvals):        
            
            L_f=(q/(1.+q)**2)*(r_f*M**3)**.5
            S_f= ((S1*S1hx+S2*S2hx)**2 + (S1*S1hy+S2*S2hy)**2 + (S1*S1hz+S2*S2hz)**2 )**0.5
            J_f= ((L_f*Lhx+S1*S1hx+S2*S2hx)**2 + (L_f*Lhy+S1*S1hy+S2*S2hy)**2 + (L_f*Lhz+S1*S1hz+S2*S2hz)**2 )**0.5 
            xi_f= ((1.+q)*S1*(Lhx*S1hx+Lhy*S1hy+Lhz*S1hz)+(1.+q**-1)*S2*(Lhx*S2hx+Lhy*S2hy+Lhz*S2hz))*M**-2
            if q==1:
                A1=np.sqrt(J_f**2-(L_f-S_f)**2)
                A2=np.sqrt((L_f+S_f)**2-J_f**2)
                A3=np.sqrt(S_f**2-(S1-S2)**2)
                A4=np.sqrt((S1+S2)**2-S_f**2)  
                cosvarphi = (4*J_f*S_f**2*S1hz*S1-(S_f**2+S1**2-S2**2)*(J_f**2-L_f**2+S_f**2))/(A1*A2*A3*A4)
                S_f=cosvarphi

            # Step 3. Back to theta1, theta2, deltaphi
            theta1_f,theta2_f,deltaphi_f,dummy= parametric_angles(S_f,J_f,xi_f,q,S1,S2,r_f)
            
            # Step 4. Track the precessional phase to set the sign of DeltaPhi. In symbols, the sign of DeltaPhi must be the sign of
            #L dot [ ( S1 - (S1 dot L) dot L ) cross ( S2 - (S2 dot L) dot L ) ]
            S1px=(S1hx-theta1_f*Lhx)
            S1py=(S1hy-theta1_f*Lhy)
            S1pz=(S1hz-theta1_f*Lhz)
            S2px=(S2hx-theta2_f*Lhx)
            S2py=(S2hy-theta2_f*Lhy)
            S2pz=(S2hz-theta2_f*Lhz)
            proj=Lhx*(S1py*S2pz-S1pz*S2py) + Lhy*(S1pz*S2px-S1px*S2pz) + Lhz*(S1px*S2py-S1py*S2px)
            deltaphi_f*=math.copysign(1., proj)

            # Step 4. Store data            
            outfilesave.write(str(r_f)+" "+str(theta1_f)+" "+str(theta2_f)+" "+str(deltaphi_f)+"\n")
        outfilesave.close()

    #else:
    #    print "[evolve_angles] Skipping. Output:", savename
    
    return savename
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.orbit_averaged">
    <p>def <span class="ident">orbit_averaged</span>(</p><p>J_vals, xi_vals, S_vals, r_vals, q, S1, S2)</p>
    </div>
    

    
  
    <div class="desc"><p>Wrapper of <a href="#precession.orbav_integrator"><code>orbav_integrator</code></a> to enable parallelization through the python parmap module; the number of available cores can be specified using the integer global variable <code>CPUs</code> (all available cores will be used by default). Input/outputs are given in terms of J, xi and S. Evolve a sequence of binaries with the SAME q, S1,S2 but different xi and initial values of J and S; save outputs at r_vals. The initial configuration must be compatible with r_vals[0]. Output is a 2D array, where e.g. J_vals[0] is the first binary (1D array at all output separations) and J_vals[0][0] is the first binary at the first output separation (this is a scalar).</p>
<p>Checkpointing is implemented: results are stored in <a href="#precession.storedir"><code>storedir</code></a>.</p>
<p><strong>Call:</strong></p>
<pre><code>Jf_vals,xif_vals,Sf_vals=precession.orbit_averaged(J_vals,xi_vals,S_vals,r_vals,q,S1,S2)
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>Ji_vals</code>: initial condition for J (array).</li>
<li><code>xii_vals</code>: initial condition for xi (array).</li>
<li><code>Si_vals</code>: initial condition for S (array).</li>
<li><code>r_vals</code>: binary separation (array).</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>Jf_vals</code>: solutions for J (2D array).</li>
<li><code>xif_vals</code>: solutions for xi (2D array).</li>
<li><code>Sf_vals</code>: solutions for S (2D array).</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.orbit_averaged', this);">Show source &equiv;</a></p>
  <div id="source-precession.orbit_averaged" class="source">
    <pre><code>def orbit_averaged(J_vals,xi_vals,S_vals,r_vals,q,S1,S2):

    '''
    Wrapper of `precession.orbav_integrator` to enable parallelization through the python parmap module; the number of available cores can be specified using the integer global variable `CPUs` (all available cores will be used by default). Input/outputs are given in terms of J, xi and S. Evolve a sequence of binaries with the SAME q, S1,S2 but different xi and initial values of J and S; save outputs at r_vals. The initial configuration must be compatible with r_vals[0]. Output is a 2D array, where e.g. J_vals[0] is the first binary (1D array at all output separations) and J_vals[0][0] is the first binary at the first output separation (this is a scalar).

    Checkpointing is implemented: results are stored in `precession.storedir`.
 
    **Call:**

        Jf_vals,xif_vals,Sf_vals=precession.orbit_averaged(J_vals,xi_vals,S_vals,r_vals,q,S1,S2)

    **Parameters:**

    - `Ji_vals`: initial condition for J (array).
    - `xii_vals`: initial condition for xi (array).
    - `Si_vals`: initial condition for S (array).
    - `r_vals`: binary separation (array).
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.

    **Returns:**

    - `Jf_vals`: solutions for J (2D array).
    - `xif_vals`: solutions for xi (2D array).
    - `Sf_vals`: solutions for S (2D array).
    '''
    
    global CPUs
    
    global flags_q1 
    if q==1:
        if flags_q1[12]==False:
            print "[orbit_averaged] Warning q=1: Input/output for S is actually cos(varphi)"       
            flags_q1[12]=True

    single_flag=False
    try: #Convert float to array if you're evolving just one binary
        len(J_vals)
        len(xi_vals)
        len(S_vals)
    except:
        J_vals=[J_vals]
        xi_vals=[xi_vals]
        S_vals=[S_vals]
        single_flag=True
    try: # Set default
        CPUs
    except:
        CPUs=0
        print "[orbit_averaged] Default parallel computation"
    
    # Parallelization
    if CPUs==0: # Run on all cpus on the current machine! (default option)
        filelist=parmap.starmap(orbav_integrator_checkpoint, zip(J_vals,xi_vals,S_vals),r_vals,q,S1,S2,parallel=True) 
    elif CPUs==1: # 1 cpus done by explicitely removing parallelization
        filelist=parmap.starmap(orbav_integrator_checkpoint, zip(J_vals,xi_vals,S_vals),r_vals,q,S1,S2,parallel=False) 
    else: # Run on a given number of CPUs        
        p = multiprocessing.Pool(CPUs)
        filelist=parmap.starmap(orbav_integrator_checkpoint, zip(J_vals,xi_vals,S_vals),r_vals,q,S1,S2,pool=p) 

    J_fvals=[]
    S_fvals=[]
    xi_vals=[]
    for index, file in enumerate(filelist):
        print "[orbit_averaged] Reading:", index, file
        dummy,J_f,xi_f,S_f= np.loadtxt(file,unpack=True)
        J_fvals.append(J_f)
        S_fvals.append(S_f)
        xi_vals.append(xi_f)

    if single_flag==True:
        return J_fvals[0], xi_vals[0], S_fvals[0]
    else:
        return J_fvals, xi_vals, S_fvals
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.parametric_angles">
    <p>def <span class="ident">parametric_angles</span>(</p><p>S, J, xi, q, S1, S2, r)</p>
    </div>
    

    
  
    <div class="desc"><p>Compute the angles theta1,theta2,deltaphi and theta12, given S, J and xi. 
Roundoff errors are fixed forcing cosines to be in [-1,1]. 
The thetas are polar angles in [0,pi]. Deltaphi is an azimuthal angle, in principle lies in [-pi,pi]. Here we assumed DeltaPhi to be in [0,pi] as returned by arcccos: one may
need to add a sign, depending on the actual application of this function
(see e.g. <a href="#precession.orbit_angles"><code>orbit_angles</code></a> below). This function can be seen as the inverse of <a href="#precession.from_the_angles"><code>from_the_angles</code></a>. In the equal-mass limit q=1, S doesn't
parametrize the precessional motion; we track the binary precession using
varphi explicitly.</p>
<p><strong>Call:</strong></p>
<pre><code>theta1,theta2,deltaphi,theta12=precession.parametric_angles(S,J,xi,q,S1,S2,r)
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>S</code>: magnitude of the total spin.   </li>
<li><code>J</code>: magnitude of the total angular momentum.</li>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>r</code>: binary separation.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>theta1</code>: angle between the spin of the primary and the orbital angular momentum.</li>
<li><code>theta2</code>: angle between the spin of the secondary and the orbital angular momentum.</li>
<li><code>deltaphi</code>: angle between the projection of the two spins on the orbital plane.</li>
<li><code>theta12</code>: angle between the two spins.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.parametric_angles', this);">Show source &equiv;</a></p>
  <div id="source-precession.parametric_angles" class="source">
    <pre><code>def parametric_angles(S,J,xi,q,S1,S2,r):
    
    '''
    Compute the angles theta1,theta2,deltaphi and theta12, given S, J and xi. 
    Roundoff errors are fixed forcing cosines to be in [-1,1]. 
    The thetas are polar angles in [0,pi]. Deltaphi is an azimuthal angle, in principle lies in [-pi,pi]. Here we assumed DeltaPhi to be in [0,pi] as returned by arcccos: one may
    need to add a sign, depending on the actual application of this function
    (see e.g. `precession.orbit_angles` below). This function can be seen as the inverse of `precession.from_the_angles`. In the equal-mass limit q=1, S doesn't
    parametrize the precessional motion; we track the binary precession using
    varphi explicitly.

    **Call:**

        theta1,theta2,deltaphi,theta12=precession.parametric_angles(S,J,xi,q,S1,S2,r)

    **Parameters:**
    
    - `S`: magnitude of the total spin.   
    - `J`: magnitude of the total angular momentum.
    - `xi`: projection of the effective spin along the orbital angular momentum.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `r`: binary separation.

    **Returns:**

    - `theta1`: angle between the spin of the primary and the orbital angular momentum.
    - `theta2`: angle between the spin of the secondary and the orbital angular momentum.
    - `deltaphi`: angle between the projection of the two spins on the orbital plane.
    - `theta12`: angle between the two spins.
    '''
    
    L=(q/(1.+q)**2)*(r*M**3)**.5

    global flags_q1    
    if q==1:
        if flags_q1[0]==False:
            print "[parametric_angles] Warning q=1: input here is cos(varphi), not S."
            flags_q1[0]=True # Suppress future warnings
        cosvarphi=S # The input variable is actually cos(varphi)
        S=(J**2-L**2-xi*L*M**2)**.5
        t4=J**2-(L-S)**2
        t5=(L+S)**2-J**2
        t6=(S1+S2)**2-S**2
        t7=S**2-(S1-S2)**2        
        B=max(0,t4*t5*t6*t7)
        costheta1= (1/(4*S1*S**2*L))*((J**2-L**2-S**2)*(S**2+S1**2-S2**2)+np.sqrt(B)*cosvarphi)
        costheta2= (1/(4*S2*S**2*L))*((J**2-L**2-S**2)*(S**2+S2**2-S1**2)-np.sqrt(B)*cosvarphi)
    
    else:
        costheta1= ( ((J**2-L**2-S**2)/L) - (2.*q*M**2*xi)/(1.+q) )/(2.*(1.-q)*S1)
        costheta2= ( ((J**2-L**2-S**2)*(-q/L)) + (2.*q*M**2*xi)/(1.+q) )/(2.*(1.-q)*S2)

    # Force all cosines in [-1,1].
    costheta1=max(-1,min(costheta1,1.))
    theta1=np.arccos(costheta1)
    costheta2=max(-1,min(costheta2,1.))
    theta2=np.arccos(costheta2)
    costheta12=(S**2-S1**2-S2**2)/(2.*S1*S2)
    costheta12=max(-1,min(costheta12,1.))
    theta12=np.arccos(costheta12)
    cosdeltaphi= (costheta12 - costheta1*costheta2)/(np.sin(theta1)*np.sin(theta2))    
    cosdeltaphi=max(-1,min(cosdeltaphi,1.))
    deltaphi=np.arccos(cosdeltaphi)
    
    return theta1,theta2,deltaphi,theta12
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.phase_checker">
    <p>def <span class="ident">phase_checker</span>(</p><p>q, S1, S2, r, verbose=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Computes the number of different morphologies you MAY have for a given geometrical configuration (i.e. given the lengths of the vectors L, S1 and S2). These are just geometrical constraints: the actual number of allowed morphologies depends on J, as returned by <a href="#precession.phase_xi"><code>phase_xi</code></a>, but it can't be out of what returned by this function. This function is basically a sanity check for <a href="#precession.phase_xi"><code>phase_xi</code></a>.</p>
<p><strong>Call:</strong></p>
<pre><code>phases_vals=precession.phase_checker(q,S1,S2,r,verbose=False)
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>r</code>: binary separation.</li>
<li><code>verbose</code>: if True print additional information.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li>phases_vals: number of coexisting morphologies: 1 if only the DeltaPhi~pi phase is present; 2 if two DeltaPhi~pi phases and a circulating phase are present; 3 if a librating DeltaPhi~0, a circulating, and a DeltaPhi~pi phase al all present (array).</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.phase_checker', this);">Show source &equiv;</a></p>
  <div id="source-precession.phase_checker" class="source">
    <pre><code>def phase_checker(q,S1,S2,r,verbose=False):
    
    '''
    Computes the number of different morphologies you MAY have for a given geometrical configuration (i.e. given the lengths of the vectors L, S1 and S2). These are just geometrical constraints: the actual number of allowed morphologies depends on J, as returned by `precession.phase_xi`, but it can't be out of what returned by this function. This function is basically a sanity check for `precession.phase_xi`.

    **Call:**

        phases_vals=precession.phase_checker(q,S1,S2,r,verbose=False)
    
    **Parameters:**

    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `r`: binary separation.
    - `verbose`: if True print additional information.

    **Returns:**

    - phases_vals: number of coexisting morphologies: 1 if only the DeltaPhi~pi phase is present; 2 if two DeltaPhi~pi phases and a circulating phase are present; 3 if a librating DeltaPhi~0, a circulating, and a DeltaPhi~pi phase al all present (array).
    '''

    L=(q/(1.+q)**2)*(r*M**3)**.5
    
    if L > S1 + S2:
        if verbose:
            print "L > S1 + S2 : 3"
        phases=[3]
    
    elif (S1 + S2 > L and L > max(S1, S2)):
        if verbose:
            print "S1 + S2 > L > max(S1, S2) : 3,1"
        phases=[3,1]

    elif (max(S1,S2) > L and  L>np.abs(S1-S2)):
        if verbose:
            print "max(S1,S2) > L > |S1-S2| : 3,2,1"
        phases=[3,2,1]
    
    elif np.abs(S1-S2) > L:
        if verbose:
            print "|S1 - S2| > L : 3,2"
        phases=[3,2]

    else:
        print "[phase_checker] Error. You should never be here!"        
        sys.exit()
        
    return phases
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.phase_xi">
    <p>def <span class="ident">phase_xi</span>(</p><p>J, q, S1, S2, r)</p>
    </div>
    

    
  
    <div class="desc"><p>Return an integer number, phases, specifying the number of precessional morphologies that can coexist for a given value of J. Returns:</p>
<ul>
<li>1 if only the DeltaPhi~pi phase is present;</li>
<li>2 if two DeltaPhi~pi phases and a circulating phase are present;</li>
<li>3 if a librating DeltaPhi~0, a circulating, and a DeltaPhi~pi phase al all present.</li>
</ul>
<p>The latter is <em>standard</em> case studied in <a href="http://journals.aps.org/prl/abstract/10.1103/PhysRevLett.114.081103">our first PRL</a>. Additionally, return the values of xi that, for given J, separate the binaries with different morphologies. If there are no transitions (i.e. phase=1), the transition values of xi are returned as Nones. If transitions cannot be found for numerical reasons, assume they coincides with the extrema of xi (see <a href="#precession.xi_allowed"><code>xi_allowed</code></a>). The output of this function can be tested with <a href="#precession.phase_checker"><code>phase_checker</code></a>.</p>
<p><strong>Call:</strong></p>
<pre><code>phases=precession.phase_xi(J,q,S1,S2,r)
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>J</code>: magnitude of the total angular momentum.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>r</code>: binary separation.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li>phases: number of coexisting morphologies: 1 if only the DeltaPhi~pi phase is present; 2 if two DeltaPhi~pi phases and a circulating phase are present; 3 if a librating DeltaPhi~0, a circulating, and a DeltaPhi~pi phase al all present.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.phase_xi', this);">Show source &equiv;</a></p>
  <div id="source-precession.phase_xi" class="source">
    <pre><code>def phase_xi(J,q,S1,S2,r): 

    '''
    Return an integer number, phases, specifying the number of precessional morphologies that can coexist for a given value of J. Returns:

    - 1 if only the DeltaPhi~pi phase is present;
    - 2 if two DeltaPhi~pi phases and a circulating phase are present;
    - 3 if a librating DeltaPhi~0, a circulating, and a DeltaPhi~pi phase al all present.

    The latter is *standard* case studied in [our first PRL](http://journals.aps.org/prl/abstract/10.1103/PhysRevLett.114.081103). Additionally, return the values of xi that, for given J, separate the binaries with different morphologies. If there are no transitions (i.e. phase=1), the transition values of xi are returned as Nones. If transitions cannot be found for numerical reasons, assume they coincides with the extrema of xi (see `precession.xi_allowed`). The output of this function can be tested with `precession.phase_checker`.

    **Call:**

        phases=precession.phase_xi(J,q,S1,S2,r)
    
    **Parameters:**

    - `J`: magnitude of the total angular momentum.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `r`: binary separation.

    **Returns:**

    - phases: number of coexisting morphologies: 1 if only the DeltaPhi~pi phase is present; 2 if two DeltaPhi~pi phases and a circulating phase are present; 3 if a librating DeltaPhi~0, a circulating, and a DeltaPhi~pi phase al all present.
    '''

    xi_min,xi_max=xi_allowed(J,q,S1,S2,r)
    L=(q/(1.+q)**2)*(r*M**3)**.5
    
    # The following should be equivalent to apply find_morphology at xi_min and xi_max but it turns out to be more stable to numerical noise because it doesn't rely on Sb_limits
    St_min,St_max=St_limits(J,q,S1,S2,r)
    morph_ximin=find_morphology(xi_plus(St_max,J,q,S1,S2,r),J,q,S1,S2,r)
    morph_ximax=find_morphology(xi_plus(St_min,J,q,S1,S2,r),J,q,S1,S2,r)
    
    # The morphology at xi_max must be librating about pi. The morphology at xi_min can't be circulating.  Check if, because of degeneracies and numerical issues, a different morphology is be detected... 
    if morph_ximax!=1 or morph_ximin==0:
        print "[phase_xi] I think this should never ever happen. morph_ximax=",morph_ximax," morph_ximin=",morph_ximin
        if morph_ximin==-1:
            phase=3.
            xi_transit_up=xi_plus(St_min,J,q,S1,S2,r)+1e-9
            try:
                xi_transit_low=sp.optimize.brentq(lambda xi: (find_morphology(xi,J,q,S1,S2,r) +0.5), xi_min,xi_transit_up-1e-5, xtol=1e-5)
            except:
                xi_transit_low=xi_min

            return phase,xi_transit_low,xi_transit_up
        
    if morph_ximin==-1: 

        phase=3. # This is a three-phase case: Deltaphi~pi close to xi_max, Deltaphi~0 at xi_min and a circulating phase in between

        #Find transition Librating 180 - Circulating. Shift the find_morphology output, such that the zero is between the two phases
        try:
            xi_transit_up=sp.optimize.brentq(lambda xi: (find_morphology(xi,J,q,S1,S2,r) -0.5), xi_min,xi_max, xtol=1e-5)
        except:
            xi_transit_up=xi_max
            
        #Find transition Librating 0 - Circulating. Shift the find_morphology output, such that the zero is between the two phases
        try:
            xi_transit_low=sp.optimize.brentq(lambda xi: (find_morphology(xi,J,q,S1,S2,r) +0.5), xi_min,xi_max, xtol=1e-5)
        except:
            xi_transit_low=xi_min
            
        #xi_transit_low,xi_transit_up=sorted([xi_transit_0,xi_transit_180])

    elif morph_ximin==1:  # This is either a two-phase or a single-phase case.
        # Here we need to bracket the interval to find two roots. Two possible bracketing points are checked: the values of S for which
            # [first try] cos(theta1)=1 and cos(theta2)= -1 
            # [second try] cos(theta1)=-1 and cos(theta2)= 1 
        # Either one of the two choice typically gives the correct results for all the cases we tried; we cannot exclude the presence of pathological sets of parameters where both choices fail.

        for xi_bracket in [ -1.*(1.+q)*S1+(1.+1./q)*S2 , (1.+q)*S1-(1.+1./q)*S2 ]:
            if xi_bracket>xi_max or xi_bracket<xi_min:
                phase=1. # Either the bracketing is wrong or this is a single-phase case
                xi_transit_low=xi_min
                xi_transit_up=xi_max
            elif find_morphology(xi_bracket,J,q,S1,S2,r)==0:
                phase=2. # You found a good bracketing point. This must be a two-phase case             
            
                #Find the first transition Librating 180 - Circulating at lower xi. Shift the find_morphology output, such that the zero is between the two phase
                try:
                    xi_transit_low=sp.optimize.brentq(lambda xi: (find_morphology(xi,J,q,S1,S2,r) -0.5), xi_min,xi_bracket, xtol=1e-5)
                except:
                    xi_transit_low=xi_min
   
                #Find the other transition Librating 180 - Circulating at larger xi. Shift the find_morphology output, such that the zero is between the two phase
                try:
                    xi_transit_up=sp.optimize.brentq(lambda xi:  (find_morphology(xi,J,q,S1,S2,r) -0.5), xi_bracket,xi_max, xtol=1e-5)
                except:
                    xi_transit_up=xi_max
             
                break # One bracketing point is enough. Get out if you found the solution
            
            else:
                phase=1.  # Either the bracketing is wrong or this is a single-phase case
                xi_transit_low=xi_min
                xi_transit_up=xi_max
                          
    if phase not in phase_checker(q,S1,S2,r):
        print "[phase_xi] Warning: detected phases not allowed by geometry!"

    return phase, xi_transit_low,xi_transit_up
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.precession_period">
    <p>def <span class="ident">precession_period</span>(</p><p>xi, J, q, S1, S2, r)</p>
    </div>
    

    
  
    <div class="desc"><p>Find the period of S, i.e. the precessional timescale. This is <a href="#precession.t_of_S"><code>t_of_S</code></a> integrated from Sb_min to Sb_max times 2.</p>
<p><strong>Call:</strong></p>
<pre><code>tau=precession.precession_period(xi,J,q,S1,S2,r)
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>J</code>: magnitude of the total angular momentum.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>r</code>: binary separation.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>tau</code>: precessional period (in total mass units).</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.precession_period', this);">Show source &equiv;</a></p>
  <div id="source-precession.precession_period" class="source">
    <pre><code>def precession_period(xi,J,q,S1,S2,r):
    
    '''
    Find the period of S, i.e. the precessional timescale. This is `precession.t_of_S` integrated from Sb_min to Sb_max times 2.

    **Call:**

        tau=precession.precession_period(xi,J,q,S1,S2,r)
    
    **Parameters:**
    
    - `xi`: projection of the effective spin along the orbital angular momentum.
    - `J`: magnitude of the total angular momentum.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `r`: binary separation.

    **Returns:**

    - `tau`: precessional period (in total mass units).
    '''
    
    if q==1: # If q=1, the limits must be specified in cos(varphi)
       Sb_min=-1
       Sb_max=1
    else:
        Sb_min,Sb_max=Sb_limits(xi,J,q,S1,S2,r)
    
    halfperiod = t_of_S(Sb_min,Sb_max,Sb_min,Sb_max,xi,J,q,S1,S2,r)
    #abs because here you don't care about the <sign> issue in dS/dt here
    return np.abs(2*halfperiod)
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.region_selection">
    <p>def <span class="ident">region_selection</span>(</p><p>varphi, S, J, q, S1, S2, r)</p>
    </div>
    

    
  
    <div class="desc"><p>Get the morphology in the varphi plane. See <a href="#precession.find_morphology"><code>find_morphology</code></a>.</p>
<p><strong>Call:</strong></p>
<pre><code>morphology=precession.region_selection(varphi,S,J,q,S1,S2,r)
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>varphi</code>: angle describing the rotation of S1 and S2 about S, in a frame aligned with J.</li>
<li><code>S</code>: magnitude of the total spin.</li>
<li><code>J</code>: magnitude of the total angular momentum.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>r</code>: binary separation.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li>morphology: precessional morphology in DeltaPhi: -1 if librating about DeltaPhi=0; 0 if circulating; +1 if librating about DeltaPhi=pi.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.region_selection', this);">Show source &equiv;</a></p>
  <div id="source-precession.region_selection" class="source">
    <pre><code>def region_selection(varphi,S,J,q,S1,S2,r):

    '''
    Get the morphology in the varphi plane. See `precession.find_morphology`.

    **Call:**

        morphology=precession.region_selection(varphi,S,J,q,S1,S2,r)

    **Parameters:**

    - `varphi`: angle describing the rotation of S1 and S2 about S, in a frame aligned with J.
    - `S`: magnitude of the total spin.
    - `J`: magnitude of the total angular momentum.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `r`: binary separation.

    **Returns:**

    - morphology: precessional morphology in DeltaPhi: -1 if librating about DeltaPhi=0; 0 if circulating; +1 if librating about DeltaPhi=pi.
    '''
    
    xi=xi_contour(varphi,S,J,q,S1,S2,r)
    return find_morphology(xi,J,q,S1,S2,r)
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.resonant_finder">
    <p>def <span class="ident">resonant_finder</span>(</p><p>xi, q, S1, S2, r, more=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Find the spin-orbit resonances, for given xi, as extrema of the allowed region in the parameter space. Two resonances are present for DeltaPhi=0 and DeltaPhi=pi. They maximize (0) and minimize (pi) J for fixed xi. This is an alternative (and more powerful) approach to solving the Schnittman equation, given in Eq.(35) of <a href="http://journals.aps.org/prd/abstract/10.1103/PhysRevD.70.124020">PRD 70,124020(2004)</a>.</p>
<p><strong>Call:</strong></p>
<pre><code>theta1_dp0,theta2_dp0,theta1_dp180,theta2_dp180=precession.resonant_finder(xi,q,S1,S2,r,more=False)

J_dp0,S_dp0,theta1_dp0,theta2_dp0,J_dp180,S_dp180,theta1_dp180,theta2_dp180=precession.resonant_finder(xi,q,S1,S2,r,more=True)
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>r</code>: binary separation.</li>
<li><code>more</code>: if <code>True</code> returns additional quantities,</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li>J_dp0: (optional) value of J for the DeltaPhi=0 resonance.</li>
<li>S_dp0: (optional) value of S for the DeltaPhi=0 resonance.</li>
<li>theta1_dp0: value of theta1 for the DeltaPhi=0 resonance.</li>
<li>theta2_dp0: value of theta2 for the DeltaPhi=pi resonance.</li>
<li>J_dp180: (optional) value of J for the DeltaPhi=pi resonance.</li>
<li>S_dp180: (optional) value of S for the DeltaPhi=pi resonance.</li>
<li>theta1_dp180: value of theta1 for the DeltaPhi=pi resonance.</li>
<li>theta2_dp180: value of theta2 for the DeltaPhi=pi resonance.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.resonant_finder', this);">Show source &equiv;</a></p>
  <div id="source-precession.resonant_finder" class="source">
    <pre><code>def resonant_finder(xi,q,S1,S2,r, more=False):

    '''
    Find the spin-orbit resonances, for given xi, as extrema of the allowed region in the parameter space. Two resonances are present for DeltaPhi=0 and DeltaPhi=pi. They maximize (0) and minimize (pi) J for fixed xi. This is an alternative (and more powerful) approach to solving the Schnittman equation, given in Eq.(35) of [PRD 70,124020(2004)](http://journals.aps.org/prd/abstract/10.1103/PhysRevD.70.124020).
    
    **Call:**

        theta1_dp0,theta2_dp0,theta1_dp180,theta2_dp180=precession.resonant_finder(xi,q,S1,S2,r,more=False)

        J_dp0,S_dp0,theta1_dp0,theta2_dp0,J_dp180,S_dp180,theta1_dp180,theta2_dp180=precession.resonant_finder(xi,q,S1,S2,r,more=True)

    **Parameters:**

    - `xi`: projection of the effective spin along the orbital angular momentum.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `r`: binary separation.
    - `more`: if `True` returns additional quantities,

    **Returns:**

    - J_dp0: (optional) value of J for the DeltaPhi=0 resonance.
    - S_dp0: (optional) value of S for the DeltaPhi=0 resonance.
    - theta1_dp0: value of theta1 for the DeltaPhi=0 resonance.
    - theta2_dp0: value of theta2 for the DeltaPhi=pi resonance.
    - J_dp180: (optional) value of J for the DeltaPhi=pi resonance.
    - S_dp180: (optional) value of S for the DeltaPhi=pi resonance.
    - theta1_dp180: value of theta1 for the DeltaPhi=pi resonance.
    - theta2_dp180: value of theta2 for the DeltaPhi=pi resonance. 
    '''
    
    Jmin,Jmax=J_lim(q,S1,S2,r)    
    L=(q/(1.+q)**2)*(r*M**3)**.5    
    
    #DeltaPhi=0 resonance.
    J_dp0=sp.optimize.brentq(lambda J: xi_allowed(J,q,S1,S2,r)[0] -xi , abs(L-S1-S2), Jmax,xtol=1e-12)

    if q==1: 
        # Find S. St_max
        S_dp0=St_limits(J_dp0,q,S1,S2,r)[1]
        # Find angles
        theta1_dp0,theta2_dp0,deltaphi_dp0,dummy = parametric_angles(0,J_dp0,xi,q,S1,S2,r)   
                
    else:
        # Find S. Minimum of effective potential       
        dummy,dummy,S_dp0,dummy= xi_allowed(J_dp0,q,S1,S2,r,more=True)
        # Find angles
        theta1_dp0,theta2_dp0,deltaphi_dp0,dummy = parametric_angles(S_dp0,J_dp0,xi,q,S1,S2,r)

    #DeltaPhi=180 resonance.
    xi_Jmin,xi_Jmax= xi_at_Jlim(q,S1,S2,r)
            
    if xi>xi_Jmin:
        # Find J. Solution always on xi_max, between Jmin and Jmax
        J_dp180=sp.optimize.brentq(lambda J: xi_allowed(J,q,S1,S2,r)[1] -xi , Jmin, Jmax,xtol=1e-12)
        if q==1:
            # Find S. St_min
            S_dp180=St_limits(J_dp180,q,S1,S2,r)[0]
            # Find angles
            theta1_dp180,theta2_dp180,deltaphi_dp0,dummy = parametric_angles(0,J_dp180,xi,q,S1,S2,r)   
        else:
            # Find S. Maximum of effective potential
            dummy,dummy,dummy,S_dp180= xi_allowed(J_dp180,q,S1,S2,r,more=True)
            # Find angles
            theta1_dp180,theta2_dp180,deltaphi_dp180,dummy = parametric_angles(S_dp180,J_dp180,xi,q,S1,S2,r)
    else:
        # Find J. Solution still on xi_min, between Jmin and L-S1-S2. You're not here if Jmin=L-S1-S2, because xi_Jmin is the lower allowed value for xi in that case.
        J_dp180=sp.optimize.brentq(lambda J: xi_allowed(J,q,S1,S2,r)[0] -xi ,Jmin, abs(L-S1-S2),xtol=1e-12)
        if q==1:
            # Find S. St_max
            S_dp180=St_limits(J_dp180,q,S1,S2,r)[1]
            # Find angles
            theta1_dp180,theta2_dp180,deltaphi_dp0,dummy = parametric_angles(0,J_dp180,xi,q,S1,S2,r)   
        else:
            # Find S. Minimum of effective potential
            dummy,dummy,S_dp180,dummy= xi_allowed(J_dp180,q,S1,S2,r,more=True)
            # Find angles
            theta1_dp180,theta2_dp180,deltaphi_dp180,dummy = parametric_angles(S_dp180,J_dp180,xi,q,S1,S2,r)
       
    if False: # Sanity check. 
        print "DeltaPhi=0?", deltaphi_dp0
        print "DeltaPhi=pi?", deltaphi_dp180
    
    if more: # return everything you got
        return J_dp0, S_dp0, theta1_dp0, theta2_dp0, J_dp180, S_dp180, theta1_dp180, theta2_dp180
    else: # return the angles only
        return theta1_dp0, theta2_dp0, theta1_dp180, theta2_dp180
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.rtof">
    <p>def <span class="ident">rtof</span>(</p><p>r, M_msun)</p>
    </div>
    

    
  
    <div class="desc"><p>Conversion between emitted GW frequency f (in Hertz) and binary
separation r (in mass unit). We use the Newtonian expression:
f^2 = G M / (pi^2 r^3) in cgs units. Mass units: r--&gt; GMr/c^2</p>
<p><strong>Call:</strong></p>
<pre><code>f=precession.rtof(r,M_msun)
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>r</code>: binary separation.</li>
<li><code>M_msun</code>: binary total mass in solar masses.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>f</code>: emitted GW frequency in Hertz.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.rtof', this);">Show source &equiv;</a></p>
  <div id="source-precession.rtof" class="source">
    <pre><code>def rtof(r,M_msun):

    '''
    Conversion between emitted GW frequency f (in Hertz) and binary
    separation r (in mass unit). We use the Newtonian expression:
    f^2 = G M / (pi^2 r^3) in cgs units. Mass units: r--> GMr/c^2
 
    **Call:**

        f=precession.rtof(r,M_msun)

    **Parameters:**
    
    - `r`: binary separation.
    - `M_msun`: binary total mass in solar masses.

    **Returns:**
    
    - `f`: emitted GW frequency in Hertz.
    '''

    M_cgs=M_msun*(2e33)
    c_cgs=2.99e10
    G_cgs=6.67e-8
    f=pow(c_cgs,3.)/(math.pi*G_cgs*M_cgs*pow(r,3./2.))
    return f
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.samplingS">
    <p>def <span class="ident">samplingS</span>(</p><p>xi, J, q, S1, S2, r)</p>
    </div>
    

    
  
    <div class="desc"><p>Select a value of S weighted with |dt/dS|. Sampling implemented using the cumulative distribution:</p>
<ol>
<li>select a random number epsilon in [0,1];</li>
<li>find the value of S at which the cumulative probability distribution is equal to epsilon.</li>
</ol>
<p>The cumulative-distribution method is particualry suitable because the probability distribution function |dt/dS| diverges at the extrema Sb_min and Sb_max (and is troubling to apply a hit-or-miss approach).</p>
<p><strong>Call:</strong></p>
<pre><code>S=precession.samplingS(xi,J,q,S1,S2,r)
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>J</code>: magnitude of the total angular momentum.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>r</code>: binary separation.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>S</code>: magnitude of the total spin.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.samplingS', this);">Show source &equiv;</a></p>
  <div id="source-precession.samplingS" class="source">
    <pre><code>def samplingS(xi,J,q,S1,S2,r):
    
    '''
    Select a value of S weighted with |dt/dS|. Sampling implemented using the cumulative distribution:
    
    1. select a random number epsilon in [0,1];
    2. find the value of S at which the cumulative probability distribution is equal to epsilon.

    The cumulative-distribution method is particualry suitable because the probability distribution function |dt/dS| diverges at the extrema Sb_min and Sb_max (and is troubling to apply a hit-or-miss approach).

    **Call:**

        S=precession.samplingS(xi,J,q,S1,S2,r)
    
    **Parameters:**
    
    - `xi`: projection of the effective spin along the orbital angular momentum.
    - `J`: magnitude of the total angular momentum.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `r`: binary separation.

    **Returns:**

    - `S`: magnitude of the total spin.
    '''

    global flags_q1
    if q==1:
        if flags_q1[7]==False:
            print "[samplingS] Warning q=1: sampling is cos(varphi), not S"
            flags_q1[7]=True
            
        # If q=1, the limits must be specified in cos(varphi)
        tol=1e-10 # Don't go too close to the actual limits
        Sb_min=-1.+tol
        Sb_max=1.-tol
        
    else:
        Sb_min,Sb_max=Sb_limits(xi,J,q,S1,S2,r)
    
    if np.abs(Sb_min-Sb_max)<1e-8: # This typically happen when [Sb_limits] fails in bracketing of the solutions. In practice, this is a resonant binary.
        S_sol=(Sb_min+Sb_max)/2.
    else:
        halfperiod=t_of_S(Sb_min,Sb_max,Sb_min,Sb_max,xi,J,q,S1,S2,r)
        
        eps= random.uniform(0,1)    
        
        S_sol= sp.optimize.brentq(lambda S: np.abs(t_of_S(Sb_min,S,Sb_min,Sb_max,xi,J,q,S1,S2,r) / halfperiod) - eps, Sb_min, Sb_max) # The brentq algorithm works very well with a monotonic function like the cumulative distribution

    return S_sol            
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.t_of_S">
    <p>def <span class="ident">t_of_S</span>(</p><p>S_initial, S_final, Sb_min, Sb_max, xi, J, q, S1, S2, r, t_initial=0, sign=1.0)</p>
    </div>
    

    
  
    <div class="desc"><p>Integrate `precession.dSdt' to find t (time) as a function of S (magnitude of the total spin). Since dS/dt depends on S and not on t, finding t(S) only requires a numnerical integration; finding S(t) would require a ODE solver (straightforward, but it has not been implemented). Sb_min and Sb_max are passed to this function (and not computed within it) for computational efficiency. This function can only integrate over half precession period (i.e. from Sb_min to Sb_max at most). If you want t(S) over more precession periods you should stich different solutions together, consistently with the argument sign (in particular, flip sign every half period).</p>
<p><strong>Call:</strong></p>
<pre><code>t=precession.t_of_S(S_initial,S_final,Sb_min,Sb_max,xi,J,q,S1,S2,r,t_initial=0,sign=1.)
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>S_initial</code>: lower edge of the integration domain.</li>
<li><code>S_final</code>: upper edge of the integration domain.</li>
<li><code>Sb_min</code>: minimum value of S from geometrical constraints. This is S- in our papers.</li>
<li><code>Sb_max</code>: maximum value of S from geometrical constraints. This is S+ in our papers.</li>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>J</code>: magnitude of the total angular momentum.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>r</code>: binary separation.</li>
<li><code>t_initial</code>: intial integration time.</li>
<li><code>sign</code>: if 1 return angle in [0,pi], if -1 return angle in [-pi,0].</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>t</code>: time (in total mass units).</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.t_of_S', this);">Show source &equiv;</a></p>
  <div id="source-precession.t_of_S" class="source">
    <pre><code>def t_of_S( S_initial,S_final ,Sb_min,Sb_max ,xi,J,q,S1,S2,r, t_initial=0, sign=1. ):

    '''
    Integrate `precession.dSdt' to find t (time) as a function of S (magnitude of the total spin). Since dS/dt depends on S and not on t, finding t(S) only requires a numnerical integration; finding S(t) would require a ODE solver (straightforward, but it has not been implemented). Sb_min and Sb_max are passed to this function (and not computed within it) for computational efficiency. This function can only integrate over half precession period (i.e. from Sb_min to Sb_max at most). If you want t(S) over more precession periods you should stich different solutions together, consistently with the argument sign (in particular, flip sign every half period).

    **Call:**

        t=precession.t_of_S(S_initial,S_final,Sb_min,Sb_max,xi,J,q,S1,S2,r,t_initial=0,sign=1.)
    
    **Parameters:**
    
    - `S_initial`: lower edge of the integration domain.
    - `S_final`: upper edge of the integration domain.
    - `Sb_min`: minimum value of S from geometrical constraints. This is S- in our papers.
    - `Sb_max`: maximum value of S from geometrical constraints. This is S+ in our papers.
    - `xi`: projection of the effective spin along the orbital angular momentum.
    - `J`: magnitude of the total angular momentum.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `r`: binary separation.
    - `t_initial`: intial integration time.
    - `sign`: if 1 return angle in [0,pi], if -1 return angle in [-pi,0].

    **Returns:**

    - `t`: time (in total mass units).
    '''

    global flags_q1
    if q==1:
        if flags_q1[4]==False:
            print "[t_of_S] Warning q=1: input here is cos(varphi) not S; now computing t( cos(varphi) )"
            flags_q1[4]=True
            
        L=(q/(1.+q)**2)*(r*M**3)**.5
        S = np.sqrt(J**2-L**2-xi*L*M**2)
        S_min,S_max=St_limits(J,q,S1,S2,r)
        if np.abs(S-S_min)<1e-8 or np.abs(S-S_max)<1e-8:
            print "[t_of_S] Warning: you are at resonance, varphi is ill defined here."
            return 0.
        elif min(S_initial,S_final) < -1 or max(S_initial,S_final) > 1:
            print "[t_of_S] Error. You're trying to integrate over more than one (half)period"
            sys.exit()
        else:
            res=sp.integrate.quad(dtdS, S_initial, S_final, args=(xi,J,q,S1,S2,r,sign),full_output=1)
            return t_initial + res[0]
            
    if np.abs(Sb_min-Sb_max)<1e-8: # This happens when [Sb_limits] fails in bracketing of the solutions. In practice, this is a resonant binary.
        return 0.
    elif min(S_initial,S_final) < Sb_min or max(S_initial,S_final) > Sb_max:
        print "[t_of_S] Error. You're trying to integrate over more than one (half)period"
        print Sb_min,Sb_max
        sys.exit()
    else:
        res=sp.integrate.quad(dtdS, S_initial, S_final, args=(xi,J,q,S1,S2,r,sign),full_output=1)               
        return t_initial + res[0]
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.thetas_inf">
    <p>def <span class="ident">thetas_inf</span>(</p><p>xi, kappa_inf, q, S1, S2)</p>
    </div>
    

    
  
    <div class="desc"><p>Find the asymptotic (constant) values of theta1 and theta2 given xi and kappa_inf.</p>
<p><strong>Call:</strong></p>
<pre><code>theta1_inf,theta2_inf=precession.thetas_inf(xi,kappa_inf,q,S1,S2)
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
<li><code>kappa_inf</code>: asymptotic value of kappa at large separations.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>theta1_inf</code>: asymptotic value of theta1 at large separations.</li>
<li><code>theta2_inf</code>: asymptotic value of theta2 at large separations.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.thetas_inf', this);">Show source &equiv;</a></p>
  <div id="source-precession.thetas_inf" class="source">
    <pre><code>def thetas_inf(xi,kappa_inf,q,S1,S2):

    '''
    Find the asymptotic (constant) values of theta1 and theta2 given xi and kappa_inf.

    **Call:**

        theta1_inf,theta2_inf=precession.thetas_inf(xi,kappa_inf,q,S1,S2)

    **Parameters:**

    - `xi`: projection of the effective spin along the orbital angular momentum.
    - `kappa_inf`: asymptotic value of kappa at large separations.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.

    **Returns:**

    - `theta1_inf`: asymptotic value of theta1 at large separations.
    - `theta2_inf`: asymptotic value of theta2 at large separations.
    '''
    
    if q==1:
        print "[thetas_inf] Error: I'm sorry, can't run for q=1. The angles theta1 and theta2 are not constant at large separations."
        sys.exit()
    else:
        ct1=(-xi + kappa_inf*(1.+q**(-1)))/(S1*(q**(-1)-q))
        ct2=(xi - kappa_inf*(1.+q))/(S2*(q**(-1)-q))
        return np.arccos(ct1),np.arccos(ct2)
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.updown">
    <p>def <span class="ident">updown</span>(</p><p>q, S1, S2)</p>
    </div>
    

    
  
    <div class="desc"><p>Instability range for up-down aligned binaries. Binaries with the primary (secondary) spin aligned (antialigned) with the angular momentum are unstable between the two separations returned.
Hack the code to compute also the function <em>switch</em>, for a sanity check on the property of the second threshold (whether that's on <a href="#precession.xi_plus"><code>xi_plus</code></a> or on <a href="#precession.xi_minus"><code>xi_minus</code></a>).
All up-down binaries are stable in the equal-mass case: if q=1 returns Nones.</p>
<p><strong>Call:</strong></p>
<pre><code>r_udp,r_udm=precession.updown(q,S1,S2)
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>r_udp</code>: upper separation for the up-down instability.</li>
<li><code>r_udm</code>: lower separation for the up-down instability.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.updown', this);">Show source &equiv;</a></p>
  <div id="source-precession.updown" class="source">
    <pre><code>def updown(q,S1,S2):
    
    '''
    Instability range for up-down aligned binaries. Binaries with the primary (secondary) spin aligned (antialigned) with the angular momentum are unstable between the two separations returned.
    Hack the code to compute also the function *switch*, for a sanity check on the property of the second threshold (whether that's on `precession.xi_plus` or on `precession.xi_minus`).
    All up-down binaries are stable in the equal-mass case: if q=1 returns Nones.

    **Call:**

        r_udp,r_udm=precession.updown(q,S1,S2)

    **Parameters:**

    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    
    **Returns:**

    - `r_udp`: upper separation for the up-down instability.
    - `r_udm`: lower separation for the up-down instability.    
    '''

    if q==1:
        print "[updown] Warning: up-down is always stable for q=1. Retuning Nones."
        return None, None

    r_udp=((1.+q)**2 *((q*S1)**0.5 + S2**0.5)**2/((1.-q)*q))**2
    r_udm=((1.+q)**2 *((q*S1)**0.5 - S2**0.5)**2/((1.-q)*q))**2
    
    if False:
        switch=q**0.5+ q**(-0.5) - (S2/S1)**0.5 - (S2/S1)**(-0.5)
        return r_udp,r_udm,switch
    else:
        return r_udp,r_udm
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.why">
    <p>def <span class="ident">why</span>(</p><p>)</p>
    </div>
    

    
  
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.why', this);">Show source &equiv;</a></p>
  <div id="source-precession.why" class="source">
    <pre><code>def why():
    print "\nIt's all about python and gravity. Go to"
    print "http://imgs.xkcd.com/comics/python.png\n"
    sys.exit()
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.xi_allowed">
    <p>def <span class="ident">xi_allowed</span>(</p><p>J, q, S1, S2, r, more=False, verbose=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Find the allowed range of xi for fixed J, corresponding to the extrema of
the effective potential. Two implementations are presented, and are
controlled by the inner flag use_derivative. If False (default, suggested), scipy's
fminbound minimization algorithm is applied to the effective potentials
<a href="#precession.xi_minus"><code>xi_minus</code></a> and <a href="#precession.xi_plus"><code>xi_plus</code></a>. If True, we explicitly look for the zeroes of the
derivative of the effective potentials with respect to S. J. Vosmera
found that the bisect root finder behaves better than brentq for low mass
ratio. We believe both implementation are correct: the former has been
tested more extensively, the latter has been found to be more reliable in
the q-&gt;1 limit. </p>
<p>WARNING: This function is critical. It's tested, but is
tricky numerical issues may still be present.</p>
<p><strong>Call:</strong></p>
<pre><code>xi_low,xi_up=precession.xi_allowed(J,q,S1,S2,r,more=False,verbose=False)

xi_low,xi_up,S_xilow,S_xiup=precession.xi_allowed(J,q,S1,S2,r,more=True,verbose=False)
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>J</code>: magnitude of the total angular momentum.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>r</code>: binary separation.</li>
<li><code>more</code>: if <code>True</code> returns additional quantities,</li>
<li><code>verbose</code>: if <code>True</code> print additional information.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>xi_low</code>: minimum allowed value of xi, given the input parameters.</li>
<li><code>xi_up</code>: maximum allowed value of xi, given the input parameters.</li>
<li><code>S_xilow</code>: (optional) value of S when xi=xi_low.</li>
<li><code>S_xiup</code>: (optional) value of S when xi=xi_up.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.xi_allowed', this);">Show source &equiv;</a></p>
  <div id="source-precession.xi_allowed" class="source">
    <pre><code>def xi_allowed(J,q,S1,S2,r, more=False,verbose=False):

    '''
    Find the allowed range of xi for fixed J, corresponding to the extrema of
    the effective potential. Two implementations are presented, and are
    controlled by the inner flag use_derivative. If False (default, suggested), scipy's
    fminbound minimization algorithm is applied to the effective potentials
    `precession.xi_minus` and `precession.xi_plus`. If True, we explicitly look for the zeroes of the
    derivative of the effective potentials with respect to S. J. Vosmera
    found that the bisect root finder behaves better than brentq for low mass
    ratio. We believe both implementation are correct: the former has been
    tested more extensively, the latter has been found to be more reliable in
    the q->1 limit. 
    
    WARNING: This function is critical. It's tested, but is
    tricky numerical issues may still be present.

    **Call:**

        xi_low,xi_up=precession.xi_allowed(J,q,S1,S2,r,more=False,verbose=False)

        xi_low,xi_up,S_xilow,S_xiup=precession.xi_allowed(J,q,S1,S2,r,more=True,verbose=False)


    **Parameters:**

    - `J`: magnitude of the total angular momentum.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `r`: binary separation.
    - `more`: if `True` returns additional quantities,
    - `verbose`: if `True` print additional information.

    **Returns:**

    - `xi_low`: minimum allowed value of xi, given the input parameters.
    - `xi_up`: maximum allowed value of xi, given the input parameters.
    - `S_xilow`: (optional) value of S when xi=xi_low.
    - `S_xiup`: (optional) value of S when xi=xi_up.
    '''

    # Take care of possible pathologies at the edges of the parameter space
    Jmin,Jmax= J_lim(q,S1,S2,r)
    if J==Jmin or J==Jmax:
        if J==Jmin:
            xiboth, dummy, Sboth, dummy = xi_at_Jlim(q,S1,S2,r,more=True)
        elif J==Jmax:
            dummy, xiboth, dummy, Sboth = xi_at_Jlim(q,S1,S2,r,more=True)
        if more:
            return xiboth, xiboth, Sboth, Sboth
        else:
            return xiboth, xiboth
    
    St_min,St_max=St_limits(J,q,S1,S2,r)
    
    # The extrema are at S=St_min, St_max
    if q==1:
        L=(q/(1.+q)**2)*(r*M**3)**.5
        xi_low=(J**2-L**2-St_max**2)/(L*M**2)
        xi_up=(J**2-L**2-St_min**2)/(L*M**2)
        S_xilow=St_max
        S_xiup=St_min

    # Extremize the two effective potentials.  
    else:
    
        use_derivative=False
        
        #Run a minimization algorithms on the effective potentials. 
        if use_derivative==False:
        
            # Minimum of xi_minus
            resmin= sp.optimize.fminbound(lambda S: xi_minus(S,J,q,S1,S2,r), St_min, St_max,xtol=1e-12,full_output=1)
            S_xilow=resmin[0] 
            xi_low=resmin[1]

            # Maximum of xi_plus. Scipy provides minimization algorithms: minimize -xi_plus and change sign at the end.
            resmax= sp.optimize.fminbound(lambda S: -1.*xi_plus(S,J,q,S1,S2,r), St_min, St_max,xtol=1e-12,full_output=1)
            S_xiup=resmax[0] 
            xi_up=-1.*resmax[1]

        # Run a root finders on the derivative of the effective potentials. 
        elif use_derivative==True:
        
            if q<0.1: # bisect behaves better for extreme mass ratios...
                S_xilow=sp.optimize.bisect(lambda S: dxidS_plus(S,J,q,S1,S2,r), St_min, St_max,xtol=1e-12)     
                S_xiup=sp.optimize.bisect(lambda S: dxidS_minus(S,J,q,S1,S2,r), St_min, St_max,xtol=1e-12)
            else: # ... but brentq is faster
                S_xilow=sp.optimize.brentq(lambda S: dxidS_plus(S,J,q,S1,S2,r), St_min, St_max,xtol=1e-12)    
                S_xiup=sp.optimize.brentq(lambda S: dxidS_minus(S,J,q,S1,S2,r), St_min, St_max,xtol=1e-12)
            xi_low=xi_minus(S_xilow,J,q,S1,S2,r)
            xi_up =xi_plus(S_xiup,J,q,S1,S2,r)

    if verbose:
        print "[xi_allowed] xi_low", xi_low, " xi_up=", xi_up
    if more: # Return the S values as well
        return xi_low, xi_up, S_xilow, S_xiup
    else:
        return xi_low, xi_up
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.xi_at_Jlim">
    <p>def <span class="ident">xi_at_Jlim</span>(</p><p>q, S1, S2, r, more=False)</p>
    </div>
    

    
  
    <div class="desc"><p>Find the value of xi (and S, optional) when J is either Jmax or Jmin..</p>
<p><strong>Call:</strong></p>
<pre><code>xi_Jmin,xi_Jmax=precession.xi_at_Jlim(q,S1,S2,r,more=False)
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>r</code>: binary separation.</li>
<li><code>more</code>: if <code>True</code> returns additional quantities,</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>xi_Jmin</code>: value of xi when J=Jmin.</li>
<li><code>xi_Jmax</code>: value of xi when J=Jmax.</li>
<li><code>S_Jmin</code>: (optional) value of S when J=Jmin.</li>
<li><code>S_Jmax</code>: (optional) value of S when J=Jmax.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.xi_at_Jlim', this);">Show source &equiv;</a></p>
  <div id="source-precession.xi_at_Jlim" class="source">
    <pre><code>def xi_at_Jlim(q,S1,S2,r,more=False):

    '''
    Find the value of xi (and S, optional) when J is either Jmax or Jmin..
    
    **Call:**

        xi_Jmin,xi_Jmax=precession.xi_at_Jlim(q,S1,S2,r,more=False)
    
    **Parameters:**
    
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `r`: binary separation.
    - `more`: if `True` returns additional quantities,

    **Returns:**

    - `xi_Jmin`: value of xi when J=Jmin.
    - `xi_Jmax`: value of xi when J=Jmax.
    - `S_Jmin`: (optional) value of S when J=Jmin.
    - `S_Jmax`: (optional) value of S when J=Jmax.
    '''

    # Find Jmin and Jmax
    L=(q/(1.+q)**2)*(r*M**3)**.5    
    Jmin=max(1e-20,L-S1-S2,S1-L-S2,S2-S1-L)
    Jmax=L+S1+S2
    
    # Everything is aligned at Jmax
    ct1=1.
    ct2=1.
    xi_Jmax= ((1.+q)*S1*ct1+(1.+q**-1)*S2*ct2)*M**-2
    S_Jmax= S1+S2
    
    # Split the Jmin cases
    if Jmin==1e-20: # Force vectors in a plane, closed triangle
        ct1= (-S1**2+S2**2-L**2)/(2.*L*S1)
        ct2= (-S2**2+S1**2-L**2)/(2.*L*S2)
        S_Jmin=0
    elif Jmin==L-S1-S2: # Both antialigned
        ct1=-1.
        ct2=-1.
        S_Jmin=S1+S2
    elif Jmin==S1-L-S2: # One antialigned
        ct1=-1.
        ct2=1.
        S_Jmin=np.abs(S1-S2)
    elif Jmin==S2-L-S1: # One antialigned
        ct1=1.
        ct2=-1.
        S_Jmin=np.abs(S1-S2)
    xi_Jmin= ((1.+q)*S1*ct1+(1.+q**-1)*S2*ct2)*M**-2
    
    if more:
        return xi_Jmin, xi_Jmax, S_Jmin, S_Jmax
    else:
        return xi_Jmin, xi_Jmax
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.xi_contour">
    <p>def <span class="ident">xi_contour</span>(</p><p>varphi, S, J, q, S1, S2, r)</p>
    </div>
    

    
  
    <div class="desc"><p>Compute the projection of the effective spin xi as a function of the spin-rotation degree of freedom
varphi and the total spin magnitude S.</p>
<p><strong>Call:</strong></p>
<pre><code>xi=precession.xi_contour(varphi,S,J,q,S1,S2,r)
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>varphi</code>: angle describing the rotation of S1 and S2 about S, in a frame aligned with J.</li>
<li><code>S</code>: magnitude of the total spin.</li>
<li><code>J</code>: magnitude of the total angular momentum.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>r</code>: binary separation.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.xi_contour', this);">Show source &equiv;</a></p>
  <div id="source-precession.xi_contour" class="source">
    <pre><code>def xi_contour(varphi,S,J,q,S1,S2,r):

    '''
    Compute the projection of the effective spin xi as a function of the spin-rotation degree of freedom
    varphi and the total spin magnitude S.
 
    **Call:**

        xi=precession.xi_contour(varphi,S,J,q,S1,S2,r)
    
    **Parameters:**
    
    - `varphi`: angle describing the rotation of S1 and S2 about S, in a frame aligned with J.
    - `S`: magnitude of the total spin.
    - `J`: magnitude of the total angular momentum.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `r`: binary separation.

    **Returns:**

    - `xi`: projection of the effective spin along the orbital angular momentum.
    '''

    L=(q/(1.+q)**2)*(r*M**3)**.5
    t1=(1.+q)/(4.*q*M**2*S**2*L)
    t2=J**2-L**2-S**2
    t3=S**2*(1.+q)-(S1**2-S2**2)*(1.-q)
    t4=(1.-q)*((L+S)**2-J**2)**.5
    t5=(J**2-(L-S)**2)**.5             
    t6=((S1+S2)**2-S**2)**.5
    t7=(S**2-(S1-S2)**2)**.5
    return t1*((t2*t3)-(t4*t5*t6*t7*np.cos(varphi)))  
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.xi_lim">
    <p>def <span class="ident">xi_lim</span>(</p><p>q, S1, S2)</p>
    </div>
    

    
  
    <div class="desc"><p>Compute the absolute limits on xi (i.e. regardless of J). Check <a href="#precession.xi_allowed"><code>xi_allowed</code></a> for the limits on xi for a given J. This functions is simply checks -1&lt;cos(theta_i)&lt;1.</p>
<p><strong>Call:</strong></p>
<pre><code>xi_min,xi_max=precession.xi_lim(q,S1,S2)
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>xi_min</code>: minimum value of xi from geometrical constraints.</li>
<li><code>xi_max</code>: maximum value of xi from geometrical constraints.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.xi_lim', this);">Show source &equiv;</a></p>
  <div id="source-precession.xi_lim" class="source">
    <pre><code>def xi_lim(q,S1,S2):

    '''
    Compute the absolute limits on xi (i.e. regardless of J). Check `precession.xi_allowed` for the limits on xi for a given J. This functions is simply checks -1<cos(theta_i)<1.

    **Call:**

        xi_min,xi_max=precession.xi_lim(q,S1,S2)
    
    **Parameters:**
    
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    
    **Returns:**
    
    - `xi_min`: minimum value of xi from geometrical constraints.
    - `xi_max`: maximum value of xi from geometrical constraints.
    '''

    xi_max= ((1.+q)*S1+(1.+q**-1)*S2)*M**-2
    xi_min=-1.*xi_max
    return xi_min,xi_max    
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.xi_minus">
    <p>def <span class="ident">xi_minus</span>(</p><p>S, J, q, S1, S2, r)</p>
    </div>
    

    
  
    <div class="desc"><p>Lower effective potential, corresponding to cos(varphi)=+1.</p>
<p><strong>Call:</strong></p>
<pre><code>xi=precession.xi_minus(S,J,q,S1,S2,r)
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>S</code>: magnitude of the total spin.</li>
<li><code>J</code>: magnitude of the total angular momentum.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>r</code>: binary separation.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.xi_minus', this);">Show source &equiv;</a></p>
  <div id="source-precession.xi_minus" class="source">
    <pre><code>def xi_minus(S,J,q,S1,S2,r):
    
    '''
    Lower effective potential, corresponding to cos(varphi)=+1.

    **Call:**

        xi=precession.xi_minus(S,J,q,S1,S2,r)
    
    **Parameters:**
    
    - `S`: magnitude of the total spin.
    - `J`: magnitude of the total angular momentum.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `r`: binary separation.

    **Returns:**

    - `xi`: projection of the effective spin along the orbital angular momentum.
    '''
    
    # Do it explicitely. Somehow faster than calling xi_contour(np.pi,...)    
    L=(q/(1.+q)**2)*(r*M**3)**.5
    t1=(1.+q)/(4.*q*M**2*S**2*L)
    t2=J**2-L**2-S**2
    t3=S**2*(1.+q)-(S1**2-S2**2)*(1.-q)

    if S in St_limits(J,q,S1,S2,r): #if you're on the limits, the second bit must be zero
        t4=t5=t6=t7=0.
    else:
        t4=(1.-q)*((L+S)**2-J**2)**.5
        t5=(J**2-(L-S)**2)**.5             
        t6=((S1+S2)**2-S**2)**.5
        t7=(S**2-(S1-S2)**2)**.5    

    return t1*((t2*t3)-(t4*t5*t6*t7*(1.)))  
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.xi_minus_comp">
    <p>def <span class="ident">xi_minus_comp</span>(</p><p>S, kappa, q, S1, S2, u)</p>
    </div>
    

    
  
    <div class="desc"><p>Auxiliary function, see <a href="#precession.xi_minus"><code>xi_minus</code></a>.</p>
<p><strong>Call:</strong></p>
<pre><code>xi=precession.xi_minus_comp(S,kappa,q,S1,S2,u)
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>S</code>: magnitude of the total spin.</li>
<li><code>kappa</code>: rescaling of the total angular momentum to compactify the inspiral domain.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>u</code>: rescaling of the orbital angular momentum to compactify the inspiral domain.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.xi_minus_comp', this);">Show source &equiv;</a></p>
  <div id="source-precession.xi_minus_comp" class="source">
    <pre><code>def xi_minus_comp(S,kappa,q,S1,S2,u):
    
    '''
    Auxiliary function, see `precession.xi_minus`.
        
    **Call:**

        xi=precession.xi_minus_comp(S,kappa,q,S1,S2,u)

    **Parameters:**
    
    - `S`: magnitude of the total spin.
    - `kappa`: rescaling of the total angular momentum to compactify the inspiral domain.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `u`: rescaling of the orbital angular momentum to compactify the inspiral domain.

    **Returns:**

    - `xi`: projection of the effective spin along the orbital angular momentum.
    '''
    
    t1= kappa-u*S**2
    t2=S**2*(1.+q)**2-(S1**2-S2**2)*(1.-q**2)
    if S in St_limits_comp(kappa,q,S1,S2,u): #if you're on the limits, the second bit must be zero
        t3=t4=t5=0
    else:
        t3=(1.-q**2)*(S**2 - kappa**2-u**2*S**4+2.*u*kappa*S**2)**0.5
        t4=((S1+S2)**2-S**2)**.5
        t5=(S**2-(S1-S2)**2)**.5    
    t6= 2.*q*M**2*S**2
    return (t1*t2 - t3*t4*t5)/t6
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.xi_plus">
    <p>def <span class="ident">xi_plus</span>(</p><p>S, J, q, S1, S2, r)</p>
    </div>
    

    
  
    <div class="desc"><p>Upper effective potential, corresponding to cos(varphi)=-1.</p>
<p><strong>Call:</strong></p>
<pre><code>xi=precession.xi_plus(S,J,q,S1,S2,r)
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>S</code>: magnitude of the total spin.</li>
<li><code>J</code>: magnitude of the total angular momentum.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>r</code>: binary separation.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.xi_plus', this);">Show source &equiv;</a></p>
  <div id="source-precession.xi_plus" class="source">
    <pre><code>def xi_plus(S,J,q,S1,S2,r):

    '''
    Upper effective potential, corresponding to cos(varphi)=-1.
 
    **Call:**

        xi=precession.xi_plus(S,J,q,S1,S2,r)

    **Parameters:**
    
    - `S`: magnitude of the total spin.
    - `J`: magnitude of the total angular momentum.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `r`: binary separation.

    **Returns:**

    - `xi`: projection of the effective spin along the orbital angular momentum.
    '''
    
    # Do it explicitely. Somehow faster than calling xi_contour(np.pi,...)
    L=(q/(1.+q)**2)*(r*M**3)**.5
    t1=(1.+q)/(4.*q*M**2*S**2*L)
    t2=J**2-L**2-S**2
    t3=S**2*(1.+q)-(S1**2-S2**2)*(1.-q)

    if S in St_limits(J,q,S1,S2,r): #if you're on the limits, the second bit must be zero
        t4=t5=t6=t7=0.
    else:
        t4=(1.-q)*((L+S)**2-J**2)**.5
        t5=(J**2-(L-S)**2)**.5             
        t6=((S1+S2)**2-S**2)**.5
        t7=(S**2-(S1-S2)**2)**.5    

    return t1*((t2*t3)-(t4*t5*t6*t7*(-1.)))  
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.xi_plus_comp">
    <p>def <span class="ident">xi_plus_comp</span>(</p><p>S, kappa, q, S1, S2, u)</p>
    </div>
    

    
  
    <div class="desc"><p>Auxiliary function, see <a href="#precession.xi_plus"><code>xi_plus</code></a>.</p>
<p><strong>Call:</strong></p>
<pre><code>xi=precession.xi_plus_comp(S,kappa,q,S1,S2,u)
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>S</code>: magnitude of the total spin.</li>
<li><code>kappa</code>: rescaling of the total angular momentum to compactify the inspiral domain.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
<li><code>u</code>: rescaling of the orbital angular momentum to compactify the inspiral domain.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>xi</code>: projection of the effective spin along the orbital angular momentum.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.xi_plus_comp', this);">Show source &equiv;</a></p>
  <div id="source-precession.xi_plus_comp" class="source">
    <pre><code>def xi_plus_comp(S,kappa,q,S1,S2,u):

    '''
    Auxiliary function, see `precession.xi_plus`.
    
    **Call:**

        xi=precession.xi_plus_comp(S,kappa,q,S1,S2,u)

    **Parameters:**
    
    - `S`: magnitude of the total spin.
    - `kappa`: rescaling of the total angular momentum to compactify the inspiral domain.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.
    - `u`: rescaling of the orbital angular momentum to compactify the inspiral domain.

    **Returns:**

    - `xi`: projection of the effective spin along the orbital angular momentum.
    '''

    t1= kappa-u*S**2
    t2=S**2*(1.+q)**2-(S1**2-S2**2)*(1.-q**2)
    if S in St_limits_comp(kappa,q,S1,S2,u): #if you're on the limits, the second bit must be zero
        t3=t4=t5=0
    else:
        t3=(1.-q**2)*(S**2 - kappa**2-u**2*S**4+2.*u*kappa*S**2)**0.5        
        t4=((S1+S2)**2-S**2)**.5
        t5=(S**2-(S1-S2)**2)**.5    
    t6= 2.*q*M**2*S**2
    return (t1*t2 + t3*t4*t5)/t6
</code></pre>
  </div>
</div>

  </div>
  
      
  <div class="item">
    <div class="name def" id="precession.xiinf_allowed">
    <p>def <span class="ident">xiinf_allowed</span>(</p><p>kappa_inf, q, S1, S2)</p>
    </div>
    

    
  
    <div class="desc"><p>Limits on xi for a given value of kappa_inf, obtained forcing -1&lt;cos(theta_i)&lt;1.</p>
<p><strong>Call:</strong></p>
<pre><code>xi_low,xi_up=precession.xiinf_allowed(kappa_inf,q,S1,S2)
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>kappa_inf</code>: asymptotic value of kappa at large separations.</li>
<li><code>q</code>: binary mass ratio. Must be q&lt;=1.</li>
<li><code>S1</code>: spin magnitude of the primary BH.</li>
<li><code>S2</code>: spin magnitude of the secondary BH.</li>
</ul>
<p><strong>Returns:</strong></p>
<ul>
<li><code>xi_low</code>: minimum allowed value of xi, given the input parameters.</li>
<li><code>xi_up</code>: maximum allowed value of xi, given the input parameters.</li>
</ul></div>
  <div class="source_cont">
  <p class="source_link"><a href="javascript:void(0);" onclick="toggle('source-precession.xiinf_allowed', this);">Show source &equiv;</a></p>
  <div id="source-precession.xiinf_allowed" class="source">
    <pre><code>def xiinf_allowed(kappa_inf,q,S1,S2):
 
    '''
    Limits on xi for a given value of kappa_inf, obtained forcing -1<cos(theta_i)<1.
 
    **Call:**

        xi_low,xi_up=precession.xiinf_allowed(kappa_inf,q,S1,S2)
    
    **Parameters:**
    
    - `kappa_inf`: asymptotic value of kappa at large separations.
    - `q`: binary mass ratio. Must be q<=1.
    - `S1`: spin magnitude of the primary BH.
    - `S2`: spin magnitude of the secondary BH.

    **Returns:**

    - `xi_low`: minimum allowed value of xi, given the input parameters.
    - `xi_up`: maximum allowed value of xi, given the input parameters.
    '''
    
    xi_low = max( kappa_inf*(1+q) - (q**-1-q)*S2 , kappa_inf*(1+q**-1) - (q**-1-q)*S1 )
    xi_up = min( kappa_inf*(1+q) + (q**-1-q)*S2 , kappa_inf*(1+q**-1) + (q**-1-q)*S1 )
    return xi_low,xi_up
</code></pre>
  </div>
</div>

  </div>
  


    <h2 class="section-title" id="header-submodules">Sub-modules</h2>
      <div class="item">
      <p class="name"><a href="tutorial.m.html">precession.tutorial</a></p>
      
  

      </div>
  </section>

    </article>
  <div class="clear"> </div>
  <footer id="footer">
    <p>
      Documentation generated by
      <a href="https://github.com/BurntSushi/pdoc">pdoc 0.3.1</a>
    </p>

    <p>pdoc is in the public domain with the
      <a href="http://unlicense.org">UNLICENSE</a></p>

    <p>Design by <a href="http://nadh.in">Kailash Nadh</a></p>
  </footer>
</div>
</body>
</html>
